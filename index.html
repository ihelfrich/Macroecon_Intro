<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ECON 205 Midterm I Study Studio</title>
  <meta name="description" content="USC ECON 205 Midterm I learning studio with rendered math, adaptive recall, and timed macro drills by Dr. Ian Helfrich." />
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [["\\(", "\\)"], ["$", "$"]],
        displayMath: [["\\[", "\\]"], ["$$", "$$"]]
      },
      options: {
        skipHtmlTags: ["script", "noscript", "style", "textarea", "pre", "code"]
      }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Sora:wght@300;400;600;700;800&amp;family=Fraunces:opsz,wght@9..144,300;9..144,500;9..144,700&amp;family=JetBrains+Mono:wght@400;600&amp;display=swap" rel="stylesheet">
  <style>
    :root {
      --usc-cardinal: #990000;
      --usc-cardinal-deep: #6f0000;
      --usc-gold: #ffcc00;
      --usc-gold-deep: #d89900;
      --paper: #f6f0e5;
      --paper-soft: #fbf7ef;
      --ink: #1f1b16;
      --muted: #5f564d;
      --sage: #dbe7d4;
      --ocean: #1f4b5a;
      --ocean-soft: #34697b;
      --border: #d5c8b6;
      --shadow: 0 18px 40px rgba(34, 25, 18, 0.16);
      --shadow-deep: 0 32px 64px rgba(31, 18, 11, 0.24);
      --radius-lg: 18px;
      --radius-md: 12px;
      --radius-sm: 8px;
      --maxw: 1180px;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
    }

    body {
      font-family: "Sora", system-ui, sans-serif;
      color: var(--ink);
      background:
        radial-gradient(1300px 700px at -10% -8%, rgba(255, 204, 0, 0.24), transparent 56%),
        radial-gradient(900px 520px at 108% -6%, rgba(31, 75, 90, 0.18), transparent 60%),
        radial-gradient(900px 500px at 98% 10%, rgba(153, 0, 0, 0.12), transparent 68%),
        linear-gradient(180deg, #faf5ea 0%, #f2e7d4 48%, #f1e2ce 100%);
      line-height: 1.5;
      min-height: 100vh;
      overflow-x: hidden;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image:
        linear-gradient(rgba(121, 98, 77, 0.07) 1px, transparent 1px),
        linear-gradient(90deg, rgba(121, 98, 77, 0.07) 1px, transparent 1px);
      background-size: 38px 38px;
      mask-image: linear-gradient(to bottom, rgba(0,0,0,0.34), rgba(0,0,0,0.07));
      z-index: -1;
    }

    a {
      color: var(--usc-cardinal);
      text-decoration-thickness: 2px;
      text-underline-offset: 2px;
    }

    .shell {
      width: min(var(--maxw), 92vw);
      margin: 0 auto;
      padding: 16px 0 48px;
    }

    .topbar {
      position: sticky;
      top: 10px;
      z-index: 50;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin: 10px auto 22px;
      padding: 10px 14px;
      border: 1px solid rgba(111, 0, 0, 0.2);
      border-radius: 999px;
      background: rgba(251, 247, 239, 0.9);
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 24px rgba(50, 29, 22, 0.1);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      font-size: 0.95rem;
      letter-spacing: 0.02em;
    }

    .brand-copy {
      display: grid;
      gap: 1px;
      line-height: 1.15;
    }

    .brand-title {
      font-weight: 700;
      font-size: 0.95rem;
      color: #2f261e;
    }

    .brand-credit {
      font-size: 0.68rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-weight: 700;
      color: #71675e;
      opacity: 0.86;
    }

    .crest {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      color: #fff;
      background: linear-gradient(145deg, var(--usc-cardinal), var(--usc-cardinal-deep));
      font-family: "Fraunces", serif;
      font-weight: 700;
      font-size: 0.78rem;
    }

    .top-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .auth-chip {
      font-size: 0.74rem;
      border: 1px solid #ddccb8;
      border-radius: 999px;
      padding: 5px 10px;
      background: #fff;
      color: #54493f;
      font-weight: 700;
      letter-spacing: 0.02em;
      display: inline-flex;
      align-items: center;
    }
    .auth-chip.warn {
      border-color: rgba(143, 63, 0, 0.34);
      color: #7a3600;
      background: #fff7ec;
    }
    .auth-chip.danger {
      border-color: rgba(155, 18, 18, 0.34);
      color: #7f1010;
      background: #fff1f1;
    }

    .admin-inline {
      display: none;
    }

    body[data-role="admin"] .admin-inline {
      display: inline-flex;
    }

    .admin-only {
      display: none;
    }

    body[data-role="admin"] .admin-only {
      display: block;
    }

    body.auth-locked {
      overflow: hidden;
    }

    .auth-gate {
      position: fixed;
      inset: 0;
      z-index: 130;
      display: grid;
      place-items: center;
      padding: 18px;
      background:
        radial-gradient(1100px 540px at 0% 0%, rgba(255, 204, 0, 0.22), transparent 62%),
        radial-gradient(900px 500px at 100% 0%, rgba(153, 0, 0, 0.16), transparent 68%),
        rgba(25, 18, 13, 0.44);
      backdrop-filter: blur(8px);
    }

    .auth-gate.hidden {
      display: none;
    }

    .auth-card {
      width: min(540px, 92vw);
      border: 1px solid rgba(224, 205, 184, 0.9);
      border-radius: 16px;
      background: linear-gradient(180deg, #fffefb 0%, #fff4e2 100%);
      box-shadow: 0 26px 56px rgba(22, 14, 9, 0.34);
      padding: 16px;
      display: grid;
      gap: 12px;
    }

    .auth-card h2 {
      margin: 0;
      font-family: "Fraunces", serif;
      font-size: 1.5rem;
      color: #3a2b1f;
      line-height: 1.18;
    }

    .auth-card p {
      margin: 0;
      color: #5f5247;
      font-size: 0.9rem;
    }

    .auth-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .auth-input {
      flex: 1 1 260px;
      min-width: 220px;
      border: 1px solid #dcc6ab;
      border-radius: 10px;
      padding: 9px 11px;
      font-size: 0.92rem;
      color: #33291f;
      background: #fff;
      font-family: "Sora", system-ui, sans-serif;
    }

    .auth-input:focus-visible {
      outline: 2px solid rgba(153, 0, 0, 0.34);
      outline-offset: 1px;
      border-color: rgba(153, 0, 0, 0.4);
    }

    .auth-help {
      font-size: 0.76rem;
      color: #6d5f52;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      font-weight: 700;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .auth-message {
      min-height: 1.2em;
      font-size: 0.84rem;
      color: #6a594c;
    }

    .auth-message.error {
      color: #8f1f1f;
      font-weight: 700;
    }

    .btn {
      border: 1px solid transparent;
      border-radius: 999px;
      padding: 8px 12px;
      font-weight: 600;
      font-size: 0.82rem;
      cursor: pointer;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 7px;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.14);
    }

    .btn:disabled,
    .btn:disabled:hover {
      cursor: not-allowed;
      opacity: 0.56;
      box-shadow: none;
      transform: none;
    }

    .btn-primary {
      color: #fff;
      background: linear-gradient(140deg, var(--usc-cardinal), var(--usc-cardinal-deep));
    }

    .btn-ghost {
      color: var(--usc-cardinal);
      background: #fff;
      border-color: rgba(153, 0, 0, 0.24);
    }

    .command-shell {
      position: fixed;
      inset: 0;
      z-index: 120;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .command-shell.open {
      opacity: 1;
      pointer-events: auto;
    }

    .command-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(26, 17, 12, 0.36);
      backdrop-filter: blur(6px);
    }

    .command-dialog {
      position: relative;
      width: min(760px, 92vw);
      margin: 68px auto 0;
      border: 1px solid rgba(223, 205, 184, 0.95);
      border-radius: 16px;
      background: linear-gradient(180deg, #fffefc 0%, #fff5e6 100%);
      box-shadow: 0 24px 56px rgba(28, 17, 11, 0.32);
      overflow: hidden;
    }

    .command-head {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px;
      border-bottom: 1px solid #e4d4bf;
      background: rgba(255, 255, 255, 0.86);
    }

    .command-input {
      width: 100%;
      border: 1px solid #dfcdb7;
      border-radius: 10px;
      padding: 9px 11px;
      font-size: 0.9rem;
      color: #30271f;
      background: #fff;
      font-family: "Sora", system-ui, sans-serif;
    }

    .command-input:focus-visible {
      outline: 2px solid rgba(153, 0, 0, 0.35);
      outline-offset: 1px;
      border-color: rgba(153, 0, 0, 0.42);
    }

    .command-hint {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.74rem;
      color: #60564d;
      border: 1px solid #ddccb7;
      border-radius: 8px;
      background: #fff;
      padding: 4px 7px;
      white-space: nowrap;
    }

    .command-list {
      max-height: min(62vh, 540px);
      overflow: auto;
      padding: 8px;
      display: grid;
      gap: 6px;
    }

    .command-item {
      width: 100%;
      text-align: left;
      border: 1px solid #e3d4c1;
      border-radius: 10px;
      background: #fff;
      color: #372e26;
      padding: 9px 10px;
      cursor: pointer;
      display: grid;
      gap: 2px;
      transition: transform 0.14s ease, border-color 0.14s ease, box-shadow 0.14s ease;
    }

    .command-item:hover,
    .command-item.active {
      transform: translateY(-1px);
      border-color: rgba(153, 0, 0, 0.4);
      box-shadow: 0 9px 20px rgba(48, 30, 18, 0.12);
    }

    .command-item .title {
      font-size: 0.88rem;
      font-weight: 700;
      color: #3a2d22;
    }

    .command-item .meta {
      font-size: 0.74rem;
      color: #6c6258;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 700;
    }

    .hero {
      --hero-shift-x: 0px;
      --hero-shift-y: 0px;
      position: relative;
      overflow: hidden;
      border-radius: calc(var(--radius-lg) + 6px);
      border: 1px solid #d4c4ad;
      box-shadow: var(--shadow-deep);
      background:
        radial-gradient(700px 280px at 0% 0%, rgba(255, 204, 0, 0.32), transparent 58%),
        linear-gradient(130deg, #fff8ec 0%, #f5e5cc 45%, #f0ddbc 100%);
      padding: 26px clamp(18px, 3vw, 34px) 24px;
      isolation: isolate;
    }

    .hero::after {
      content: "";
      position: absolute;
      right: -80px;
      top: -40px;
      width: 320px;
      height: 320px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 35%, rgba(153, 0, 0, 0.45), rgba(153, 0, 0, 0.1) 60%, transparent 72%);
      transform: translate3d(var(--hero-shift-x), var(--hero-shift-y), 0);
      transition: transform 0.22s ease-out;
      z-index: -1;
    }

    .hero::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        repeating-linear-gradient(118deg, rgba(255, 255, 255, 0.3) 0, rgba(255, 255, 255, 0.3) 2px, transparent 2px, transparent 14px);
      mask-image: linear-gradient(to bottom, rgba(0,0,0,0.3), transparent 72%);
      pointer-events: none;
      z-index: -1;
    }

    .hero-kicker {
      margin: 0;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--ocean);
      font-size: 0.74rem;
    }

    .hero h1 {
      margin: 6px 0 0;
      font-family: "Fraunces", serif;
      font-weight: 700;
      line-height: 1.06;
      font-size: clamp(1.9rem, 4vw, 3rem);
      letter-spacing: 0.01em;
    }

    .hero .sub {
      margin: 10px 0 0;
      color: var(--muted);
      max-width: 70ch;
      font-size: clamp(0.95rem, 1.6vw, 1.05rem);
    }

    .hero-art {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      overflow: hidden;
    }

    .hero-layer {
      position: absolute;
      border-radius: 50%;
      opacity: 0.74;
      will-change: transform;
      transition: transform 0.14s linear;
      filter: saturate(1.08);
      transform: translate3d(0, var(--parallax-y, 0px), 0);
    }

    .hero-layer.layer-a {
      width: 230px;
      height: 230px;
      top: 8%;
      left: 58%;
      background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.85), rgba(255, 204, 0, 0.44), rgba(255, 204, 0, 0.08) 72%);
    }

    .hero-layer.layer-b {
      width: 300px;
      height: 300px;
      top: 22%;
      left: 74%;
      background: radial-gradient(circle at 40% 40%, rgba(255, 255, 255, 0.22), rgba(52, 105, 123, 0.4), rgba(52, 105, 123, 0.04) 70%);
    }

    .hero-layer.layer-c {
      width: 260px;
      height: 260px;
      top: 62%;
      left: -4%;
      background: radial-gradient(circle at 44% 44%, rgba(255, 255, 255, 0.3), rgba(153, 0, 0, 0.28), rgba(153, 0, 0, 0.05) 72%);
    }

    .hero-grid {
      position: absolute;
      left: -4%;
      right: -4%;
      top: 56%;
      height: 220px;
      background:
        linear-gradient(rgba(111, 0, 0, 0.2) 1px, transparent 1px),
        linear-gradient(90deg, rgba(111, 0, 0, 0.14) 1px, transparent 1px);
      background-size: 46px 28px;
      transform: translate3d(0, var(--parallax-y, 0px), 0) perspective(420px) rotateX(66deg);
      transform-origin: center top;
      opacity: 0.3;
      mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.76), transparent 90%);
    }

    .chip-row {
      margin-top: 16px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      font-size: 0.78rem;
      border: 1px solid #d7c4ab;
      border-radius: 999px;
      padding: 5px 10px;
      background: rgba(255, 255, 255, 0.7);
      color: #433a30;
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    .chip-status-ok {
      border-color: rgba(18, 122, 74, 0.36);
      color: #1d5f43;
      background: rgba(241, 255, 249, 0.84);
    }

    .chip-status-warn {
      border-color: rgba(147, 66, 0, 0.34);
      color: #7f4400;
      background: rgba(255, 248, 237, 0.9);
    }

    .section {
      margin-top: 24px;
      border-radius: var(--radius-lg);
      border: 1px solid var(--border);
      background:
        linear-gradient(180deg, #fefcf8 0%, var(--paper-soft) 100%);
      box-shadow: 0 10px 28px rgba(52, 34, 23, 0.08);
      padding: clamp(16px, 2.2vw, 24px);
      position: relative;
      overflow: hidden;
    }

    .section::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      height: 3px;
      background: linear-gradient(90deg, rgba(153, 0, 0, 0.16), rgba(255, 204, 0, 0.38), rgba(31, 75, 90, 0.2));
      pointer-events: none;
    }

    .reveal {
      opacity: 0;
      transform: translateY(18px);
      transition: opacity 0.55s ease, transform 0.55s ease;
    }

    .reveal.is-visible {
      opacity: 1;
      transform: translateY(0);
    }

    .section h2 {
      margin: 0 0 6px;
      font-family: "Fraunces", serif;
      font-size: clamp(1.3rem, 2.1vw, 1.9rem);
      letter-spacing: 0.01em;
    }

    .section p.lead {
      margin: 0;
      color: var(--muted);
      max-width: 78ch;
      font-size: 0.95rem;
    }

    .grid {
      margin-top: 14px;
      display: grid;
      gap: 12px;
    }

    .grid.cols-2 {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .grid.cols-3 {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .card {
      background: #fff;
      border: 1px solid #e1d4c2;
      border-radius: var(--radius-md);
      padding: 14px;
      box-shadow: 0 8px 20px rgba(49, 31, 22, 0.08);
      transform-origin: center;
      animation: rise 0.5s ease both;
    }

    .card:nth-child(2) { animation-delay: 0.05s; }
    .card:nth-child(3) { animation-delay: 0.1s; }
    .card:nth-child(4) { animation-delay: 0.15s; }
    .card:nth-child(5) { animation-delay: 0.2s; }
    .card:nth-child(6) { animation-delay: 0.25s; }

    @keyframes rise {
      from {
        opacity: 0;
        transform: translateY(8px) scale(0.99);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .card h3 {
      margin: 0 0 8px;
      font-size: 1rem;
      line-height: 1.3;
      color: var(--usc-cardinal-deep);
    }

    .card ul {
      margin: 0;
      padding-left: 18px;
      color: #3f352d;
    }

    .card li {
      margin: 4px 0;
      font-size: 0.9rem;
    }

    .formula-board {
      margin-top: 12px;
      border-radius: var(--radius-md);
      border: 1px solid #d6c3ac;
      background: linear-gradient(180deg, #fffdfa 0%, #fff5e6 100%);
      padding: 12px;
      display: grid;
      gap: 8px;
    }

    .formula {
      border: 1px solid #e5d3be;
      border-left: 5px solid var(--usc-cardinal);
      border-radius: 8px;
      background: #fff;
      padding: 8px 10px;
      font-family: "Fraunces", serif;
      font-size: 1rem;
      color: #2b2722;
      white-space: pre-wrap;
      text-align: center;
    }

    .formula .mjx-container,
    .flash-q .mjx-container,
    .flash-a .mjx-container {
      margin: 0.15rem 0 !important;
      line-height: 1.25 !important;
    }

    .formula-workbench {
      margin-top: 12px;
      display: grid;
      gap: 12px;
      grid-template-columns: minmax(240px, 0.84fr) minmax(420px, 1.16fr);
      align-items: start;
    }

    .formula-catalog {
      border: 1px solid #deccb7;
      border-radius: 14px;
      background: linear-gradient(180deg, #fffefb 0%, #fff6e9 100%);
      box-shadow: 0 10px 24px rgba(45, 27, 16, 0.08);
      padding: 10px;
      display: grid;
      gap: 8px;
      max-height: 760px;
      overflow: auto;
    }

    .formula-item {
      width: 100%;
      border: 1px solid #decab2;
      border-radius: 10px;
      background: #fff;
      padding: 8px 10px;
      text-align: left;
      cursor: pointer;
      display: grid;
      gap: 4px;
      transition: transform 0.14s ease, border-color 0.14s ease, box-shadow 0.14s ease;
    }

    .formula-item:hover {
      transform: translateY(-1px);
      border-color: rgba(153, 0, 0, 0.33);
      box-shadow: 0 8px 18px rgba(43, 25, 15, 0.1);
    }

    .formula-item.active {
      border-color: rgba(153, 0, 0, 0.45);
      background: linear-gradient(180deg, #fffaf3 0%, #fff3e5 100%);
      box-shadow: 0 9px 20px rgba(153, 0, 0, 0.14);
    }

    .formula-item .kicker {
      font-size: 0.7rem;
      color: #6b5a4b;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 700;
    }

    .formula-item .title {
      font-size: 0.86rem;
      font-weight: 700;
      color: #3c2d22;
      line-height: 1.3;
    }

    .formula-item .math {
      font-size: 0.83rem;
      color: #4a3a2f;
      font-family: "Fraunces", serif;
      line-height: 1.25;
    }

    .formula-main {
      display: grid;
      gap: 12px;
    }

    .formula-panel {
      border: 1px solid #deccb5;
      border-radius: 14px;
      background: linear-gradient(180deg, #fffefc 0%, #fff6e9 100%);
      padding: 12px;
      display: grid;
      gap: 10px;
      box-shadow: 0 12px 26px rgba(55, 35, 20, 0.08);
    }

    .formula-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .formula-head h3 {
      margin: 0;
      color: #452d1f;
      font-size: 0.98rem;
      letter-spacing: 0.01em;
    }

    .formula-topic {
      border: 1px solid #ddccb8;
      border-radius: 999px;
      background: #fff;
      padding: 3px 9px;
      font-size: 0.72rem;
      color: #5d5248;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      white-space: nowrap;
    }

    .formula-latex {
      min-height: 58px;
      display: grid;
      place-items: center;
      text-align: center;
      font-size: 1.06rem;
      line-height: 1.3;
    }

    .formula-intuition {
      margin: 0;
      font-size: 0.86rem;
      color: #4f4338;
      line-height: 1.45;
      border: 1px solid #dfccb5;
      border-radius: 10px;
      background: #fff;
      padding: 9px 10px;
    }

    .formula-focus-list {
      margin: 0;
      padding-left: 18px;
      color: #4b4036;
      font-size: 0.84rem;
      display: grid;
      gap: 5px;
    }

    .formula-variable-cloud {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .formula-var-chip {
      border: 1px solid #dec9b2;
      border-radius: 999px;
      background: #fff;
      color: #3d3025;
      font-size: 0.79rem;
      font-weight: 700;
      letter-spacing: 0.01em;
      padding: 5px 10px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: border-color 0.14s ease, box-shadow 0.14s ease, transform 0.14s ease;
    }

    .formula-var-chip:hover {
      transform: translateY(-1px);
      border-color: rgba(153, 0, 0, 0.35);
      box-shadow: 0 6px 14px rgba(43, 25, 15, 0.1);
    }

    .formula-var-chip.active {
      border-color: rgba(153, 0, 0, 0.45);
      background: linear-gradient(180deg, #fffaf3 0%, #fff2e2 100%);
      box-shadow: 0 7px 16px rgba(153, 0, 0, 0.14);
    }

    .formula-var-chip .symbol {
      font-family: "Fraunces", serif;
      font-size: 0.86rem;
      color: var(--usc-cardinal-deep);
      line-height: 1.1;
    }

    .formula-var-symbol {
      border: 1px solid #deccb6;
      border-radius: 10px;
      background: #fff;
      padding: 8px 10px;
      color: #3f3126;
      font-family: "Fraunces", serif;
      font-size: 1.04rem;
      text-align: center;
    }

    .formula-meta-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    .formula-meta {
      border: 1px solid #dfcdb8;
      border-radius: 10px;
      background: #fff;
      padding: 8px 10px;
      display: grid;
      gap: 4px;
      align-content: start;
    }

    .formula-meta span {
      font-size: 0.72rem;
      color: #63564b;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-weight: 700;
    }

    .formula-meta strong {
      font-size: 0.82rem;
      color: #3f3329;
      line-height: 1.35;
      font-weight: 700;
    }

    .formula-data-lab {
      gap: 11px;
    }

    .formula-data-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .formula-field {
      display: grid;
      gap: 6px;
    }

    .formula-field label {
      font-size: 0.78rem;
      color: #5a4d43;
      font-weight: 700;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }

    .formula-field input,
    .formula-field select {
      border: 1px solid #dbc7af;
      border-radius: 10px;
      background: #fff;
      color: #342a22;
      font-size: 0.85rem;
      padding: 7px 10px;
      min-height: 38px;
    }

    .formula-field input[type="password"] {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.8rem;
    }

    .formula-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .formula-binding-table {
      display: grid;
      gap: 6px;
    }

    .formula-binding-row {
      border: 1px solid #e0ceb8;
      border-radius: 10px;
      background: #fff;
      padding: 8px 10px;
      display: grid;
      gap: 8px;
      grid-template-columns: minmax(88px, 0.55fr) minmax(90px, 0.5fr) minmax(82px, 0.5fr) minmax(160px, 1fr);
      align-items: center;
      text-align: left;
      cursor: pointer;
      font: inherit;
      color: inherit;
    }

    .formula-binding-row.header {
      border-style: dashed;
      background: #fffaf2;
      color: #645649;
      font-size: 0.72rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      font-weight: 700;
      padding-top: 7px;
      padding-bottom: 7px;
      cursor: default;
    }

    .formula-binding-row.active {
      border-color: rgba(153, 0, 0, 0.4);
      background: linear-gradient(180deg, #fffbf6 0%, #fff2e4 100%);
    }

    .formula-binding-row button {
      border: none;
      background: none;
      text-align: left;
      padding: 0;
      font: inherit;
      color: inherit;
      cursor: pointer;
    }

    .formula-binding-row .cell-value {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.8rem;
      color: #3e3126;
      font-weight: 700;
    }

    .formula-binding-row .cell-source {
      font-size: 0.76rem;
      color: #5d5146;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .formula-binding-row .cell-series {
      font-size: 0.77rem;
      color: #594d42;
      line-height: 1.3;
    }

    .formula-compute-solution {
      display: none;
      border: 1px dashed #d8c3a8;
      border-radius: 10px;
      background: #fff;
      padding: 10px;
      color: #4f4338;
      font-size: 0.86rem;
      line-height: 1.45;
    }

    .formula-compute-solution.show {
      display: block;
    }

    .playbook-step {
      display: grid;
      grid-template-columns: 34px 1fr;
      gap: 10px;
      align-items: start;
      padding: 9px;
      border-radius: 10px;
      background: #fff;
      border: 1px solid #e6d9ca;
    }

    .step-num {
      width: 34px;
      height: 34px;
      border-radius: 10px;
      background: linear-gradient(145deg, #f9d46a, var(--usc-gold));
      color: #302512;
      font-weight: 800;
      display: grid;
      place-items: center;
    }

    .kpi-strip {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
    }

    .kpi {
      background: linear-gradient(180deg, #fff, #fdf8f2);
      border: 1px solid #e8d9c7;
      border-radius: 12px;
      padding: 10px;
      text-align: center;
    }

    .kpi .n {
      font-family: "Fraunces", serif;
      font-size: 1.5rem;
      color: var(--usc-cardinal);
      line-height: 1.1;
    }

    .kpi .l {
      margin-top: 3px;
      font-size: 0.75rem;
      color: var(--muted);
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }

    .checklist {
      margin-top: 10px;
      display: grid;
      gap: 8px;
    }

    .check {
      display: grid;
      grid-template-columns: 24px 1fr;
      align-items: center;
      gap: 9px;
      border: 1px solid #e3d4c2;
      border-radius: 10px;
      background: #fff;
      padding: 8px 10px;
    }

    .check input {
      width: 18px;
      height: 18px;
      accent-color: var(--usc-cardinal);
      cursor: pointer;
    }

    .flash-wrap {
      margin-top: 10px;
      border: 1px solid #d6c8b7;
      border-radius: 12px;
      background: linear-gradient(180deg, #fffefb, #fff6eb);
      padding: 14px;
      display: grid;
      gap: 10px;
    }

    .flash-q {
      font-weight: 700;
      font-size: 1rem;
      color: #3a2c20;
      min-height: 3.4em;
      display: grid;
      align-items: center;
    }

    .flash-a {
      border: 1px dashed #d6bea3;
      border-radius: 10px;
      padding: 10px;
      background: #fff;
      color: #302a24;
      display: none;
      min-height: 2.5em;
    }

    .flash-mode {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .flash-mode-help {
      font-size: 0.82rem;
      color: #5f5348;
      border: 1px solid #e2d2bf;
      border-radius: 10px;
      background: #fff;
      padding: 8px 10px;
      line-height: 1.4;
    }

    .recall-options {
      display: grid;
      gap: 8px;
    }

    .recall-option {
      border: 1px solid #decab4;
      border-radius: 10px;
      background: #fff;
      padding: 8px 10px;
      display: grid;
      grid-template-columns: auto auto 1fr;
      align-items: center;
      gap: 9px;
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease;
    }

    .recall-option:hover {
      transform: translateY(-1px);
      border-color: rgba(153, 0, 0, 0.3);
      box-shadow: 0 8px 16px rgba(44, 27, 15, 0.09);
    }

    .recall-option input {
      width: 17px;
      height: 17px;
      margin: 0;
      accent-color: var(--usc-cardinal);
    }

    .recall-option .choice-key {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.76rem;
      color: #4e4339;
      border: 1px solid #ddc8b1;
      border-radius: 999px;
      background: #fff9ef;
      padding: 2px 7px;
      font-weight: 700;
      min-width: 28px;
      text-align: center;
    }

    .recall-option .choice-text {
      font-size: 0.86rem;
      color: #3b2f26;
      line-height: 1.35;
    }

    .recall-option.selected {
      border-color: rgba(153, 0, 0, 0.4);
      background: linear-gradient(180deg, #fffdf9 0%, #fff6ea 100%);
    }

    .recall-option.correct {
      border-color: rgba(20, 124, 74, 0.35);
      background: linear-gradient(180deg, #f4fff8 0%, #effcf3 100%);
    }

    .recall-option.wrong {
      border-color: rgba(155, 18, 18, 0.33);
      background: linear-gradient(180deg, #fff8f7 0%, #fff2f1 100%);
    }

    .recall-submit-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .flash-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .flash-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      color: #5a5048;
      font-size: 0.82rem;
      font-weight: 600;
    }

    .flash-meta {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.78rem;
      color: #4a3c30;
      border: 1px solid #dccab5;
      border-radius: 999px;
      padding: 4px 10px;
      background: #fff;
    }

    .rating-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .recall-option input:focus-visible,
    .resource-filter-input:focus-visible,
    .timer-minutes:focus-visible,
    .lab-select:focus-visible,
    .intuition-select:focus-visible,
    .formula-field input:focus-visible,
    .formula-field select:focus-visible,
    .macro-inline-controls select:focus-visible {
      outline: 2px solid rgba(153, 0, 0, 0.35);
      outline-offset: 1px;
      border-color: rgba(153, 0, 0, 0.4);
    }

    .study-stats {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      color: #5a5048;
      font-size: 0.82rem;
    }

    .stat-pill {
      border: 1px solid #dccab5;
      border-radius: 999px;
      padding: 4px 10px;
      background: #fff;
      font-weight: 700;
      font-family: "JetBrains Mono", monospace;
    }

    .live-status {
      margin: 6px 2px 0;
      color: #554a42;
      font-size: 0.82rem;
      min-height: 1.1em;
    }

    .progress-wrap {
      margin-top: 12px;
      padding: 10px;
      border: 1px solid #e2d4c3;
      border-radius: 12px;
      background: #fff;
      display: grid;
      gap: 10px;
    }

    .progress-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 0.84rem;
      color: #574d45;
      flex-wrap: wrap;
    }

    .progress-meta strong {
      color: var(--usc-cardinal-deep);
      font-size: 0.92rem;
    }

    .progress-bar {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: #efe2d1;
      overflow: hidden;
      border: 1px solid #dfcdb8;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #b22424, var(--usc-cardinal), #df6d2b);
      transition: width 0.25s ease;
    }

    .timer-panel {
      margin-top: 12px;
      border: 1px solid #dac7b0;
      border-radius: 14px;
      background: linear-gradient(180deg, #fffdfa 0%, #fff4e4 100%);
      padding: 14px;
      display: grid;
      gap: 12px;
    }

    .timer-display {
      font-family: "JetBrains Mono", monospace;
      font-weight: 700;
      font-size: clamp(1.75rem, 4vw, 2.5rem);
      text-align: center;
      color: var(--usc-cardinal-deep);
      letter-spacing: 0.05em;
      border: 1px solid #dfccb6;
      border-radius: 12px;
      background: #fff;
      padding: 12px 10px;
    }

    .timer-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .timer-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.82rem;
      color: #544a42;
      font-weight: 600;
      border: 1px solid #dfccb6;
      background: #fff;
      border-radius: 999px;
      padding: 5px 8px;
    }

    .timer-minutes {
      width: 72px;
      border: 1px solid #d7c3ac;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 0.82rem;
      font-family: "JetBrains Mono", monospace;
      color: #31281f;
      background: #fffdf9;
    }

    .timer-status {
      font-size: 0.84rem;
      color: #574d45;
      min-height: 1.1em;
    }

    .timer-status.warn {
      color: #8f3f00;
      font-weight: 700;
    }

    .timer-status.danger {
      color: #9b1212;
      font-weight: 800;
    }

    .resource-controls {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }

    .resource-filter-input {
      flex: 1 1 280px;
      min-width: 220px;
      border: 1px solid #dbcab6;
      border-radius: 999px;
      background: #fff;
      padding: 8px 12px;
      font-size: 0.86rem;
      color: #332b24;
    }

    .resource-grid {
      margin-top: 12px;
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .resource {
      display: grid;
      gap: 8px;
      padding: 12px;
      border: 1px solid #e2d2bf;
      border-radius: 12px;
      background: #fff;
    }

    .resource h3 {
      margin: 0;
      font-size: 0.98rem;
      color: #402a1f;
    }

    .resource p {
      margin: 0;
      color: var(--muted);
      font-size: 0.86rem;
    }

    .resource .links {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      border: 1px solid #e1d0bc;
      padding: 4px 9px;
      font-size: 0.75rem;
      font-weight: 700;
      color: #513b2a;
      background: #fff9ef;
      text-decoration: none;
    }

    .timeline {
      margin-top: 12px;
      border-left: 3px solid rgba(153, 0, 0, 0.28);
      padding-left: 16px;
      display: grid;
      gap: 10px;
    }

    .tick {
      position: relative;
      background: #fff;
      border: 1px solid #e5d8c8;
      border-radius: 10px;
      padding: 10px;
    }

    .tick::before {
      content: "";
      position: absolute;
      left: -24px;
      top: 15px;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--usc-cardinal);
      border: 2px solid #ffe6b4;
    }

    .tick strong {
      display: block;
      margin-bottom: 3px;
      color: #3f291f;
      font-size: 0.92rem;
    }

    .tick span {
      color: #5f554e;
      font-size: 0.86rem;
    }

    .lab-grid {
      margin-top: 12px;
      display: grid;
      gap: 12px;
      grid-template-columns: minmax(280px, 0.95fr) minmax(420px, 1.35fr);
      align-items: start;
    }

    .lab-panel {
      border: 1px solid #deccb5;
      border-radius: 14px;
      background: linear-gradient(180deg, #fffefc 0%, #fff7ec 100%);
      padding: 12px;
      display: grid;
      gap: 10px;
      box-shadow: 0 12px 26px rgba(55, 35, 20, 0.08);
    }

    .lab-presets {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .lab-preset {
      padding: 6px 10px;
      font-size: 0.76rem;
      letter-spacing: 0.02em;
    }

    .slider-block {
      display: grid;
      gap: 6px;
    }

    .slider-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 0.86rem;
      color: #4f4338;
      font-weight: 700;
    }

    .slider-row strong {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.84rem;
      color: var(--usc-cardinal-deep);
      background: #fff;
      border: 1px solid #dccab4;
      border-radius: 999px;
      padding: 2px 8px;
    }

    .policy-row {
      display: grid;
      gap: 6px;
      font-size: 0.84rem;
      color: #4f4338;
      font-weight: 700;
    }

    .lab-select {
      width: 100%;
      border: 1px solid #d9c5ad;
      border-radius: 10px;
      padding: 7px 9px;
      color: #332c25;
      font-size: 0.86rem;
      font-weight: 600;
      background: #fff;
    }

    .lab-slider {
      width: 100%;
      accent-color: var(--usc-cardinal);
      cursor: pointer;
    }

    .lab-formulas {
      gap: 6px;
      padding: 8px;
      border-style: dashed;
    }

    .lab-formulas .formula {
      font-size: 0.88rem;
      padding: 7px 9px;
    }

    .lab-note {
      border: 1px solid #deccb5;
      border-radius: 10px;
      padding: 10px;
      background: linear-gradient(170deg, #fff 0%, #fff7ea 100%);
    }

    .lab-note h3 {
      margin: 0 0 4px;
      font-size: 0.9rem;
      color: #462d1e;
    }

    .lab-note p {
      margin: 0;
      font-size: 0.84rem;
      color: #5a4c40;
      line-height: 1.45;
    }

    .lab-chart-panel {
      display: grid;
      gap: 10px;
    }

    .market-svg {
      width: 100%;
      height: auto;
      border: 1px solid #e3d0b8;
      border-radius: 12px;
      background: #fffdf8;
    }

    .lab-metrics {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    .lab-metric {
      border: 1px solid #e0ceb8;
      border-radius: 10px;
      background: #fff;
      padding: 8px 10px;
      display: grid;
      gap: 4px;
    }

    .lab-metric span {
      font-size: 0.76rem;
      color: #5e5248;
      font-weight: 600;
    }

    .lab-metric strong {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.9rem;
      color: #3b2c22;
      line-height: 1.2;
    }

    .macro-link-shell {
      margin-top: 12px;
      display: grid;
      gap: 12px;
      grid-template-columns: minmax(280px, 0.9fr) minmax(420px, 1.1fr);
      align-items: start;
    }

    .macro-panel {
      border: 1px solid #dcc8ae;
      border-radius: 14px;
      background: linear-gradient(180deg, #fffefb 0%, #fff6e9 100%);
      padding: 12px;
      box-shadow: 0 10px 24px rgba(44, 26, 15, 0.08);
      display: grid;
      gap: 10px;
    }

    .macro-visual-stage {
      position: relative;
      display: grid;
      gap: 10px;
      isolation: isolate;
    }

    .macro-particle-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
      opacity: 0.94;
    }

    .macro-presets {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .macro-preset {
      font-size: 0.75rem;
      letter-spacing: 0.02em;
      padding: 6px 10px;
    }

    .macro-control-grid {
      display: grid;
      gap: 8px;
    }

    .macro-row {
      display: grid;
      gap: 6px;
    }

    .macro-row label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 0.83rem;
      color: #4f4338;
      font-weight: 700;
    }

    .macro-row label strong {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.8rem;
      color: var(--usc-cardinal-deep);
      border: 1px solid #dcc8b1;
      border-radius: 999px;
      background: #fff;
      padding: 2px 8px;
    }

    .macro-slider {
      width: 100%;
      accent-color: var(--usc-cardinal);
      cursor: pointer;
    }

    .macro-inline-controls {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .macro-inline-controls .field {
      display: grid;
      gap: 6px;
    }

    .macro-inline-controls label {
      font-size: 0.74rem;
      color: #5a4d42;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-weight: 700;
    }

    .macro-inline-controls select {
      border: 1px solid #dbc7af;
      border-radius: 10px;
      background: #fff;
      color: #342a22;
      font-size: 0.82rem;
      padding: 7px 9px;
      min-height: 36px;
      font-weight: 600;
    }

    .macro-formulas {
      gap: 6px;
      padding: 8px;
      border-style: dashed;
    }

    .macro-formulas .formula {
      font-size: 0.86rem;
      padding: 7px 9px;
    }

    .macro-narrative {
      border: 1px solid #dfccb5;
      border-radius: 10px;
      background: #fff;
      padding: 9px 10px;
      color: #4e4237;
      font-size: 0.84rem;
      line-height: 1.46;
      min-height: 92px;
    }

    .macro-metrics {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }

    .macro-metric {
      border: 1px solid #e0cdb7;
      border-radius: 10px;
      background: #fff;
      padding: 8px 9px;
      display: grid;
      gap: 4px;
    }

    .macro-metric span {
      font-size: 0.72rem;
      color: #5f5348;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .macro-metric strong {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.86rem;
      color: #3a2d23;
      line-height: 1.2;
    }

    .macro-chart-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .macro-chart-card {
      border: 1px solid #dfccb5;
      border-radius: 12px;
      background: linear-gradient(180deg, #fff 0%, #fff8ec 100%);
      padding: 8px;
      display: grid;
      gap: 8px;
      transition: transform 0.24s ease, box-shadow 0.24s ease, border-color 0.24s ease;
    }

    .macro-chart-card.hidden {
      display: none;
    }

    .macro-chart-card.shift-active {
      border-color: #d4a258;
      box-shadow: 0 14px 30px rgba(122, 76, 25, 0.2);
      transform: translateY(-2px);
    }

    .macro-chart-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .macro-chart-head h3 {
      margin: 0;
      font-size: 0.86rem;
      color: #422b1d;
      letter-spacing: 0.01em;
    }

    .macro-chart-head span {
      border: 1px solid #ddc8af;
      border-radius: 999px;
      background: #fff;
      padding: 3px 8px;
      font-size: 0.72rem;
      color: #5c4f44;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .macro-svg {
      width: 100%;
      height: auto;
      border: 1px solid #e2d0b9;
      border-radius: 10px;
      background: #fffdf9;
    }

    .arena-grid {
      margin-top: 12px;
      display: grid;
      gap: 12px;
      grid-template-columns: minmax(300px, 1fr) minmax(360px, 1.05fr);
      align-items: start;
    }

    .arena-panel {
      border: 1px solid #dcc8ae;
      border-radius: 14px;
      background: linear-gradient(180deg, #fffefb 0%, #fff5e6 100%);
      padding: 12px;
      box-shadow: 0 10px 24px rgba(44, 26, 15, 0.08);
      display: grid;
      gap: 10px;
    }

    .arena-controls {
      display: grid;
      gap: 8px;
    }

    .arena-control-row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .arena-control-row label {
      font-size: 0.8rem;
      font-weight: 700;
      color: #4f4438;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }

    .arena-select,
    .arena-answer-input {
      border: 1px solid #dbc6ac;
      border-radius: 10px;
      background: #fff;
      color: #352b22;
      font-size: 0.88rem;
      padding: 7px 10px;
    }

    .arena-select {
      min-width: 180px;
      font-weight: 600;
    }

    .arena-answer-input {
      flex: 1 1 220px;
      font-family: "JetBrains Mono", monospace;
      min-width: 170px;
    }

    .arena-select:focus-visible,
    .arena-answer-input:focus-visible {
      outline: 2px solid rgba(153, 0, 0, 0.35);
      outline-offset: 1px;
      border-color: rgba(153, 0, 0, 0.4);
    }

    .arena-timer {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #ddc8b0;
      border-radius: 999px;
      background: #fff;
      padding: 4px 9px;
      font-size: 0.78rem;
      color: #54483d;
      font-weight: 700;
      font-family: "JetBrains Mono", monospace;
    }

    .arena-timer.warn {
      color: #8f3f00;
      border-color: rgba(143, 63, 0, 0.34);
    }

    .arena-timer.danger {
      color: #9b1212;
      border-color: rgba(155, 18, 18, 0.34);
    }

    .arena-prompt {
      border: 1px solid #dcc8ae;
      border-radius: 12px;
      background: linear-gradient(170deg, #fff 0%, #fff8ed 100%);
      padding: 10px;
      min-height: 140px;
      display: grid;
      gap: 8px;
      align-content: start;
    }

    .arena-prompt h3 {
      margin: 0;
      color: #482e1e;
      font-size: 0.96rem;
    }

    .arena-prompt p {
      margin: 0;
      color: #4e4136;
      font-size: 0.9rem;
      line-height: 1.45;
    }

    .arena-feedback {
      border: 1px solid #ddc8b0;
      border-radius: 10px;
      background: #fff;
      padding: 8px 10px;
      font-size: 0.84rem;
      color: #584b3f;
      min-height: 40px;
      display: grid;
      align-items: center;
    }

    .arena-feedback.success {
      border-color: rgba(20, 124, 74, 0.35);
      background: linear-gradient(180deg, #f3fff8 0%, #effcf4 100%);
      color: #165b3d;
      font-weight: 700;
    }

    .arena-feedback.error {
      border-color: rgba(155, 18, 18, 0.33);
      background: linear-gradient(180deg, #fff8f7 0%, #fff2f1 100%);
      color: #7f1d1d;
      font-weight: 700;
    }

    .arena-solution {
      display: none;
      border: 1px dashed #d8c3a8;
      border-radius: 10px;
      background: #fff;
      padding: 10px;
      color: #4f4338;
      font-size: 0.88rem;
      line-height: 1.45;
    }

    .arena-solution.show {
      display: block;
    }

    .arena-stats {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .arena-stat {
      border: 1px solid #dfcab0;
      border-radius: 10px;
      background: #fff;
      padding: 8px 10px;
      display: grid;
      gap: 4px;
    }

    .arena-stat span {
      font-size: 0.76rem;
      color: #5f5246;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .arena-stat strong {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.92rem;
      color: #3d3026;
      line-height: 1.2;
    }

    .intuition-grid {
      margin-top: 12px;
      display: grid;
      gap: 12px;
      grid-template-columns: minmax(250px, 0.86fr) minmax(420px, 1.2fr);
      align-items: start;
    }

    .intuition-panel {
      border: 1px solid #dcc8ae;
      border-radius: 14px;
      background: linear-gradient(180deg, #fffefb 0%, #fff5e6 100%);
      padding: 12px;
      box-shadow: 0 10px 24px rgba(44, 26, 15, 0.08);
      display: grid;
      gap: 10px;
    }

    .intuition-panel h3 {
      margin: 0;
      color: #452d1f;
      font-size: 0.96rem;
      letter-spacing: 0.01em;
    }

    .intuition-scenarios {
      display: grid;
      gap: 8px;
    }

    .intuition-library-tools {
      display: grid;
      gap: 8px;
    }

    .intuition-filter-row {
      display: grid;
      gap: 6px;
    }

    .intuition-filter-row label {
      font-size: 0.74rem;
      color: #5d5045;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-weight: 700;
    }

    .intuition-scenario {
      width: 100%;
      text-align: left;
      border: 1px solid #dfccb3;
      border-radius: 10px;
      background: #fff;
      padding: 8px 10px;
      cursor: pointer;
      display: grid;
      gap: 3px;
      transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
    }

    .intuition-scenario:hover {
      transform: translateY(-1px);
      border-color: rgba(153, 0, 0, 0.33);
      box-shadow: 0 8px 18px rgba(42, 25, 15, 0.1);
    }

    .intuition-scenario.active {
      border-color: rgba(153, 0, 0, 0.45);
      box-shadow: 0 10px 20px rgba(153, 0, 0, 0.14);
      background: linear-gradient(180deg, #fffaf3 0%, #fff5e7 100%);
    }

    .intuition-scenario .title {
      font-size: 0.86rem;
      font-weight: 700;
      color: #3b2d22;
      line-height: 1.25;
    }

    .intuition-scenario .meta {
      font-size: 0.72rem;
      color: #675b4f;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-weight: 700;
    }

    .intuition-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .intuition-shock {
      margin: 0;
      font-size: 0.9rem;
      color: #4f4338;
      line-height: 1.45;
      border: 1px solid #dfccb5;
      border-radius: 10px;
      background: #fff;
      padding: 10px;
    }

    .intuition-tools {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }

    .intuition-confidence {
      display: inline-flex;
      align-items: center;
      gap: 7px;
      border: 1px solid #dfccb5;
      border-radius: 999px;
      background: #fff;
      padding: 4px 8px;
      font-size: 0.74rem;
      color: #5c4f44;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-weight: 700;
    }

    .intuition-confidence select {
      border: 1px solid #dbc6ac;
      border-radius: 999px;
      background: #fffdf9;
      color: #382e24;
      font-size: 0.78rem;
      font-weight: 700;
      padding: 3px 8px;
      min-width: 132px;
    }

    .intuition-coach-meta {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.74rem;
      color: #4f4439;
      border: 1px solid #ddc9b2;
      border-radius: 999px;
      background: #fff;
      padding: 4px 10px;
      white-space: nowrap;
    }

    .intuition-vars {
      display: grid;
      gap: 8px;
    }

    .intuition-var {
      border: 1px solid #e2d0ba;
      border-radius: 10px;
      background: #fff;
      padding: 9px 10px;
      display: grid;
      gap: 8px;
      grid-template-columns: minmax(160px, 1fr) minmax(150px, 0.9fr) auto;
      align-items: center;
    }

    .intuition-var.correct {
      border-color: rgba(22, 122, 72, 0.35);
      background: linear-gradient(180deg, #f4fff8 0%, #effcf3 100%);
    }

    .intuition-var.wrong {
      border-color: rgba(155, 18, 18, 0.32);
      background: linear-gradient(180deg, #fff8f7 0%, #fff2f1 100%);
    }

    .intuition-label {
      font-size: 0.84rem;
      color: #493d33;
      font-weight: 700;
      line-height: 1.3;
    }

    .intuition-select {
      border: 1px solid #dbc6ac;
      border-radius: 10px;
      background: #fff;
      color: #352b22;
      font-size: 0.84rem;
      padding: 7px 9px;
      font-weight: 600;
      min-width: 140px;
    }

    .intuition-result {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.74rem;
      color: #5d5146;
      border: 1px solid #ddccb8;
      border-radius: 999px;
      background: #fff;
      padding: 3px 8px;
      white-space: nowrap;
      justify-self: end;
    }

    .intuition-var.correct .intuition-result {
      border-color: rgba(22, 122, 72, 0.35);
      color: #1e5e42;
      background: #f7fffa;
    }

    .intuition-var.wrong .intuition-result {
      border-color: rgba(155, 18, 18, 0.32);
      color: #781818;
      background: #fff7f7;
    }

    .intuition-chain {
      border: 1px dashed #d8c3a8;
      border-radius: 10px;
      background: #fff;
      padding: 10px;
      display: grid;
      gap: 8px;
      color: #4f4338;
      font-size: 0.84rem;
      line-height: 1.45;
    }

    .intuition-chain.hidden {
      display: none;
    }

    .intuition-chain ol {
      margin: 0;
      padding-left: 17px;
      display: grid;
      gap: 4px;
    }

    .intuition-chain ul {
      margin: 0;
      padding-left: 17px;
      display: grid;
      gap: 4px;
    }

    .intuition-chain strong {
      color: #3f2b1f;
    }

    .intuition-debrief {
      border: 1px dashed #d7c3a8;
      border-radius: 10px;
      background: #fff;
      padding: 10px;
      display: grid;
      gap: 8px;
    }

    .intuition-debrief.hidden {
      display: none;
    }

    .intuition-debrief h4 {
      margin: 0;
      color: #3f2b1f;
      font-size: 0.88rem;
      letter-spacing: 0.01em;
    }

    .intuition-debrief-item {
      border: 1px solid #e1cfba;
      border-radius: 10px;
      background: #fffdf9;
      padding: 8px 10px;
      display: grid;
      gap: 5px;
    }

    .intuition-debrief-item.good {
      border-color: rgba(22, 122, 72, 0.34);
      background: linear-gradient(180deg, #f5fff9 0%, #effcf4 100%);
    }

    .intuition-debrief-item.bad {
      border-color: rgba(155, 18, 18, 0.32);
      background: linear-gradient(180deg, #fff9f8 0%, #fff2f1 100%);
    }

    .intuition-debrief-item .top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 0.8rem;
      color: #4a3d32;
      font-weight: 700;
    }

    .intuition-debrief-item .logic {
      margin: 0;
      color: #5b4d42;
      font-size: 0.8rem;
      line-height: 1.45;
    }

    .mission-grid {
      margin-top: 12px;
      display: grid;
      gap: 12px;
      grid-template-columns: minmax(300px, 0.92fr) minmax(420px, 1.08fr);
      align-items: start;
    }

    .mission-panel {
      border: 1px solid #dcc8ae;
      border-radius: 14px;
      background: linear-gradient(180deg, #fffefb 0%, #fff6e9 100%);
      padding: 12px;
      box-shadow: 0 10px 24px rgba(44, 26, 15, 0.08);
      display: grid;
      gap: 10px;
    }

    .mission-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .mission-head h3 {
      margin: 0;
      color: #482f20;
      font-size: 0.98rem;
      letter-spacing: 0.01em;
    }

    .mastery-ring {
      width: 138px;
      height: 138px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      background:
        radial-gradient(circle at center, #fff 52%, transparent 54%),
        conic-gradient(from 270deg, #b22323 0deg, #b22323 120deg, #ddc6ad 120deg);
      border: 1px solid #ddc8b0;
      box-shadow: inset 0 0 0 1px rgba(153, 0, 0, 0.1);
      margin: 4px auto;
    }

    .mastery-ring .value {
      font-family: "Fraunces", serif;
      font-weight: 700;
      font-size: 1.35rem;
      color: #3f2a1f;
      line-height: 1.1;
    }

    .mastery-ring .label {
      display: block;
      margin-top: 2px;
      font-family: "JetBrains Mono", monospace;
      font-size: 0.64rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: #6d5f50;
      text-align: center;
    }

    .mission-signals {
      display: grid;
      gap: 8px;
    }

    .mission-signal {
      border: 1px solid #e2d0bb;
      border-radius: 10px;
      background: #fff;
      padding: 7px 9px;
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 8px;
    }

    .mission-signal span {
      font-size: 0.8rem;
      color: #56493f;
      font-weight: 700;
      letter-spacing: 0.01em;
    }

    .mission-signal strong {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.82rem;
      color: #3a2c22;
    }

    .mission-heatmap {
      display: grid;
      gap: 8px;
    }

    .heat-row {
      border: 1px solid #dfccb5;
      border-radius: 10px;
      background: #fff;
      padding: 8px 9px;
      display: grid;
      gap: 7px;
    }

    .heat-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 0.79rem;
      color: #51453a;
      font-weight: 700;
    }

    .heat-top strong {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.78rem;
      color: #3f2f25;
      padding: 2px 8px;
      border: 1px solid #ddc9b1;
      border-radius: 999px;
      background: #fff9ee;
    }

    .heat-bar {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      border: 1px solid #e2d1bc;
      background: #efe1d0;
      overflow: hidden;
    }

    .heat-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #ad1f1f, #d9792e, #2e8d5b);
      transition: width 0.24s ease;
    }

    .heat-note {
      font-size: 0.76rem;
      color: #65584d;
      line-height: 1.35;
    }

    .quest-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .quest-select {
      border: 1px solid #dbc6ac;
      border-radius: 10px;
      background: #fff;
      color: #352b22;
      font-size: 0.84rem;
      padding: 7px 9px;
      font-weight: 600;
      min-width: 150px;
    }

    .quest-select:focus-visible {
      outline: 2px solid rgba(153, 0, 0, 0.35);
      outline-offset: 1px;
      border-color: rgba(153, 0, 0, 0.4);
    }

    .quest-list {
      display: grid;
      gap: 8px;
    }

    .quest-item {
      border: 1px solid #dfccb5;
      border-radius: 10px;
      background: #fff;
      padding: 9px 10px;
      display: grid;
      gap: 8px;
    }

    .quest-item.done {
      border-color: rgba(22, 122, 72, 0.35);
      background: linear-gradient(180deg, #f4fff8 0%, #effcf3 100%);
    }

    .quest-item-head {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 8px;
      align-items: center;
    }

    .quest-item input[type="checkbox"] {
      width: 17px;
      height: 17px;
      accent-color: var(--usc-cardinal);
      cursor: pointer;
    }

    .quest-title {
      font-size: 0.84rem;
      font-weight: 700;
      color: #3c2d22;
      line-height: 1.3;
    }

    .quest-mins {
      font-family: "JetBrains Mono", monospace;
      font-size: 0.74rem;
      color: #574b40;
      border: 1px solid #deccb7;
      border-radius: 999px;
      background: #fff9ee;
      padding: 2px 7px;
      white-space: nowrap;
    }

    .quest-note {
      margin: 0;
      font-size: 0.78rem;
      color: #66594f;
      line-height: 1.35;
    }

    .quest-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .quest-progress-row {
      display: grid;
      gap: 8px;
    }

    .quest-progress-row .progress-bar {
      height: 11px;
    }

    .admin-console {
      display: grid;
      gap: 10px;
      margin-top: 8px;
    }

    .admin-console .flash-meta {
      width: fit-content;
    }

    footer {
      margin-top: 24px;
      color: #665a50;
      font-size: 0.83rem;
      text-align: center;
      padding: 12px;
    }

    @media (max-width: 980px) {
      .grid.cols-3,
      .kpi-strip {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .grid.cols-2,
      .resource-grid {
        grid-template-columns: 1fr;
      }
      .lab-grid {
        grid-template-columns: 1fr;
      }
      .macro-link-shell {
        grid-template-columns: 1fr;
      }
      .macro-chart-grid {
        grid-template-columns: 1fr;
      }
      .macro-metrics {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
      .formula-workbench {
        grid-template-columns: 1fr;
      }
      .arena-grid {
        grid-template-columns: 1fr;
      }
      .intuition-grid {
        grid-template-columns: 1fr;
      }
      .mission-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 620px) {
      .topbar {
        border-radius: 14px;
        position: static;
      }
      .kpi-strip,
      .grid.cols-3 {
        grid-template-columns: 1fr;
      }
      .hero {
        padding: 18px;
      }
      .hero-layer.layer-a {
        width: 170px;
        height: 170px;
      }
      .hero-layer.layer-b {
        width: 220px;
        height: 220px;
      }
      .hero-layer.layer-c {
        width: 180px;
        height: 180px;
      }
      .hero-grid {
        top: 62%;
      }
      .section {
        padding: 14px;
      }
      .lab-metrics {
        grid-template-columns: 1fr;
      }
      .arena-stats {
        grid-template-columns: 1fr;
      }
      .macro-inline-controls,
      .macro-metrics {
        grid-template-columns: 1fr;
      }
      .intuition-tools {
        flex-direction: column;
        align-items: stretch;
      }
      .intuition-confidence {
        width: 100%;
        justify-content: space-between;
      }
      .intuition-coach-meta {
        white-space: normal;
      }
      .formula-data-grid,
      .formula-meta-grid {
        grid-template-columns: 1fr;
      }
      .formula-binding-row {
        grid-template-columns: 1fr;
      }
      .formula-binding-row.header {
        display: none;
      }
      .intuition-var {
        grid-template-columns: 1fr;
      }
      .intuition-result {
        justify-self: start;
      }
      .quest-item-head {
        grid-template-columns: 1fr;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .card,
      .reveal {
        animation: none !important;
        transition: none !important;
      }
      .hero-layer {
        transform: none !important;
      }
      .hero::after {
        transform: none !important;
      }
      .macro-chart-card {
        transition: none !important;
      }
      .macro-particle-canvas {
        display: none !important;
      }
    }

    @media print {
      .auth-gate,
      .topbar,
      .command-shell,
      .flash-actions,
      .btn,
      #marketLab,
      #macroLinkStudio,
      #formulaEngine .formula-catalog,
      #formulaEngine .formula-data-lab .btn,
      #missionControl .quest-actions,
      #intuitionStudio,
      #quantArena,
      footer {
        display: none !important;
      }
      body {
        background: white;
      }
      .section, .hero, .card {
        box-shadow: none;
      }
      a {
        color: #000;
        text-decoration: none;
      }
    }
  </style>
</head>
<body class="auth-locked" data-role="locked">
  <div class="auth-gate" id="authGate">
    <div class="auth-card">
      <h2>ECON 205 Access</h2>
      <p>Enter your name to unlock this instructional studio.</p>
      <div class="auth-row">
        <label class="sr-only" for="authNameInput">Authorized name</label>
        <input id="authNameInput" class="auth-input" type="text" autocomplete="name" placeholder="Name" aria-label="Authorized name" spellcheck="false" />
        <button class="btn btn-primary" id="authUnlockBtn" type="button" aria-label="Unlock access">Unlock</button>
      </div>
      <div class="auth-help">Use your authorized course name. Sessions auto-lock after inactivity.</div>
      <div class="auth-message" id="authMessage">Access is name-gated for current enrolled use.</div>
    </div>
  </div>

  <div class="shell">
    <div class="topbar">
      <div class="brand">
        <div class="crest">USC</div>
        <div class="brand-copy">
          <div class="brand-title">ECON 205 Midterm I Study Studio</div>
          <div class="brand-credit">Dr. Ian Helfrich</div>
        </div>
      </div>
      <div class="top-actions">
        <span class="auth-chip" id="authBadge">Locked</span>
        <span class="auth-chip" id="sessionGuardChip">Session Guard: Locked</span>
        <button class="btn btn-ghost" id="commandBtn" type="button">Command</button>
        <button class="btn btn-ghost admin-inline" id="adminDiagnosticsBtn" type="button">Run Diag</button>
        <a class="btn btn-ghost" href="#missionControl">Mission</a>
        <a class="btn btn-ghost" href="#marketLab">Graph Lab</a>
        <a class="btn btn-ghost" href="#macroLinkStudio">Macro Studio</a>
        <a class="btn btn-ghost" href="#intuitionStudio">Intuition</a>
        <a class="btn btn-ghost" href="#quantArena">Quant Arena</a>
        <a class="btn btn-ghost" href="ECON205_Midterm1_Complete_Study_Pack.pdf">Open Full Pack</a>
        <button class="btn btn-ghost" id="resetAllBtn" type="button">Reset Progress</button>
        <button class="btn btn-ghost" id="switchUserBtn" type="button">Switch User</button>
        <button class="btn btn-primary" id="printBtn" type="button">Print Layout</button>
      </div>
    </div>
    <div class="live-status" id="liveStatus" aria-live="polite"></div>

    <div class="command-shell" id="commandShell" aria-hidden="true">
      <div class="command-backdrop" id="commandBackdrop"></div>
      <div class="command-dialog" role="dialog" aria-label="Command palette">
        <div class="command-head">
          <input id="commandInput" class="command-input" type="search" placeholder="Search actions... (e.g., mission, graph, intuition, timer, arena, recall)" />
          <span class="command-hint">ESC</span>
        </div>
        <div class="command-list" id="commandList"></div>
      </div>
    </div>

    <section class="hero" id="hero">
      <div class="hero-art" aria-hidden="true">
        <div class="hero-layer layer-a" data-parallax="0.08"></div>
        <div class="hero-layer layer-b" data-parallax="0.13"></div>
        <div class="hero-layer layer-c" data-parallax="0.05"></div>
        <div class="hero-grid" data-parallax="0.04"></div>
      </div>
      <p class="hero-kicker">USC ECON 205  Midterm I</p>
      <h1>Macroeconomics Learning Studio</h1>
      <p class="sub">
        Built from your lecture flow and syllabus scope. Use this as a high-performance prep environment for
        formulas, graph logic, adaptive recall, and full-timed exam execution.
      </p>
      <div class="chip-row">
        <span class="chip">Mode: Concept + Computation + Graphing</span>
        <span class="chip">Timed Runtime: 75 minutes</span>
        <span class="chip">Coverage: Lecture 01-07</span>
        <span class="chip">Workflow: Learn -> Reason -> Drill -> Simulate -> Debrief</span>
        <span class="chip" id="diagnosticsChip">Diagnostics: pending</span>
      </div>
      <div class="kpi-strip">
        <div class="kpi"><div class="n">8</div><div class="l">Topic Blocks</div></div>
        <div class="kpi"><div class="n">17</div><div class="l">Core Equations</div></div>
        <div class="kpi"><div class="n" id="heroRecallCount">10</div><div class="l">Recall Prompts</div></div>
        <div class="kpi"><div class="n">3</div><div class="l">Timed Mock Forms</div></div>
      </div>
    </section>

    <section class="section" id="missionControl">
      <h2>Mission Control</h2>
      <p class="lead">A live control center for mastery quality. Signals combine retrieval, quantitative execution, causal intuition, and checklist completion into one adaptive plan.</p>
      <div class="mission-grid">
        <div class="mission-panel">
          <div class="mission-head">
            <h3>Mastery Signal</h3>
            <button type="button" class="btn btn-ghost" id="refreshMissionBtn">Refresh Analysis</button>
          </div>
          <div class="mastery-ring" id="masteryRing">
            <div>
              <div class="value" id="masteryScore">50%</div>
              <span class="label">Composite</span>
            </div>
          </div>
          <div class="mission-signals">
            <div class="mission-signal"><span>Recall retention</span><strong id="missionRecallScore">50%</strong></div>
            <div class="mission-signal"><span>Quant execution</span><strong id="missionArenaScore">50%</strong></div>
            <div class="mission-signal"><span>Causal intuition</span><strong id="missionIntuitionScore">50%</strong></div>
            <div class="mission-signal"><span>Protocol completion</span><strong id="missionChecklistScore">0%</strong></div>
          </div>
          <div class="arena-feedback" id="missionAlert">Run one recall + one quant + one intuition round to generate a high-confidence mastery signal.</div>
        </div>

        <div class="mission-panel">
          <div class="mission-head">
            <h3>Weakness Heatmap</h3>
            <span class="flash-meta" id="missionWeaknessMeta">Weakest focus: pending</span>
          </div>
          <div class="mission-heatmap" id="missionHeatmap"></div>
        </div>
      </div>

      <div class="mission-panel" style="margin-top: 12px;">
        <div class="mission-head">
          <h3>Adaptive Quest Planner</h3>
          <span class="flash-meta" id="questMeta">No quest generated yet.</span>
        </div>
        <div class="quest-controls">
          <label class="timer-label" for="questIntensity">Intensity
            <select id="questIntensity" class="quest-select">
              <option value="light">Light (20-25 min)</option>
              <option value="standard" selected>Standard (30-40 min)</option>
              <option value="challenge">Challenge (45-60 min)</option>
            </select>
          </label>
          <button type="button" class="btn btn-primary" id="generateQuestBtn">Generate Quest</button>
          <button type="button" class="btn btn-ghost" id="runNextQuestBtn">Run Next Task</button>
          <button type="button" class="btn btn-ghost" id="clearQuestBtn">Clear Quest</button>
        </div>
        <div class="quest-progress-row">
          <div class="progress-meta">
            <strong id="questProgressPct">0% complete</strong>
            <span id="questProgressText">No active tasks.</span>
          </div>
          <div class="progress-bar"><div class="progress-fill" id="questProgressFill"></div></div>
        </div>
        <div class="quest-list" id="questList"></div>
      </div>
    </section>

    <section class="section admin-only" id="adminConsole">
      <h2>Admin Console</h2>
      <p class="lead">Admin mode for Dr. Ian Helfrich. Student view remains unchanged.</p>
      <div class="admin-console">
        <div class="flash-actions">
          <button class="btn btn-ghost" id="adminRunDiagnosticsBtn" type="button">Run Diagnostics</button>
          <button class="btn btn-ghost" id="adminExportStateBtn" type="button">Export Local State</button>
          <button class="btn btn-ghost" id="adminHardResetBtn" type="button">Hard Reset</button>
        </div>
        <div class="flash-actions">
          <label class="timer-label" for="adminIdleMinutes">Idle Lock
            <input id="adminIdleMinutes" class="timer-minutes" type="number" min="5" max="180" step="1" value="30" />
          </label>
          <button class="btn btn-ghost" id="adminSaveIdleBtn" type="button">Save Idle Policy</button>
          <button class="btn btn-ghost" id="adminLockNowBtn" type="button">Lock Now</button>
        </div>
        <div class="flash-meta" id="adminSecurityMeta">Idle lock: 30 minutes.</div>
        <div class="flash-meta" id="adminModeMeta">Admin mode active.</div>
      </div>
    </section>

    <section class="section" id="topicArchitecture">
      <h2>Topic Architecture</h2>
      <p class="lead">What you must master by lecture, in the same logic sequence used in class.</p>
      <div class="grid cols-3">
        <article class="card">
          <h3>L01 Supply and Demand</h3>
          <ul>
            <li>Law of demand and law of supply</li>
            <li>Movement along curve vs curve shift</li>
            <li>Equilibrium, shortage, surplus, self-correction</li>
          </ul>
        </article>
        <article class="card">
          <h3>L02 Policy and Elasticity</h3>
          <ul>
            <li>Binding price ceilings and floors</li>
            <li>Midpoint elasticity mechanics</li>
            <li>Revenue effects under elastic vs inelastic demand</li>
          </ul>
        </article>
        <article class="card">
          <h3>L03 Macro Concepts</h3>
          <ul>
            <li>Real GDP, cycles, unemployment, inflation</li>
            <li>Nominal vs real interest rates</li>
            <li>Short-run fluctuations vs long-run growth</li>
          </ul>
        </article>
        <article class="card">
          <h3>L04 National Accounts</h3>
          <ul>
            <li>Spending, income, value-added approaches</li>
            <li>Final vs intermediate goods</li>
            <li>Nominal vs real GDP and deflator</li>
          </ul>
        </article>
        <article class="card">
          <h3>L05 Spending Shares and Saving</h3>
          <ul>
            <li>Shares C/Y, I/Y, G/Y, NX/Y</li>
            <li>Private/public/national saving</li>
            <li>Interest-rate channels to C, I, and NX</li>
          </ul>
        </article>
        <article class="card">
          <h3>L06 Labor Market</h3>
          <ul>
            <li>LF, unemployment rate, LFPR, EPOP</li>
            <li>Frictional, structural, cyclical, seasonal</li>
            <li>Natural unemployment interpretation</li>
          </ul>
        </article>
      </div>
    </section>

    <section class="section" id="formulaEngine">
      <h2>Formula Explorer</h2>
      <p class="lead">Click any formula, then click any variable. Each variable includes economic intuition, data mapping, and API-ready hooks for real FRED/BLS series.</p>
      <div class="formula-workbench">
        <aside class="formula-catalog" id="formulaCatalog" aria-label="Formula catalog"></aside>

        <div class="formula-main">
          <div class="formula-panel">
            <div class="formula-head">
              <h3 id="formulaActiveTitle">Select a formula</h3>
              <span class="formula-topic" id="formulaActiveTopic">Catalog</span>
            </div>
            <div class="formula formula-latex" id="formulaActiveLatex">\(Y=C+I+G+NX\)</div>
            <p class="formula-intuition" id="formulaIntuition">Choose a formula from the left panel to open its intuition, exam logic, and variable-level guidance.</p>
            <ul class="formula-focus-list" id="formulaExamFocus"></ul>
            <div class="formula-variable-cloud" id="formulaVariableButtons"></div>
          </div>

          <div class="formula-panel">
            <div class="formula-head">
              <h3 id="formulaVariableTitle">Variable Explorer</h3>
              <span class="formula-topic">Deep Dive</span>
            </div>
            <div class="formula-var-symbol" id="formulaVariableSymbol">\(Y\)</div>
            <p class="formula-intuition" id="formulaVariableDefinition">Click a variable chip to inspect what the variable means, why it matters, and what real data can represent it.</p>
            <div class="formula-meta-grid">
              <div class="formula-meta">
                <span>Economic Role</span>
                <strong id="formulaVariableRole">-</strong>
              </div>
              <div class="formula-meta">
                <span>Typical Units</span>
                <strong id="formulaVariableUnits">-</strong>
              </div>
              <div class="formula-meta">
                <span>Data Mapping</span>
                <strong id="formulaVariableDataMap">-</strong>
              </div>
              <div class="formula-meta">
                <span>Exam Intuition</span>
                <strong id="formulaVariableExamHint">-</strong>
              </div>
            </div>
          </div>

          <div class="formula-panel formula-data-lab">
            <div class="formula-head">
              <h3>Formula Data Playground</h3>
              <span class="formula-topic">Live + Local Storage</span>
            </div>
            <p class="formula-intuition">Bind each variable to a manual value, FRED series, or BLS series. Values persist in local storage so students can keep experimenting between sessions.</p>

            <div class="formula-data-grid">
              <div class="formula-field">
                <label for="formulaVariableSelect">Variable</label>
                <select id="formulaVariableSelect"></select>
              </div>
              <div class="formula-field">
                <label for="formulaSourceSelect">Input source</label>
                <select id="formulaSourceSelect">
                  <option value="manual">Manual value</option>
                  <option value="fred">FRED API series</option>
                  <option value="bls">BLS API series</option>
                </select>
              </div>
              <div class="formula-field" id="formulaSeriesField">
                <label for="formulaSeriesInput">Series ID</label>
                <input id="formulaSeriesInput" type="text" placeholder="e.g., GDPC1 or LNS14000000" spellcheck="false" />
              </div>
              <div class="formula-field" id="formulaManualField">
                <label for="formulaManualInput">Manual value</label>
                <input id="formulaManualInput" type="number" step="any" placeholder="Enter numeric value" />
              </div>
            </div>

            <div class="formula-actions">
              <button type="button" class="btn btn-ghost" id="formulaSaveBindingBtn">Save Variable Binding</button>
              <button type="button" class="btn btn-primary" id="formulaFetchBtn">Fetch Latest Series Value</button>
              <button type="button" class="btn btn-ghost" id="formulaApplyManualBtn">Apply Manual Value</button>
            </div>

            <div class="formula-data-grid">
              <div class="formula-field">
                <label for="fredApiKeyInput">FRED API key (stored locally)</label>
                <input id="fredApiKeyInput" type="password" placeholder="Enter FRED API key" autocomplete="off" spellcheck="false" />
              </div>
              <div class="formula-field">
                <label for="blsApiKeyInput">BLS API key (stored locally)</label>
                <input id="blsApiKeyInput" type="password" placeholder="Enter BLS API key" autocomplete="off" spellcheck="false" />
              </div>
            </div>

            <div class="formula-actions">
              <button type="button" class="btn btn-ghost" id="formulaSaveKeysBtn">Save API Keys</button>
              <span class="flash-meta" id="formulaDataMeta">No variable updates yet.</span>
            </div>

            <div class="formula-binding-table" id="formulaBindingsTable"></div>

            <div class="formula-actions">
              <button type="button" class="btn btn-primary" id="formulaComputeBtn">Compute Active Formula Output</button>
              <button type="button" class="btn btn-ghost" id="formulaResetBtn">Reset Formula Playground</button>
            </div>

            <div class="arena-feedback" id="formulaComputeResult">Ready to compute.</div>
            <div class="formula-compute-solution" id="formulaComputeSteps"></div>
          </div>
        </div>
      </div>
    </section>

    <section class="section" id="graphPlaybook">
      <h2>Graphing Playbook</h2>
      <p class="lead">Use this exact routine on every graph question to maximize partial and full credit.</p>
      <div class="grid cols-2">
        <div class="grid">
          <div class="playbook-step"><div class="step-num">1</div><div>Label axes first: <strong>P</strong> vertical, <strong>Q</strong> horizontal.</div></div>
          <div class="playbook-step"><div class="step-num">2</div><div>Draw <strong>D0</strong>, <strong>S0</strong>, and mark initial equilibrium <strong>(P0, Q0)</strong>.</div></div>
          <div class="playbook-step"><div class="step-num">3</div><div>Shift only the relevant curve(s). Left = decrease. Right = increase.</div></div>
          <div class="playbook-step"><div class="step-num">4</div><div>Mark new equilibrium <strong>(P1, Q1)</strong>. Never leave the new point unlabeled.</div></div>
          <div class="playbook-step"><div class="step-num">5</div><div>Add one sentence: <em>shock -> shift -> outcome</em>.</div></div>
        </div>
        <div class="card" style="height: fit-content;">
          <h3>High-Frequency Graph Traps</h3>
          <ul>
            <li>Price changes do <strong>not</strong> shift demand/supply.</li>
            <li>Binding ceiling is below equilibrium and creates shortage.</li>
            <li>Binding floor is above equilibrium and creates surplus.</li>
            <li>Two shocks: often price is clear, quantity is ambiguous.</li>
            <li>Always include ceteris paribus statement when needed.</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="section" id="marketLab">
      <h2>Market Dynamics Lab</h2>
      <p class="lead">Manipulate shifts and policies, then read equilibrium, binding status, and market gaps exactly like an exam graph write-up.</p>
      <div class="lab-grid">
        <div class="lab-panel">
          <div class="lab-presets">
            <button type="button" class="btn btn-ghost lab-preset" data-preset="reset">Reset</button>
            <button type="button" class="btn btn-ghost lab-preset" data-preset="demand_surge">Demand Surge</button>
            <button type="button" class="btn btn-ghost lab-preset" data-preset="supply_shock">Supply Shock</button>
            <button type="button" class="btn btn-ghost lab-preset" data-preset="ceiling_bind">Binding Ceiling</button>
            <button type="button" class="btn btn-ghost lab-preset" data-preset="floor_bind">Binding Floor</button>
          </div>

          <div class="slider-block">
            <label class="slider-row" for="labDemandShift">
              <span>Demand shift \(\Delta_D\)</span>
              <strong id="labDemandShiftVal">0</strong>
            </label>
            <input id="labDemandShift" class="lab-slider" type="range" min="-40" max="40" step="1" value="0" />
          </div>

          <div class="slider-block">
            <label class="slider-row" for="labSupplyShift">
              <span>Supply shift \(\Delta_S\)</span>
              <strong id="labSupplyShiftVal">0</strong>
            </label>
            <input id="labSupplyShift" class="lab-slider" type="range" min="-40" max="40" step="1" value="0" />
          </div>

          <div class="policy-row">
            <label for="labPolicyType">Price policy</label>
            <select id="labPolicyType" class="lab-select">
              <option value="none">No control</option>
              <option value="ceiling">Price ceiling</option>
              <option value="floor">Price floor</option>
            </select>
          </div>

          <div class="slider-block">
            <label class="slider-row" for="labControlPrice">
              <span>Controlled price \(P_c\)</span>
              <strong id="labControlPriceVal">22.0</strong>
            </label>
            <input id="labControlPrice" class="lab-slider" type="range" min="2" max="46" step="0.5" value="22" />
          </div>

          <div class="formula-board lab-formulas">
            <div class="formula">\(Q_D = (\bar{A}_D + \Delta_D) - bP\)</div>
            <div class="formula">\(Q_S = (\bar{A}_S + \Delta_S) + dP\)</div>
            <div class="formula">\(P^* = \frac{(\bar{A}_D + \Delta_D)-(\bar{A}_S + \Delta_S)}{b+d}\), \(\quad Q^* = Q_D(P^*)\)</div>
          </div>

          <div class="lab-note">
            <h3>Coach Note</h3>
            <p id="labNarrative">Use the controls to run a scenario. The site will auto-diagnose whether a control binds and whether the market gap is a shortage or surplus.</p>
          </div>
        </div>

        <div class="lab-panel lab-chart-panel">
          <svg id="marketSvg" class="market-svg" viewBox="0 0 700 420" role="img" aria-label="Supply and demand simulation chart">
            <rect x="0" y="0" width="700" height="420" fill="#fffdf8"></rect>
            <g id="marketGrid"></g>
            <line id="marketAxisX" x1="66" y1="364" x2="674" y2="364" stroke="#3a2a1a" stroke-width="2"></line>
            <line id="marketAxisY" x1="66" y1="364" x2="66" y2="24" stroke="#3a2a1a" stroke-width="2"></line>
            <text x="662" y="388" font-size="13" fill="#433326">Quantity Q</text>
            <text x="14" y="20" font-size="13" fill="#433326">Price P</text>

            <line id="marketEqPriceLine" x1="66" y1="0" x2="66" y2="0" stroke="#9a7a44" stroke-dasharray="4 4" stroke-width="1.5"></line>
            <line id="marketEqQtyLine" x1="0" y1="364" x2="0" y2="364" stroke="#9a7a44" stroke-dasharray="4 4" stroke-width="1.5"></line>

            <path id="marketDemandPath" d="" fill="none" stroke="#b52121" stroke-width="3"></path>
            <path id="marketSupplyPath" d="" fill="none" stroke="#1f5a67" stroke-width="3"></path>
            <text id="marketDemandLabel" x="0" y="0" fill="#8f1818" font-size="13" font-weight="700">D</text>
            <text id="marketSupplyLabel" x="0" y="0" fill="#1f4f5b" font-size="13" font-weight="700">S</text>

            <line id="marketPolicyLine" x1="66" y1="0" x2="674" y2="0" stroke="#5b4b3c" stroke-width="2" stroke-dasharray="8 6" opacity="0"></line>
            <line id="marketQdLine" x1="0" y1="0" x2="0" y2="364" stroke="#b52121" stroke-width="2" stroke-dasharray="5 5" opacity="0"></line>
            <line id="marketQsLine" x1="0" y1="0" x2="0" y2="364" stroke="#1f5a67" stroke-width="2" stroke-dasharray="5 5" opacity="0"></line>
            <text id="marketPcLabel" x="78" y="0" fill="#5a4a3d" font-size="12" opacity="0">Pc</text>
            <text id="marketQdLabel" x="0" y="382" fill="#8f1818" font-size="12" opacity="0">Qd(Pc)</text>
            <text id="marketQsLabel" x="0" y="382" fill="#1f4f5b" font-size="12" opacity="0">Qs(Pc)</text>

            <circle id="marketEqPoint" cx="0" cy="0" r="6" fill="#c2892e" stroke="#fff8ec" stroke-width="2"></circle>
            <text id="marketEqLabel" x="0" y="0" fill="#6a3f00" font-size="12" font-weight="700">E*</text>
          </svg>

          <div class="lab-metrics">
            <div class="lab-metric">
              <span>Equilibrium price \(P^*\)</span>
              <strong id="labEqPrice">0.00</strong>
            </div>
            <div class="lab-metric">
              <span>Equilibrium quantity \(Q^*\)</span>
              <strong id="labEqQty">0.00</strong>
            </div>
            <div class="lab-metric">
              <span>Policy status</span>
              <strong id="labPolicyStatus">No control</strong>
            </div>
            <div class="lab-metric">
              <span>Gap at \(P_c\)</span>
              <strong id="labGap">0.00</strong>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="section" id="macroLinkStudio">
      <h2>Macro Transmission Studio</h2>
      <p class="lead">Run synchronized shocks across linked panels. Compare how a single scenario propagates through <strong>AD-AS, Money Market, Loanable Funds, and Inflation-Unemployment</strong> at the same time.</p>
      <div class="macro-link-shell">
        <div class="macro-panel">
          <div class="macro-presets">
            <button type="button" class="btn btn-ghost macro-preset" data-macro-preset="reset">Reset</button>
            <button type="button" class="btn btn-ghost macro-preset" data-macro-preset="monetary_easing">Monetary Easing</button>
            <button type="button" class="btn btn-ghost macro-preset" data-macro-preset="fiscal_expansion">Fiscal Expansion</button>
            <button type="button" class="btn btn-ghost macro-preset" data-macro-preset="productivity_boom">Productivity Boom</button>
            <button type="button" class="btn btn-ghost macro-preset" data-macro-preset="stagflation_shock">Stagflation Shock</button>
            <button type="button" class="btn btn-ghost macro-preset" data-macro-preset="uncertainty_shock">Uncertainty Shock</button>
          </div>

          <div class="macro-inline-controls">
            <div class="field">
              <label for="macroLayoutMode">Panel layout</label>
              <select id="macroLayoutMode">
                <option value="2x2">2x2 linked grid</option>
                <option value="1x2">1x2 focused pair</option>
              </select>
            </div>
            <div class="field">
              <label for="macroPairMode">Focused pair</label>
              <select id="macroPairMode">
                <option value="adas_money">AD-AS + Money</option>
                <option value="adas_loanable">AD-AS + Loanable Funds</option>
                <option value="money_loanable">Money + Loanable Funds</option>
                <option value="adas_phillips">AD-AS + Inflation-Unemployment</option>
                <option value="money_phillips">Money + Inflation-Unemployment</option>
                <option value="loanable_phillips">Loanable Funds + Inflation-Unemployment</option>
              </select>
            </div>
          </div>

          <div class="macro-control-grid">
            <div class="macro-row">
              <label for="macroDemandShift"><span>Aggregate demand shift \(\Delta AD\)</span><strong id="macroDemandShiftVal">0</strong></label>
              <input id="macroDemandShift" class="macro-slider" type="range" min="-40" max="40" step="1" value="0" />
            </div>
            <div class="macro-row">
              <label for="macroSupplyShift"><span>Short-run supply shift \(\Delta SRAS\)</span><strong id="macroSupplyShiftVal">0</strong></label>
              <input id="macroSupplyShift" class="macro-slider" type="range" min="-30" max="30" step="1" value="0" />
            </div>
            <div class="macro-row">
              <label for="macroMoneySupplyShift"><span>Money supply shift \(\Delta M_s\)</span><strong id="macroMoneySupplyShiftVal">0</strong></label>
              <input id="macroMoneySupplyShift" class="macro-slider" type="range" min="-40" max="40" step="1" value="0" />
            </div>
            <div class="macro-row">
              <label for="macroMoneyDemandShift"><span>Money demand shift \(\Delta L\)</span><strong id="macroMoneyDemandShiftVal">0</strong></label>
              <input id="macroMoneyDemandShift" class="macro-slider" type="range" min="-40" max="40" step="1" value="0" />
            </div>
            <div class="macro-row">
              <label for="macroSavingShift"><span>Saving supply shift \(\Delta S\)</span><strong id="macroSavingShiftVal">0</strong></label>
              <input id="macroSavingShift" class="macro-slider" type="range" min="-30" max="30" step="1" value="0" />
            </div>
            <div class="macro-row">
              <label for="macroInvestmentShift"><span>Investment demand shift \(\Delta I\)</span><strong id="macroInvestmentShiftVal">0</strong></label>
              <input id="macroInvestmentShift" class="macro-slider" type="range" min="-30" max="30" step="1" value="0" />
            </div>
            <div class="macro-row">
              <label for="macroExpectedInflation"><span>Expected inflation \(\pi^e\)</span><strong id="macroExpectedInflationVal">2.0%</strong></label>
              <input id="macroExpectedInflation" class="macro-slider" type="range" min="-1" max="10" step="0.1" value="2" />
            </div>
          </div>

          <div class="formula-board macro-formulas">
            <div class="formula">\(AD: \; P = \bar{A}_{AD} - bY, \quad SRAS: \; P = \bar{A}_{SRAS} + cY\)</div>
            <div class="formula">\(Money:\; \frac{M^s}{P} = L(Y,i)\)</div>
            <div class="formula">\(Loanable\;Funds:\; S(r) = I(r)\)</div>
            <div class="formula">\(\pi = \pi^e - \alpha(u-u_n) + \text{cost-push}\)</div>
          </div>

          <div class="macro-narrative" id="macroNarrative">Run a preset or move sliders to see one shock transmit across all connected macro markets.</div>
        </div>

        <div class="macro-panel">
          <div class="macro-visual-stage">
            <canvas id="macroParticleCanvas" class="macro-particle-canvas" aria-hidden="true"></canvas>

            <div class="macro-metrics">
              <div class="macro-metric"><span>Output \(Y\)</span><strong id="macroOutputLevel">0.0</strong></div>
              <div class="macro-metric"><span>Price Level \(P\)</span><strong id="macroPriceLevel">0.0</strong></div>
              <div class="macro-metric"><span>Nominal Rate \(i\)</span><strong id="macroNominalRate">0.0%</strong></div>
              <div class="macro-metric"><span>Real Rate \(r\)</span><strong id="macroRealRate">0.0%</strong></div>
              <div class="macro-metric"><span>Unemployment \(u\)</span><strong id="macroUnemploymentRate">0.0%</strong></div>
              <div class="macro-metric"><span>Inflation \(\pi\)</span><strong id="macroInflationRate">0.0%</strong></div>
              <div class="macro-metric"><span>Rate Wedge \((i-\pi^e)-r\)</span><strong id="macroRateGap">0.0</strong></div>
              <div class="macro-metric"><span>Regime Signal</span><strong id="macroRegimeTag">Baseline</strong></div>
            </div>

            <div class="macro-chart-grid" id="macroChartGrid" data-layout="2x2">
              <article class="macro-chart-card" data-chart="adas">
                <div class="macro-chart-head">
                  <h3>AD-AS</h3>
                  <span id="macroAdasTag">Output-Price</span>
                </div>
                <svg id="macroAdasSvg" class="macro-svg" viewBox="0 0 640 360" role="img" aria-label="AD-AS linked graph">
                  <rect x="0" y="0" width="640" height="360" fill="#fffdf8"></rect>
                  <g id="macroAdasGrid"></g>
                  <line x1="58" y1="314" x2="616" y2="314" stroke="#3a2a1a" stroke-width="2"></line>
                  <line x1="58" y1="314" x2="58" y2="24" stroke="#3a2a1a" stroke-width="2"></line>
                  <text x="602" y="338" font-size="12" fill="#433326">Output Y</text>
                  <text x="16" y="20" font-size="12" fill="#433326">Price P</text>
                  <path id="macroAdasBaseAd" d="" fill="none" stroke="#cb8d8d" stroke-width="2" stroke-dasharray="6 5"></path>
                  <path id="macroAdasBaseSras" d="" fill="none" stroke="#9ab6c5" stroke-width="2" stroke-dasharray="6 5"></path>
                  <path id="macroAdPath" d="" fill="none" stroke="#b52121" stroke-width="3"></path>
                  <path id="macroSrasPath" d="" fill="none" stroke="#1f5a67" stroke-width="3"></path>
                  <line id="macroAdasBaseLras" x1="0" y1="0" x2="0" y2="0" stroke="#9f7d4a" stroke-width="1.7" stroke-dasharray="5 4"></line>
                  <line id="macroAdasLras" x1="0" y1="0" x2="0" y2="0" stroke="#7f5f2b" stroke-width="2.1"></line>
                  <circle id="macroAdasEqPoint" cx="0" cy="0" r="6" fill="#c2892e" stroke="#fff8ec" stroke-width="2"></circle>
                  <text id="macroAdasEqLabel" x="0" y="0" font-size="12" fill="#6a3f00" font-weight="700">E1</text>
                </svg>
              </article>

              <article class="macro-chart-card" data-chart="money">
                <div class="macro-chart-head">
                  <h3>Money Market</h3>
                  <span id="macroMoneyTag">Liquidity</span>
                </div>
                <svg id="macroMoneySvg" class="macro-svg" viewBox="0 0 640 360" role="img" aria-label="Money market linked graph">
                  <rect x="0" y="0" width="640" height="360" fill="#fffdf8"></rect>
                  <g id="macroMoneyGrid"></g>
                  <line x1="58" y1="314" x2="616" y2="314" stroke="#3a2a1a" stroke-width="2"></line>
                  <line x1="58" y1="314" x2="58" y2="24" stroke="#3a2a1a" stroke-width="2"></line>
                  <text x="522" y="338" font-size="12" fill="#433326">Real Balances</text>
                  <text x="16" y="20" font-size="12" fill="#433326">Nominal i</text>
                  <line id="macroMoneyBaseSupply" x1="0" y1="0" x2="0" y2="0" stroke="#9f7d4a" stroke-width="2" stroke-dasharray="6 5"></line>
                  <path id="macroMoneyBaseDemand" d="" fill="none" stroke="#cb8d8d" stroke-width="2" stroke-dasharray="6 5"></path>
                  <line id="macroMoneySupply" x1="0" y1="0" x2="0" y2="0" stroke="#7f5f2b" stroke-width="2.4"></line>
                  <path id="macroMoneyDemand" d="" fill="none" stroke="#b52121" stroke-width="3"></path>
                  <circle id="macroMoneyEqPoint" cx="0" cy="0" r="6" fill="#c2892e" stroke="#fff8ec" stroke-width="2"></circle>
                  <text id="macroMoneyEqLabel" x="0" y="0" font-size="12" fill="#6a3f00" font-weight="700">i1</text>
                </svg>
              </article>

              <article class="macro-chart-card" data-chart="loanable">
                <div class="macro-chart-head">
                  <h3>Loanable Funds</h3>
                  <span id="macroLfTag">Saving-Investment</span>
                </div>
                <svg id="macroLfSvg" class="macro-svg" viewBox="0 0 640 360" role="img" aria-label="Loanable funds linked graph">
                  <rect x="0" y="0" width="640" height="360" fill="#fffdf8"></rect>
                  <g id="macroLfGrid"></g>
                  <line x1="58" y1="314" x2="616" y2="314" stroke="#3a2a1a" stroke-width="2"></line>
                  <line x1="58" y1="314" x2="58" y2="24" stroke="#3a2a1a" stroke-width="2"></line>
                  <text x="534" y="338" font-size="12" fill="#433326">Funds Q</text>
                  <text x="16" y="20" font-size="12" fill="#433326">Real r</text>
                  <path id="macroLfBaseSupply" d="" fill="none" stroke="#9ab6c5" stroke-width="2" stroke-dasharray="6 5"></path>
                  <path id="macroLfBaseDemand" d="" fill="none" stroke="#cb8d8d" stroke-width="2" stroke-dasharray="6 5"></path>
                  <path id="macroLfSupply" d="" fill="none" stroke="#1f5a67" stroke-width="3"></path>
                  <path id="macroLfDemand" d="" fill="none" stroke="#b52121" stroke-width="3"></path>
                  <circle id="macroLfEqPoint" cx="0" cy="0" r="6" fill="#c2892e" stroke="#fff8ec" stroke-width="2"></circle>
                  <text id="macroLfEqLabel" x="0" y="0" font-size="12" fill="#6a3f00" font-weight="700">r1</text>
                </svg>
              </article>

              <article class="macro-chart-card" data-chart="phillips">
                <div class="macro-chart-head">
                  <h3>Inflation-Unemployment</h3>
                  <span id="macroPcTag">Expectations</span>
                </div>
                <svg id="macroPcSvg" class="macro-svg" viewBox="0 0 640 360" role="img" aria-label="Inflation and unemployment linked graph">
                  <rect x="0" y="0" width="640" height="360" fill="#fffdf8"></rect>
                  <g id="macroPcGrid"></g>
                  <line x1="58" y1="314" x2="616" y2="314" stroke="#3a2a1a" stroke-width="2"></line>
                  <line x1="58" y1="314" x2="58" y2="24" stroke="#3a2a1a" stroke-width="2"></line>
                  <text x="492" y="338" font-size="12" fill="#433326">Unemployment u</text>
                  <text x="16" y="20" font-size="12" fill="#433326">Inflation </text>
                  <path id="macroPcBasePath" d="" fill="none" stroke="#cb8d8d" stroke-width="2" stroke-dasharray="6 5"></path>
                  <path id="macroPcPath" d="" fill="none" stroke="#b52121" stroke-width="3"></path>
                  <circle id="macroPcPoint" cx="0" cy="0" r="6" fill="#c2892e" stroke="#fff8ec" stroke-width="2"></circle>
                  <text id="macroPcLabel" x="0" y="0" font-size="12" fill="#6a3f00" font-weight="700">1</text>
                </svg>
              </article>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="section" id="intuitionStudio">
      <h2>Causal Intuition Studio</h2>
      <p class="lead">Train the logic chain the exam rewards most: <strong>shock -> incentives -> curve shift -> equilibrium outcome</strong>. Predict directions first, then compare to the economic mechanism.</p>
      <div class="intuition-grid">
        <div class="intuition-panel">
          <h3>Scenario Library</h3>
          <div class="intuition-library-tools">
            <div class="intuition-filter-row">
              <label for="intuitionTagFilter">Filter by module</label>
              <select id="intuitionTagFilter" class="intuition-select">
                <option value="all">All Modules</option>
                <option value="L01-L02">L01-L02: Markets + Policy</option>
                <option value="L05">L05: Spending + Saving</option>
                <option value="L06">L06: Labor Market</option>
                <option value="L07">L07: Growth + Production</option>
              </select>
            </div>
          </div>
          <div class="intuition-scenarios" id="intuitionScenarioCards"></div>
          <div class="flash-meta" id="intuitionStatsMeta">Attempts: 0  Perfect rounds: 0</div>
        </div>
        <div class="intuition-panel">
          <div class="intuition-head">
            <h3 id="intuitionScenarioTitle">Choose a scenario</h3>
            <span class="chip" id="intuitionScenarioTag">Intuition</span>
          </div>
          <p class="intuition-shock" id="intuitionShock">Select a scenario on the left to start directional reasoning practice.</p>
          <div class="intuition-tools">
            <label class="intuition-confidence" for="intuitionConfidence">
              Confidence level
              <select id="intuitionConfidence">
                <option value="medium">Medium confidence</option>
                <option value="high">High confidence</option>
                <option value="low">Low confidence</option>
              </select>
            </label>
            <div class="intuition-coach-meta" id="intuitionCoachMeta">Hint step 0/0  Filter: all modules</div>
          </div>
          <div class="intuition-vars" id="intuitionVars"></div>
          <div class="flash-actions">
            <button type="button" class="btn btn-primary" id="intuitionGradeBtn">Grade Predictions</button>
            <button type="button" class="btn btn-ghost" id="intuitionHintBtn">Hint Step</button>
            <button type="button" class="btn btn-ghost" id="intuitionRevealBtn">Reveal Logic</button>
            <button type="button" class="btn btn-ghost" id="intuitionNextBtn">Next Scenario</button>
          </div>
          <div class="arena-feedback" id="intuitionFeedback">Use the dropdowns, then click <strong>Grade Predictions</strong>.</div>
          <div class="intuition-debrief hidden" id="intuitionDebrief"></div>
          <div class="intuition-chain hidden" id="intuitionChain"></div>
        </div>
      </div>
    </section>

    <section class="section" id="errorClinic">
      <h2>Error Clinic</h2>
      <p class="lead">The mistakes that burn points fastest. Use this as your pre-exam diagnostic checklist.</p>
      <div class="grid cols-2">
        <div class="card">
          <h3>Calculation Errors</h3>
          <ul>
            <li>Using population instead of labor force in unemployment rate</li>
            <li>Forgetting midpoint denominator average values</li>
            <li>Mixing nominal and real GDP in growth calculations</li>
            <li>Dropping NX sign in saving-investment identity</li>
            <li>Failing to report units (million, billion, percent)</li>
          </ul>
        </div>
        <div class="card">
          <h3>Conceptual Errors</h3>
          <ul>
            <li>Treating transfer payments as G in GDP accounting</li>
            <li>Counting used goods or financial assets as current output</li>
            <li>Confusing frictional and structural unemployment</li>
            <li>Confusing marginal returns with returns to scale</li>
            <li>Forgetting revenue direction from elasticity classification</li>
          </ul>
        </div>
      </div>
    </section>

    <section class="section" id="trainingProtocol">
      <h2>Training Protocol (Feb 16-23, 2026)</h2>
      <p class="lead">A tight sequence for peak retention and score reliability under timed conditions.</p>
      <div class="timeline">
        <div class="tick"><strong>Mon Feb 16:</strong><span>L01-L02 deep drill: graph shifts + 20 elasticity problems.</span></div>
        <div class="tick"><strong>Tue Feb 17:</strong><span>L03 conceptual precision: GDP, unemployment, inflation, interest logic.</span></div>
        <div class="tick"><strong>Wed Feb 18:</strong><span>L04 full national accounts set: spending, real vs nominal, deflator.</span></div>
        <div class="tick"><strong>Thu Feb 19:</strong><span>L05 identities and channels: saving blocks and NX interpretation.</span></div>
        <div class="tick"><strong>Fri Feb 20:</strong><span>L06 labor market metrics timed repetitions.</span></div>
        <div class="tick"><strong>Sat Feb 21:</strong><span>L07 production function and growth mechanics.</span></div>
        <div class="tick"><strong>Sun Feb 22:</strong><span>Mock A under strict 75-minute timing + post-mortem.</span></div>
        <div class="tick"><strong>Mon Feb 23 (exam day):</strong><span>Only formulas, graph checklist, and error list. No new content.</span></div>
      </div>
    </section>

    <section class="section" id="timerLab">
      <h2>Exam Timer Lab</h2>
      <p class="lead">Run realistic timed practice blocks. Default is 75 minutes to match the exam length.</p>
      <div class="timer-panel">
        <div class="timer-display" id="timerDisplay">75:00</div>
        <div class="timer-controls">
          <label class="timer-label" for="timerMinutes">Minutes
            <input id="timerMinutes" class="timer-minutes" type="number" min="1" max="240" step="1" value="75" />
          </label>
          <button class="btn btn-primary" id="startTimerBtn" type="button">Start</button>
          <button class="btn btn-ghost" id="pauseTimerBtn" type="button">Pause</button>
          <button class="btn btn-ghost" id="resetTimerBtn" type="button">Reset</button>
        </div>
        <div class="timer-status" id="timerStatus">Ready. Set minutes, then start.</div>
      </div>
    </section>

    <section class="section" id="quantArena">
      <h2>Adaptive Quant Arena</h2>
      <p class="lead">Generate fresh numerical macro problems, submit a numeric answer, and get immediate grading plus worked solution.</p>
      <div class="arena-grid">
        <div class="arena-panel">
          <div class="arena-controls">
            <div class="arena-control-row">
              <label for="arenaType">Problem Type</label>
              <select id="arenaType" class="arena-select">
                <option value="mixed">Mixed rotation</option>
                <option value="gdp">GDP spending</option>
                <option value="deflator">Deflator inflation</option>
                <option value="labor">Unemployment rate</option>
                <option value="saving">Saving and net exports</option>
                <option value="real_rate">Real interest rate</option>
                <option value="elasticity">Elasticity midpoint</option>
              </select>
            </div>

            <div class="arena-control-row">
              <label for="arenaDifficulty">Difficulty</label>
              <select id="arenaDifficulty" class="arena-select">
                <option value="standard">Standard</option>
                <option value="challenge">Challenge</option>
              </select>
              <span class="arena-timer" id="arenaTimer">02:00</span>
            </div>

            <div class="arena-control-row">
              <button type="button" class="btn btn-primary" id="arenaGenerateBtn">Generate Challenge</button>
              <button type="button" class="btn btn-ghost" id="arenaCheckBtn">Check Answer</button>
              <button type="button" class="btn btn-ghost" id="arenaRevealBtn">Reveal Solution</button>
            </div>
          </div>

          <div class="arena-prompt" id="arenaPrompt">
            <h3>Challenge Ready</h3>
            <p>Press <strong>Generate Challenge</strong> to start a timed quantitative problem.</p>
          </div>

          <div class="arena-control-row">
            <input id="arenaAnswer" class="arena-answer-input" type="number" step="any" placeholder="Enter numeric answer (e.g., 4.25)" />
            <button type="button" class="btn btn-ghost" id="arenaNextBtn">Next</button>
            <button type="button" class="btn btn-ghost" id="arenaResetBtn">Reset Arena</button>
          </div>

          <div class="arena-feedback" id="arenaFeedback">Awaiting first challenge.</div>
          <div class="arena-solution" id="arenaSolution"></div>
        </div>

        <div class="arena-panel">
          <div class="arena-stats">
            <div class="arena-stat"><span>Solved</span><strong id="arenaSolved">0</strong></div>
            <div class="arena-stat"><span>Correct</span><strong id="arenaCorrect">0</strong></div>
            <div class="arena-stat"><span>Accuracy</span><strong id="arenaAccuracy">0%</strong></div>
            <div class="arena-stat"><span>Current Streak</span><strong id="arenaStreak">0</strong></div>
            <div class="arena-stat"><span>Best Streak</span><strong id="arenaBestStreak">0</strong></div>
            <div class="arena-stat"><span>Last Type</span><strong id="arenaLastType">-</strong></div>
          </div>
          <div class="formula-board">
            <div class="formula">\(\text{GDP: } Y = C + I + G + NX\)</div>
            <div class="formula">\(\pi_t^{\text{GDP}} = \frac{\text{Def}_t - \text{Def}_{t-1}}{\text{Def}_{t-1}} \times 100\)</div>
            <div class="formula">\(\text{Deflator} = \frac{\text{Nominal GDP}}{\text{Real GDP}} \times 100\)</div>
            <div class="formula">\(u = \frac{U}{LF},\quad LF = E + U\)</div>
            <div class="formula">\(S = Y - C - G,\quad NX = S - I\)</div>
            <div class="formula">\(\varepsilon_D=\frac{\frac{Q_2-Q_1}{(Q_2+Q_1)/2}}{\frac{P_2-P_1}{(P_2+P_1)/2}}\)</div>
          </div>
          <div class="lab-note">
            <h3>Execution Rule</h3>
            <p>Write units every time (%, billions, index points). Arena grading checks magnitude and sign, so careless formatting mistakes become visible immediately.</p>
          </div>
        </div>
      </div>
    </section>

    <section class="section" id="recallTrainer">
      <h2>Interactive Recall Trainer</h2>
      <p class="lead">Run adaptive retrieval rounds with explicit answer flow: choose an option, click <strong>Submit Answer</strong>, then rate recall quality. No MathTeX typing is required.</p>
      <div class="flash-wrap">
        <div class="flash-head">
          <div class="flash-meta" id="flashMeta">Prompt 1 / 10</div>
          <div class="flash-meta" id="flashMasteredMeta">Mastered: 0</div>
        </div>
        <div class="flash-meta" id="flashAdaptiveMeta">Due now: 10  Recall score: 0%</div>
        <div class="flash-q" id="flashQ">Click New Prompt to start.</div>
        <div class="flash-mode">
          <div class="flash-meta" id="flashModeMeta">Format: Multiple Choice</div>
          <div class="flash-meta" id="flashAttemptMeta">Status: Awaiting submission</div>
        </div>
        <div class="flash-mode-help" id="flashModeHelp">Select one option below and press <strong>Submit Answer</strong>. Then use Again/Hard/Good/Easy to schedule the next review.</div>
        <div class="recall-options" id="recallOptions"></div>
        <div class="recall-submit-row">
          <button type="button" class="btn btn-primary" id="submitAnswerBtn">Submit Answer</button>
          <button type="button" class="btn btn-ghost" id="clearAnswerBtn">Clear Selection</button>
        </div>
        <div class="arena-feedback" id="recallFeedback">No response submitted yet.</div>
        <div class="flash-a" id="flashA"></div>
        <div class="study-stats">
          <span class="stat-pill">Seen: <span id="seenCount">0</span></span>
          <span class="stat-pill">Remaining: <span id="remainingCount">0</span></span>
          <span class="stat-pill">Recall Score: <span id="recallScore">0%</span></span>
        </div>
        <div class="flash-actions">
          <button type="button" class="btn btn-primary" id="newCardBtn">New Prompt</button>
          <button type="button" class="btn btn-ghost" id="showAnswerBtn">Reveal Answer</button>
          <button type="button" class="btn btn-ghost" id="markMasteredBtn">Mark Mastered</button>
          <button type="button" class="btn btn-ghost" id="clearMasteredBtn">Reset Deck</button>
        </div>
        <div class="rating-actions">
          <button type="button" class="btn btn-ghost" id="rateAgainBtn">Again</button>
          <button type="button" class="btn btn-ghost" id="rateHardBtn">Hard</button>
          <button type="button" class="btn btn-ghost" id="rateGoodBtn">Good</button>
          <button type="button" class="btn btn-primary" id="rateEasyBtn">Easy</button>
        </div>
      </div>
      <div class="progress-wrap">
        <div class="progress-meta">
          <strong id="progressPct">0% complete</strong>
          <span id="progressText">0 of 6 checklist targets done</span>
        </div>
        <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
        <div class="flash-actions">
          <button type="button" class="btn btn-ghost" id="resetChecklistBtn">Reset Checklist</button>
        </div>
      </div>
      <div class="checklist" id="checklist"></div>
    </section>

    <section class="section" id="resourceDock">
      <h2>Resource Dock</h2>
      <p class="lead">All premium assets in one place. Use mock -> key -> error log workflow.</p>
      <div class="resource-controls">
        <input id="resourceFilter" class="resource-filter-input" type="search" placeholder="Filter resources (e.g., mock, key, cram, recall, master)...">
        <span class="chip" id="resourceCount">6 resources</span>
      </div>
      <div class="resource-grid" id="resourceGrid">
        <article class="resource" data-tags="master study formulas graph protocol guide">
          <h3>Master Study Tool</h3>
          <p>High-yield syllabus-aligned map, formulas, graph protocol, and examples.</p>
          <div class="links">
            <a class="badge" href="ECON205_Midterm1_Master_Study_Tool.pdf">PDF</a>
            <a class="badge" href="ECON205_Midterm1_Master_Study_Tool.md">MD</a>
          </div>
        </article>
        <article class="resource" data-tags="active recall bank retrieval questions key">
          <h3>Active Recall Bank</h3>
          <p>100-prompt retrieval system plus complete key.</p>
          <div class="links">
            <a class="badge" href="ECON205_Midterm1_Active_Recall_Bank.pdf">Bank PDF</a>
            <a class="badge" href="ECON205_Midterm1_Active_Recall_Bank_Key.pdf">Key PDF</a>
          </div>
        </article>
        <article class="resource" data-tags="mock exam a timed simulation key">
          <h3>Mock Exam A</h3>
          <p>Timed full simulation with worked key.</p>
          <div class="links">
            <a class="badge" href="ECON205_Midterm1_Mock_Exam_A.pdf">Exam</a>
            <a class="badge" href="ECON205_Midterm1_Mock_Exam_A_Key.pdf">Key</a>
          </div>
        </article>
        <article class="resource" data-tags="mock exam b timed simulation key">
          <h3>Mock Exam B</h3>
          <p>Fresh numbers and scenario variants with key.</p>
          <div class="links">
            <a class="badge" href="ECON205_Midterm1_Mock_Exam_B.pdf">Exam</a>
            <a class="badge" href="ECON205_Midterm1_Mock_Exam_B_Key.pdf">Key</a>
          </div>
        </article>
        <article class="resource" data-tags="mock exam c timed simulation key">
          <h3>Mock Exam C</h3>
          <p>Third variation to avoid pattern memorization.</p>
          <div class="links">
            <a class="badge" href="ECON205_Midterm1_Mock_Exam_C.pdf">Exam</a>
            <a class="badge" href="ECON205_Midterm1_Mock_Exam_C_Key.pdf">Key</a>
          </div>
        </article>
        <article class="resource" data-tags="complete pack binder cram sheet printable">
          <h3>Complete Study Pack</h3>
          <p>Consolidated 34-page printable binder.</p>
          <div class="links">
            <a class="badge" href="ECON205_Midterm1_Complete_Study_Pack.pdf">Open Binder</a>
            <a class="badge" href="ECON205_Midterm1_Cram_Sheet_OnePage.pdf">Cram Sheet</a>
          </div>
        </article>
      </div>
    </section>

    <footer>
      ECON 205 Study Studio | Built for high-fidelity macro learning at scale. Instructional direction by Dr. Ian Helfrich.
    </footer>
  </div>

  <script>
    const prompts = [
      {
        id: "spending_identity",
        q: "Which equation is the expenditure identity for GDP?",
        choices: [
          "\\(Y = C + I + G + NX\\)",
          "\\(Y = C + G + T + M\\)",
          "\\(Y = W + r + T + NX\\)",
          "\\(Y = C + I + G - NX\\)"
        ],
        correctChoice: 0,
        guidance: "No formula typing needed. Pick the identity with consumption, investment, government purchases, and net exports.",
        a: "Correct: \\(Y = C + I + G + NX\\). It decomposes total output into final spending components."
      },
      {
        id: "unemployment_formula",
        q: "Which pair correctly defines labor force and unemployment rate?",
        choices: [
          "\\(LF = E + U\\), \\(u = \\frac{U}{LF}\\)",
          "\\(LF = E + U\\), \\(u = \\frac{U}{Population}\\)",
          "\\(LF = Population - E\\), \\(u = \\frac{E}{LF}\\)",
          "\\(LF = E\\), \\(u = \\frac{U}{E}\\)"
        ],
        correctChoice: 0,
        guidance: "Focus on denominator discipline: unemployment rate uses labor force, not total population.",
        a: "Correct: \\(LF = E + U\\) and \\(u = U/LF\\)."
      },
      {
        id: "binding_ceiling_outcome",
        q: "A binding price ceiling (below equilibrium) causes:",
        choices: [
          "A surplus because quantity supplied exceeds quantity demanded.",
          "A shortage because quantity demanded exceeds quantity supplied.",
          "No market gap because price controls only affect producers.",
          "Higher equilibrium price and higher equilibrium quantity."
        ],
        correctChoice: 1,
        guidance: "Ceiling below equilibrium pushes price down. At low price, demand rises and supply falls.",
        a: "Correct: binding ceiling -> shortage, because \\(Q_D > Q_S\\) at the controlled price."
      },
      {
        id: "midpoint_elasticity",
        q: "Which expression is the midpoint formula for demand elasticity?",
        choices: [
          "\\(\\varepsilon_D = \\frac{\\Delta Q}{\\Delta P}\\)",
          "\\(\\varepsilon_D = \\frac{\\frac{Q_2-Q_1}{Q_1}}{\\frac{P_2-P_1}{P_1}}\\)",
          "\\(\\varepsilon_D = \\frac{\\frac{Q_2-Q_1}{(Q_2+Q_1)/2}}{\\frac{P_2-P_1}{(P_2+P_1)/2}}\\)",
          "\\(\\varepsilon_D = \\frac{P_2-P_1}{Q_2-Q_1}\\)"
        ],
        correctChoice: 2,
        guidance: "Choose the version using averages in both denominator terms.",
        a: "Correct midpoint elasticity: \\(\\varepsilon_D = \\frac{\\frac{Q_2-Q_1}{(Q_2+Q_1)/2}}{\\frac{P_2-P_1}{(P_2+P_1)/2}}\\)."
      },
      {
        id: "nominal_real_gdp",
        q: "What best distinguishes nominal GDP from real GDP?",
        choices: [
          "Nominal GDP uses base-year prices; real GDP uses current prices.",
          "Nominal GDP excludes services; real GDP includes services.",
          "Nominal GDP uses current prices; real GDP uses base-year prices.",
          "Nominal GDP is always smaller than real GDP."
        ],
        correctChoice: 2,
        guidance: "Real GDP fixes prices to isolate quantity changes.",
        a: "Correct: nominal GDP uses current prices, real GDP uses base-year prices."
      },
      {
        id: "saving_nx_numeric",
        q: "If national saving \\(S = 800\\) and investment \\(I = 950\\), what is \\(NX\\)?",
        choices: [
          "\\(+150\\)",
          "\\(-150\\)",
          "\\(+1750\\)",
          "\\(-1750\\)"
        ],
        correctChoice: 1,
        guidance: "Use \\(NX = S - I\\). Keep the sign.",
        a: "Correct: \\(NX = S - I = 800 - 950 = -150\\), a trade deficit."
      },
      {
        id: "returns_to_scale",
        q: "For \\(Y = A K^{0.5}L^{0.5}\\), if both \\(K\\) and \\(L\\) double, output:",
        choices: [
          "Stays unchanged.",
          "Increases by 50%.",
          "Doubles.",
          "Quadruples."
        ],
        correctChoice: 2,
        guidance: "Exponents sum to 1 -> constant returns to scale.",
        a: "Correct: output doubles. With constant returns to scale, scaling all inputs by 2 scales output by 2."
      },
      {
        id: "real_rate_effects",
        q: "Holding other factors fixed, a higher real interest rate usually causes current:",
        choices: [
          "Consumption and investment to increase.",
          "Consumption and investment to decrease.",
          "Consumption to increase and investment to decrease.",
          "No change in either consumption or investment."
        ],
        correctChoice: 1,
        guidance: "Higher real rates reward waiting and raise borrowing cost.",
        a: "Correct: both current consumption and investment tend to decrease when real rates rise."
      },
      {
        id: "gdp_deflator_meaning",
        q: "Which statement about the GDP deflator is correct?",
        choices: [
          "It equals CPI by construction in every year.",
          "It is \\(\\frac{\\text{Nominal GDP}}{\\text{Real GDP}}\\times100\\), and its growth measures inflation in domestic final output.",
          "It tracks unemployment in the labor force.",
          "It includes only imported goods."
        ],
        correctChoice: 1,
        guidance: "Remember: deflator is a price index for domestically produced final goods/services.",
        a: "Correct: \\(\\text{Deflator} = \\frac{Nominal}{Real} \\times 100\\), and its growth rate is GDP inflation."
      },
      {
        id: "unemployment_types",
        q: "Which set correctly lists the four unemployment types used in this course?",
        choices: [
          "Natural, cyclical, imported, and seasonal",
          "Frictional, structural, cyclical, and seasonal",
          "Voluntary, involuntary, nominal, and real",
          "Structural, demographic, frictional, and monetary"
        ],
        correctChoice: 1,
        guidance: "Memorize this list exactly for concept questions.",
        a: "Correct set: frictional, structural, cyclical, and seasonal unemployment."
      }
    ];

    const dailyChecks = [
      "Can compute GDP, real GDP, deflator, inflation without notes",
      "Can compute LF, unemployment, LFPR, EPOP quickly",
      "Can classify elastic vs inelastic and predict revenue direction",
      "Can draw binding ceiling/floor graph with full labels",
      "Can do saving decomposition and infer NX",
      "Can distinguish marginal returns vs returns to scale"
    ];

    const INTUITION_OPTIONS = [
      { value: "up", label: "Increase ()" },
      { value: "down", label: "Decrease ()" },
      { value: "flat", label: "No clear change (~)" }
    ];

    const INTUITION_CONFIDENCE = {
      low: { label: "Low confidence", penaltyPerWrong: 2, perfectBonus: 0 },
      medium: { label: "Medium confidence", penaltyPerWrong: 4, perfectBonus: 2 },
      high: { label: "High confidence", penaltyPerWrong: 7, perfectBonus: 4 }
    };

    const INTUITION_TAG_FILTERS = {
      all: {
        label: "all modules",
        markers: []
      },
      "L01-L02": {
        label: "L01-L02",
        markers: ["L01", "L02"]
      },
      L05: {
        label: "L05",
        markers: ["L05"]
      },
      L06: {
        label: "L06",
        markers: ["L06"]
      },
      L07: {
        label: "L07",
        markers: ["L07"]
      }
    };

    const intuitionScenarios = [
      {
        id: "demand_income_jump",
        title: "Income Shock for a Normal Good",
        tag: "L01 Supply and Demand",
        shock: "Household income rises for a normal good while supply conditions are unchanged.",
        chain: [
          "Income rise increases willingness to pay for a normal good.",
          "Demand shifts right from \\(D_0\\) to \\(D_1\\); supply stays at \\(S_0\\).",
          "New equilibrium has higher price and higher quantity."
        ],
        variables: [
          {
            id: "price",
            label: "Equilibrium price \\(P^*\\)",
            answer: "up",
            why: "Rightward demand shift with fixed supply pushes equilibrium price upward."
          },
          {
            id: "quantity",
            label: "Equilibrium quantity \\(Q^*\\)",
            answer: "up",
            why: "A stronger demand schedule intersects supply at a larger quantity."
          },
          {
            id: "gap",
            label: "Shortage/surplus gap at equilibrium",
            answer: "flat",
            why: "At equilibrium, quantity demanded still equals quantity supplied, so the gap remains zero."
          },
          {
            id: "revenue",
            label: "Producer revenue \\((P \\times Q)\\)",
            answer: "up",
            why: "Both equilibrium price and quantity increase, so producer revenue rises."
          }
        ]
      },
      {
        id: "supply_cost_spike",
        title: "Input Cost Shock",
        tag: "L01-L02 Curves and Policy",
        shock: "Input costs rise sharply, reducing quantity supplied at every price.",
        chain: [
          "Higher production cost shifts supply left from \\(S_0\\) to \\(S_1\\).",
          "Demand remains unchanged in the baseline setup.",
          "New equilibrium moves to higher price and lower quantity."
        ],
        variables: [
          {
            id: "price",
            label: "Equilibrium price \\(P^*\\)",
            answer: "up",
            why: "Leftward supply shift creates upward price pressure at intersection with demand."
          },
          {
            id: "quantity",
            label: "Equilibrium quantity \\(Q^*\\)",
            answer: "down",
            why: "Less supply at each price means market-clearing quantity contracts."
          },
          {
            id: "supply_position",
            label: "Supply position (at any given price)",
            answer: "down",
            why: "A cost shock reduces supplied quantity at each price, i.e., a left shift."
          },
          {
            id: "gap",
            label: "Shortage/surplus gap at equilibrium",
            answer: "flat",
            why: "Even after the shift, equilibrium still clears the market."
          }
        ]
      },
      {
        id: "binding_ceiling",
        title: "Binding Price Ceiling",
        tag: "L02 Price Controls",
        shock: "A price ceiling is imposed below the original equilibrium price \\(P^*\\).",
        chain: [
          "Ceiling forces observed price down to \\(P_c < P^*\\).",
          "At lower price, quantity demanded rises while quantity supplied falls.",
          "The market does not clear: shortage appears and transactions are limited by supply."
        ],
        variables: [
          {
            id: "price",
            label: "Observed transaction price",
            answer: "down",
            why: "A binding ceiling caps legal price below market-clearing level."
          },
          {
            id: "traded_qty",
            label: "Quantity actually traded",
            answer: "down",
            why: "Actual trades are constrained by the smaller supplied quantity at \\(P_c\\)."
          },
          {
            id: "shortage",
            label: "Shortage size \\((Q_D - Q_S)\\)",
            answer: "up",
            why: "Demand exceeds supply at the capped low price."
          },
          {
            id: "search_cost",
            label: "Queue/search/non-price rationing costs",
            answer: "up",
            why: "Shortages force buyers to spend more time and effort to obtain goods."
          }
        ]
      },
      {
        id: "real_rate_hike",
        title: "Higher Real Interest Rate",
        tag: "L05 Spending and Saving",
        shock: "Real interest rate rises while income is held fixed in the short run.",
        chain: [
          "Higher \\(r\\) raises the reward to postponing consumption.",
          "Current consumption and many investment projects fall.",
          "With \\(S = Y - C - G\\) and \\(NX = S - I\\), lower \\(C\\) and \\(I\\) push \\(NX\\) up."
        ],
        variables: [
          {
            id: "consumption",
            label: "Current consumption \\(C\\)",
            answer: "down",
            why: "Intertemporal substitution encourages shifting spending into the future."
          },
          {
            id: "investment",
            label: "Investment \\(I\\)",
            answer: "down",
            why: "Higher financing cost makes fewer projects profitable."
          },
          {
            id: "saving",
            label: "National saving \\(S\\)",
            answer: "up",
            why: "With fixed \\(Y\\) and \\(G\\), lower \\(C\\) implies higher \\(S = Y - C - G\\)."
          },
          {
            id: "nx",
            label: "Net exports \\(NX\\)",
            answer: "up",
            why: "Using \\(NX = S - I\\), higher \\(S\\) and lower \\(I\\) raise \\(NX\\)."
          }
        ]
      },
      {
        id: "gov_spending_rise",
        title: "Government Spending Expansion",
        tag: "L05 National Accounts",
        shock: "Government purchases increase with taxes unchanged; treat \\(Y\\) and \\(C\\) as fixed in this accounting drill.",
        chain: [
          "A higher \\(G\\) directly raises the government spending share.",
          "National saving falls because \\(S = Y - C - G\\).",
          "Holding investment constant in the short accounting setup, \\(NX = S - I\\) declines."
        ],
        variables: [
          {
            id: "g",
            label: "Government purchases \\(G\\)",
            answer: "up",
            why: "The policy shock is defined as an increase in \\(G\\)."
          },
          {
            id: "saving",
            label: "National saving \\(S\\)",
            answer: "down",
            why: "With fixed \\(Y\\) and \\(C\\), larger \\(G\\) mechanically reduces \\(S\\)."
          },
          {
            id: "nx",
            label: "Net exports \\(NX\\) (holding \\(I\\) fixed)",
            answer: "down",
            why: "Lower \\(S\\) with unchanged \\(I\\) implies lower \\(NX = S - I\\)."
          },
          {
            id: "r_pressure",
            label: "Real interest rate pressure",
            answer: "up",
            why: "Lower public saving tightens loanable funds and tends to push \\(r\\) upward."
          }
        ]
      },
      {
        id: "matching_efficiency",
        title: "Better Job Matching Technology",
        tag: "L06 Labor Market",
        shock: "A new platform reduces search frictions between workers and firms.",
        chain: [
          "Faster matching shortens job-search duration.",
          "Frictional unemployment falls, reducing the natural unemployment rate.",
          "More workers are matched into employment at a given point in time."
        ],
        variables: [
          {
            id: "frictional",
            label: "Frictional unemployment",
            answer: "down",
            why: "The source of friction is directly reduced by better matching."
          },
          {
            id: "natural_u",
            label: "Natural unemployment rate",
            answer: "down",
            why: "Natural unemployment includes frictional plus structural components."
          },
          {
            id: "epop",
            label: "Employment-to-population ratio (EPOP)",
            answer: "up",
            why: "Quicker matching lifts employment among the adult population."
          },
          {
            id: "potential_y",
            label: "Potential output capacity",
            answer: "up",
            why: "Higher sustained employment increases available labor input."
          }
        ]
      },
      {
        id: "tfp_jump",
        title: "Productivity Increase (TFP)",
        tag: "L07 Production and Growth",
        shock: "Total factor productivity \\(A\\) rises in \\(Y = A K^{0.5} L^{0.5}\\), with \\(K\\) and \\(L\\) fixed.",
        chain: [
          "Higher \\(A\\) scales output upward for the same inputs.",
          "Marginal products rise because each unit of capital and labor becomes more productive.",
          "Wages and output per worker rise with stronger productivity."
        ],
        variables: [
          {
            id: "output",
            label: "Total output \\(Y\\)",
            answer: "up",
            why: "In the production function, \\(A\\) is a multiplicative efficiency term."
          },
          {
            id: "y_per_l",
            label: "Output per worker \\(Y/L\\)",
            answer: "up",
            why: "With fixed \\(L\\), a higher \\(A\\) raises total output and therefore \\(Y/L\\)."
          },
          {
            id: "mpl",
            label: "Marginal product of labor",
            answer: "up",
            why: "Higher productivity raises additional output from one more unit of labor."
          },
          {
            id: "rts",
            label: "Returns-to-scale classification",
            answer: "flat",
            why: "Changing \\(A\\) shifts level, not whether exponents imply constant returns."
          }
        ]
      },
      {
        id: "scale_up_crs",
        title: "Doubling Capital and Labor Under CRS",
        tag: "L07 Production and Growth",
        shock: "In \\(Y = A K^{0.5} L^{0.5}\\), both \\(K\\) and \\(L\\) double while \\(A\\) is unchanged.",
        chain: [
          "Exponents sum to 1, so the function has constant returns to scale.",
          "Scaling both inputs by 2 scales output by 2.",
          "Because \\(K/L\\) is unchanged, output per worker stays roughly unchanged."
        ],
        variables: [
          {
            id: "output",
            label: "Total output \\(Y\\)",
            answer: "up",
            why: "Under CRS, doubling all inputs doubles output."
          },
          {
            id: "y_per_l",
            label: "Output per worker \\(Y/L\\)",
            answer: "flat",
            why: "Both numerator and denominator double, leaving \\(Y/L\\) unchanged."
          },
          {
            id: "k_per_l",
            label: "Capital per worker \\(K/L\\)",
            answer: "flat",
            why: "Both \\(K\\) and \\(L\\) double, so their ratio is unchanged."
          },
          {
            id: "rts",
            label: "Returns-to-scale classification",
            answer: "flat",
            why: "Classification remains constant returns to scale."
          }
        ]
      }
    ];

    const FORMULA_SOURCES = ["manual", "fred", "bls", "computed"];

    const FORMULA_VARIABLES = {
      y: {
        id: "y",
        symbolLatex: "Y",
        label: "Output / GDP",
        definition: "Total market value of final goods and services produced domestically over a period.",
        role: "The aggregate output target in national income accounting.",
        units: "Usually billions of dollars (real or nominal, depending on context).",
        dataMap: "BEA national accounts; FRED example: GDPC1 (real GDP).",
        examHint: "Track exactly which components changed and whether the identity is nominal or real.",
        sources: { fred: { seriesId: "GDPC1", label: "Real GDP (quarterly)" } }
      },
      c: {
        id: "c",
        symbolLatex: "C",
        label: "Consumption",
        definition: "Household spending on final goods and services.",
        role: "Largest GDP expenditure component in most modern economies.",
        units: "Billions of dollars.",
        dataMap: "BEA consumption expenditure; FRED example: PCECC96.",
        examHint: "Higher real rates typically reduce current consumption through intertemporal substitution.",
        sources: { fred: { seriesId: "PCECC96", label: "Real personal consumption expenditures" } }
      },
      i: {
        id: "i",
        symbolLatex: "I",
        label: "Investment",
        definition: "Spending on capital goods, inventories, and residential structures.",
        role: "Links savings behavior and future productive capacity.",
        units: "Billions of dollars.",
        dataMap: "BEA gross private domestic investment; FRED example: GPDIC1.",
        examHint: "Investment is highly interest-sensitive in short-run comparative statics.",
        sources: { fred: { seriesId: "GPDIC1", label: "Real gross private domestic investment" } }
      },
      g: {
        id: "g",
        symbolLatex: "G",
        label: "Government Purchases",
        definition: "Government spending on final goods and services.",
        role: "Direct fiscal channel inside the spending identity.",
        units: "Billions of dollars.",
        dataMap: "BEA government consumption and investment; FRED example: GCEC1.",
        examHint: "Transfer payments are not part of \\(G\\) in GDP accounting.",
        sources: { fred: { seriesId: "GCEC1", label: "Real government consumption and investment" } }
      },
      nx: {
        id: "nx",
        symbolLatex: "NX",
        label: "Net Exports",
        definition: "Exports minus imports.",
        role: "Connects domestic saving-investment balance to external trade balance.",
        units: "Billions of dollars.",
        dataMap: "Trade balance in national accounts; FRED example: NETEXP.",
        examHint: "Remember sign conventions: deficit means \\(NX < 0\\).",
        sources: { fred: { seriesId: "NETEXP", label: "Net exports of goods and services" } }
      },
      x: {
        id: "x",
        symbolLatex: "X",
        label: "Exports",
        definition: "Domestic production sold abroad.",
        role: "Positive contributor to domestic GDP.",
        units: "Billions of dollars.",
        dataMap: "BEA exports; FRED example: EXPGSC1.",
        examHint: "Exports are produced domestically, so they are included in GDP.",
        sources: { fred: { seriesId: "EXPGSC1", label: "Real exports of goods and services" } }
      },
      m: {
        id: "m",
        symbolLatex: "M",
        label: "Imports",
        definition: "Foreign production purchased domestically.",
        role: "Subtracted from GDP to avoid counting foreign production.",
        units: "Billions of dollars.",
        dataMap: "BEA imports; FRED example: IMPGSC1.",
        examHint: "Imports are subtracted in expenditure GDP even when purchased by domestic agents.",
        sources: { fred: { seriesId: "IMPGSC1", label: "Real imports of goods and services" } }
      },
      nominal_gdp: {
        id: "nominal_gdp",
        symbolLatex: "\\text{Nominal GDP}",
        label: "Nominal GDP",
        definition: "GDP measured at current-period prices.",
        role: "Numerator in the GDP deflator identity.",
        units: "Billions of current dollars.",
        dataMap: "BEA nominal GDP; FRED example: GDP.",
        examHint: "Nominal changes mix quantity and price movements.",
        sources: { fred: { seriesId: "GDP", label: "Gross Domestic Product (nominal)" } }
      },
      real_gdp: {
        id: "real_gdp",
        symbolLatex: "\\text{Real GDP}",
        label: "Real GDP",
        definition: "GDP measured in base-year prices (chain-weighted in modern data).",
        role: "Denominator in deflator; isolates volume changes.",
        units: "Billions of chained dollars.",
        dataMap: "BEA real GDP; FRED example: GDPC1.",
        examHint: "Real GDP tracks quantity/volume, not current prices.",
        sources: { fred: { seriesId: "GDPC1", label: "Real GDP" } }
      },
      deflator_t: {
        id: "deflator_t",
        symbolLatex: "\\text{Def}_t",
        label: "GDP Deflator (Current Period)",
        definition: "Price index for domestically produced final output in period \\(t\\).",
        role: "Current-period index level used to compute GDP inflation.",
        units: "Index level (base year = 100).",
        dataMap: "FRED example: GDPDEF.",
        examHint: "Deflator growth is inflation for domestic final output.",
        sources: { fred: { seriesId: "GDPDEF", label: "GDP implicit price deflator" } }
      },
      deflator_t1: {
        id: "deflator_t1",
        symbolLatex: "\\text{Def}_{t-1}",
        label: "GDP Deflator (Previous Period)",
        definition: "GDP deflator in the prior comparison period.",
        role: "Base level in the inflation growth-rate denominator.",
        units: "Index level (base year = 100).",
        dataMap: "Use lagged value from GDPDEF or equivalent index.",
        examHint: "Always divide by the earlier period level when computing growth.",
        sources: { fred: { seriesId: "GDPDEF", label: "GDP implicit price deflator (lagged value)" } }
      },
      inflation_gdp: {
        id: "inflation_gdp",
        symbolLatex: "\\pi_t^{GDP}",
        label: "GDP Inflation",
        definition: "Percent change in GDP deflator from \\(t-1\\) to \\(t\\).",
        role: "Output of the GDP-inflation formula.",
        units: "Percent.",
        dataMap: "Derived from GDPDEF levels.",
        examHint: "Compute as growth rate of deflator, not nominal GDP growth.",
        sources: {}
      },
      t: {
        id: "t",
        symbolLatex: "T",
        label: "Net Taxes",
        definition: "Government tax revenue net of transfers.",
        role: "Separates private and public saving in fiscal decomposition.",
        units: "Billions of dollars.",
        dataMap: "National accounts fiscal aggregates; often instructor-provided in exam drills.",
        examHint: "Keep sign discipline: transfers reduce net taxes.",
        sources: {}
      },
      sp: {
        id: "sp",
        symbolLatex: "S_p",
        label: "Private Saving",
        definition: "Income left after household consumption and net taxes.",
        role: "Private-sector contribution to national saving.",
        units: "Billions of dollars.",
        dataMap: "Derived from \\(Y, C, T\\), not typically observed directly in intro datasets.",
        examHint: "If \\(C\\) rises with \\(Y, T\\) fixed, private saving falls one-for-one.",
        sources: {}
      },
      sg: {
        id: "sg",
        symbolLatex: "S_g",
        label: "Public Saving",
        definition: "Government net revenue after purchases.",
        role: "Fiscal component of national saving.",
        units: "Billions of dollars.",
        dataMap: "Derived from \\(T - G\\).",
        examHint: "Budget deficits imply negative public saving.",
        sources: {}
      },
      s: {
        id: "s",
        symbolLatex: "S",
        label: "National Saving",
        definition: "Total saving available for domestic investment and/or net foreign lending.",
        role: "Bridge between domestic spending and external balance.",
        units: "Billions of dollars.",
        dataMap: "Derived from \\(Y - C - G\\).",
        examHint: "Higher \\(G\\) with fixed \\(Y, C\\) lowers national saving.",
        sources: {}
      },
      e: {
        id: "e",
        symbolLatex: "E",
        label: "Employed",
        definition: "Number of people currently employed.",
        role: "Component of labor force and numerator for EPOP.",
        units: "Persons (often thousands).",
        dataMap: "BLS household survey; BLS series: LNS12000000.",
        examHint: "Employment can rise even if unemployment rate rises when labor force expands faster.",
        sources: {
          fred: { seriesId: "CE16OV", label: "Civilian employment level" },
          bls: { seriesId: "LNS12000000", label: "Employment level (household survey)" }
        }
      },
      u: {
        id: "u",
        symbolLatex: "U",
        label: "Unemployed",
        definition: "People without a job who are actively searching for one.",
        role: "Numerator in unemployment rate.",
        units: "Persons (often thousands).",
        dataMap: "BLS household survey; BLS series: LNS13000000.",
        examHint: "Not in labor force is distinct from unemployed.",
        sources: {
          fred: { seriesId: "UNEMPLOY", label: "Number unemployed" },
          bls: { seriesId: "LNS13000000", label: "Unemployment level (household survey)" }
        }
      },
      lf: {
        id: "lf",
        symbolLatex: "\\text{LF}",
        label: "Labor Force",
        definition: "Sum of employed and unemployed workers.",
        role: "Denominator for unemployment rate; numerator for LFPR.",
        units: "Persons (often thousands).",
        dataMap: "BLS household survey; BLS series: LNS11000000.",
        examHint: "Do not divide unemployment by population; divide by labor force.",
        sources: {
          fred: { seriesId: "CLF16OV", label: "Civilian labor force" },
          bls: { seriesId: "LNS11000000", label: "Labor force level (household survey)" }
        }
      },
      adults: {
        id: "adults",
        symbolLatex: "\\text{Adults}",
        label: "Adult Population",
        definition: "Civilian noninstitutional population used for participation ratios.",
        role: "Base population for LFPR and EPOP.",
        units: "Persons (often thousands).",
        dataMap: "BLS/Census concept; FRED example: CNP16OV.",
        examHint: "Participation and employment-population ratios use adults, not labor force.",
        sources: {
          fred: { seriesId: "CNP16OV", label: "Civilian noninstitutional population" }
        }
      },
      u_rate: {
        id: "u_rate",
        symbolLatex: "u",
        label: "Unemployment Rate",
        definition: "Share of labor force that is unemployed.",
        role: "Headline labor-market slack indicator in intro macro.",
        units: "Percent.",
        dataMap: "BLS monthly release; BLS series: LNS14000000.",
        examHint: "Rate can move for numerator or denominator reasons.",
        sources: {
          fred: { seriesId: "UNRATE", label: "Civilian unemployment rate" },
          bls: { seriesId: "LNS14000000", label: "Unemployment rate" }
        }
      },
      lfpr: {
        id: "lfpr",
        symbolLatex: "\\text{LFPR}",
        label: "Labor Force Participation Rate",
        definition: "Labor force as a share of adult population.",
        role: "Tracks participation decisions, not just job-finding.",
        units: "Percent.",
        dataMap: "BLS series: LNS11300000.",
        examHint: "LFPR can fall even with strong job growth if fewer adults participate.",
        sources: {
          fred: { seriesId: "CIVPART", label: "Labor force participation rate" },
          bls: { seriesId: "LNS11300000", label: "Labor force participation rate" }
        }
      },
      epop: {
        id: "epop",
        symbolLatex: "\\text{EPOP}",
        label: "Employment-Population Ratio",
        definition: "Employment as a share of adult population.",
        role: "Broad utilization metric less sensitive to pure search-status definitions.",
        units: "Percent.",
        dataMap: "BLS series: LNS12300000.",
        examHint: "EPOP captures both participation and employment dynamics.",
        sources: {
          fred: { seriesId: "EMRATIO", label: "Employment-population ratio" },
          bls: { seriesId: "LNS12300000", label: "Employment-population ratio" }
        }
      },
      i_nominal: {
        id: "i_nominal",
        symbolLatex: "i",
        label: "Nominal Interest Rate",
        definition: "Quoted interest rate not adjusted for inflation expectations.",
        role: "Starting point for real-rate approximation.",
        units: "Percent.",
        dataMap: "Market or policy rate; FRED examples include FEDFUNDS, GS1, GS10.",
        examHint: "Nominal rates can rise while real rates fall if expected inflation rises faster.",
        sources: { fred: { seriesId: "FEDFUNDS", label: "Effective federal funds rate" } }
      },
      pi_expected: {
        id: "pi_expected",
        symbolLatex: "\\pi^e",
        label: "Expected Inflation",
        definition: "Inflation households/firms/investors expect over the relevant horizon.",
        role: "Subtracted from nominal rate to approximate real rate.",
        units: "Percent.",
        dataMap: "Survey or market-implied expectation; FRED example: T5YIE.",
        examHint: "Expectation horizon should match interest-rate horizon in careful applications.",
        sources: { fred: { seriesId: "T5YIE", label: "5-year breakeven inflation" } }
      },
      r_real: {
        id: "r_real",
        symbolLatex: "r",
        label: "Real Interest Rate",
        definition: "Inflation-adjusted intertemporal price of consumption.",
        role: "Core channel for consumption/investment timing choices.",
        units: "Percent.",
        dataMap: "Approximate from \\(i - \\pi^e\\) or use inflation-indexed yields.",
        examHint: "Use approximation with care when inflation is high/volatile.",
        sources: {}
      },
      q1: {
        id: "q1",
        symbolLatex: "Q_1",
        label: "Initial Quantity",
        definition: "Quantity demanded before a price change.",
        role: "One endpoint in midpoint elasticity calculation.",
        units: "Units of the good.",
        dataMap: "Observed quantity from problem statement or market data.",
        examHint: "Keep endpoint labels consistent with the paired price point.",
        sources: {}
      },
      q2: {
        id: "q2",
        symbolLatex: "Q_2",
        label: "New Quantity",
        definition: "Quantity demanded after price change.",
        role: "Second endpoint in midpoint elasticity.",
        units: "Units of the good.",
        dataMap: "Observed quantity from problem statement or market data.",
        examHint: "Midpoint method is symmetric, so ordering should not change final elasticity magnitude sign logic.",
        sources: {}
      },
      p1: {
        id: "p1",
        symbolLatex: "P_1",
        label: "Initial Price",
        definition: "Price before the movement along demand curve.",
        role: "First endpoint in midpoint price change.",
        units: "Currency per unit.",
        dataMap: "Observed market price at initial point.",
        examHint: "Elasticity uses percent changes, not dollar-point changes.",
        sources: {}
      },
      p2: {
        id: "p2",
        symbolLatex: "P_2",
        label: "New Price",
        definition: "Price after movement along demand curve.",
        role: "Second endpoint in midpoint price change.",
        units: "Currency per unit.",
        dataMap: "Observed market price at second point.",
        examHint: "Use midpoint denominator averages for both quantity and price.",
        sources: {}
      },
      epsilon_d: {
        id: "epsilon_d",
        symbolLatex: "\\varepsilon_D",
        label: "Demand Elasticity (Midpoint)",
        definition: "Percent quantity change divided by percent price change using midpoint denominators.",
        role: "Output of elasticity formula used for responsiveness and revenue logic.",
        units: "Unit-free ratio.",
        dataMap: "Derived from two observed price-quantity pairs.",
        examHint: "Interpret absolute value for elastic vs inelastic; sign is usually negative for demand.",
        sources: {}
      },
      x_t: {
        id: "x_t",
        symbolLatex: "X_t",
        label: "Ending Level",
        definition: "Final value of a variable at the end of period \\(t\\).",
        role: "Numerator in compound annual growth calculation.",
        units: "Same as \\(X_0\\).",
        dataMap: "Any macro variable level: GDP, productivity, population, etc.",
        examHint: "Use same unit basis and measurement concept for start and end values.",
        sources: {}
      },
      x_0: {
        id: "x_0",
        symbolLatex: "X_0",
        label: "Initial Level",
        definition: "Starting value of a variable.",
        role: "Denominator in CAGR calculation.",
        units: "Same as \\(X_t\\).",
        dataMap: "Baseline level in first period.",
        examHint: "Ensure \\(X_0 > 0\\) before applying log/ratio growth logic.",
        sources: {}
      },
      n_years: {
        id: "n_years",
        symbolLatex: "n",
        label: "Number of Periods",
        definition: "Count of years (or periods) between \\(X_0\\) and \\(X_t\\).",
        role: "Root index that annualizes total growth.",
        units: "Periods (typically years).",
        dataMap: "Difference in calendar periods between observations.",
        examHint: "For annualized growth, period count must match data frequency interpretation.",
        sources: {}
      },
      growth_rate: {
        id: "growth_rate",
        symbolLatex: "g",
        label: "Compound Growth Rate",
        definition: "Constant per-period growth rate consistent with observed start/end levels.",
        role: "Output of CAGR formula.",
        units: "Decimal or percent per period.",
        dataMap: "Derived indicator, often reported in percent.",
        examHint: "Report clearly whether answer is decimal (0.03) or percent (3%).",
        sources: {}
      }
    };

    const FORMULA_CATALOG = [
      {
        id: "gdp_identity",
        topic: "L04 National Accounts",
        title: "GDP Spending Identity",
        latex: "Y = C + I + G + NX",
        outputVarId: "y",
        variables: ["y", "c", "i", "g", "nx"],
        intuition: "Total output equals domestic and foreign final spending on domestic production. This is an accounting identity, not a behavioral equation.",
        examFocus: [
          "Keep signs explicit, especially when \\(NX\\) is negative.",
          "A change in one component moves \\(Y\\) one-for-one if others are fixed.",
          "Distinguish this identity from causal macro models."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["c", "i", "g", "nx"]);
          if (missing.length) return formulaMissingResult(missing);
          const result = values.c + values.i + values.g + values.nx;
          return formulaSuccess(
            "y",
            result,
            `Computed output: ${formatFormulaNumber(result)}.`,
            `<p>\\(Y = C + I + G + NX = ${formatFormulaNumber(values.c)} + ${formatFormulaNumber(values.i)} + ${formatFormulaNumber(values.g)} + ${formatFormulaNumber(values.nx)} = ${formatFormulaNumber(result)}\\).</p>`
          );
        }
      },
      {
        id: "net_exports_trade",
        topic: "L04 National Accounts",
        title: "Net Exports Definition",
        latex: "NX = X - M",
        outputVarId: "nx",
        variables: ["nx", "x", "m"],
        intuition: "Net exports compare domestic sales abroad to foreign sales at home.",
        examFocus: [
          "Trade deficit means \\(NX<0\\); trade surplus means \\(NX>0\\).",
          "Imports enter domestic spending components but are removed in \\(NX\\)."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["x", "m"]);
          if (missing.length) return formulaMissingResult(missing);
          const result = values.x - values.m;
          return formulaSuccess(
            "nx",
            result,
            `Computed net exports: ${formatFormulaNumber(result)}.`,
            `<p>\\(NX = X - M = ${formatFormulaNumber(values.x)} - ${formatFormulaNumber(values.m)} = ${formatFormulaNumber(result)}\\).</p>`
          );
        }
      },
      {
        id: "gdp_deflator_level",
        topic: "L04 National Accounts",
        title: "GDP Deflator Level",
        latex: "\\text{Deflator} = \\frac{\\text{Nominal GDP}}{\\text{Real GDP}} \\times 100",
        outputVarId: "deflator_t",
        variables: ["deflator_t", "nominal_gdp", "real_gdp"],
        intuition: "Deflator converts nominal output into a price index for domestically produced final output.",
        examFocus: [
          "Use the same period for nominal and real GDP values.",
          "Deflator growth, not level, is inflation."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["nominal_gdp", "real_gdp"]);
          if (missing.length) return formulaMissingResult(missing);
          if (values.real_gdp === 0) return formulaError("Real GDP cannot be zero in the deflator denominator.");
          const result = (values.nominal_gdp / values.real_gdp) * 100;
          return formulaSuccess(
            "deflator_t",
            result,
            `Computed GDP deflator index: ${formatFormulaNumber(result)}.`,
            `<p>\\(\\text{Deflator} = \\frac{${formatFormulaNumber(values.nominal_gdp)}}{${formatFormulaNumber(values.real_gdp)}}\\times100 = ${formatFormulaNumber(result)}\\).</p>`
          );
        }
      },
      {
        id: "gdp_deflator_inflation",
        topic: "L04 National Accounts",
        title: "GDP Inflation Rate",
        latex: "\\pi_t^{GDP} = \\frac{\\text{Def}_t - \\text{Def}_{t-1}}{\\text{Def}_{t-1}} \\times 100",
        outputVarId: "inflation_gdp",
        variables: ["inflation_gdp", "deflator_t", "deflator_t1"],
        intuition: "Inflation is a growth rate of a price index, so you compare current index level to prior index level.",
        examFocus: [
          "Denominator is previous-period index, not current.",
          "Express final answer in percent."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["deflator_t", "deflator_t1"]);
          if (missing.length) return formulaMissingResult(missing);
          if (values.deflator_t1 === 0) return formulaError("Previous deflator level cannot be zero.");
          const result = ((values.deflator_t - values.deflator_t1) / values.deflator_t1) * 100;
          return formulaSuccess(
            "inflation_gdp",
            result,
            `Computed GDP inflation: ${formatFormulaNumber(result)}%.`,
            `<p>\\(\\pi_t^{GDP} = \\frac{${formatFormulaNumber(values.deflator_t)} - ${formatFormulaNumber(values.deflator_t1)}}{${formatFormulaNumber(values.deflator_t1)}}\\times100 = ${formatFormulaNumber(result)}\\%\\).</p>`
          );
        }
      },
      {
        id: "private_saving",
        topic: "L05 Saving Decomposition",
        title: "Private Saving",
        latex: "S_p = Y - C - T",
        outputVarId: "sp",
        variables: ["sp", "y", "c", "t"],
        intuition: "Private saving is the portion of private income not used for consumption or net taxes.",
        examFocus: [
          "Keep tax sign consistent: \\(T\\) is net taxes.",
          "Useful bridge between household behavior and national saving."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["y", "c", "t"]);
          if (missing.length) return formulaMissingResult(missing);
          const result = values.y - values.c - values.t;
          return formulaSuccess(
            "sp",
            result,
            `Computed private saving: ${formatFormulaNumber(result)}.`,
            `<p>\\(S_p = Y - C - T = ${formatFormulaNumber(values.y)} - ${formatFormulaNumber(values.c)} - ${formatFormulaNumber(values.t)} = ${formatFormulaNumber(result)}\\).</p>`
          );
        }
      },
      {
        id: "public_saving",
        topic: "L05 Saving Decomposition",
        title: "Public Saving",
        latex: "S_g = T - G",
        outputVarId: "sg",
        variables: ["sg", "t", "g"],
        intuition: "Public saving is fiscal balance before borrowing from private/foreign sectors.",
        examFocus: [
          "Deficits imply negative public saving.",
          "Fiscal expansion can lower national saving if taxes are unchanged."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["t", "g"]);
          if (missing.length) return formulaMissingResult(missing);
          const result = values.t - values.g;
          return formulaSuccess(
            "sg",
            result,
            `Computed public saving: ${formatFormulaNumber(result)}.`,
            `<p>\\(S_g = T - G = ${formatFormulaNumber(values.t)} - ${formatFormulaNumber(values.g)} = ${formatFormulaNumber(result)}\\).</p>`
          );
        }
      },
      {
        id: "national_saving",
        topic: "L05 Saving Decomposition",
        title: "National Saving",
        latex: "S = Y - C - G",
        outputVarId: "s",
        variables: ["s", "y", "c", "g"],
        intuition: "National saving is domestic output left after private and public consumption spending.",
        examFocus: [
          "Mechanically links fiscal/consumption changes to saving.",
          "Used with \\(NX = S - I\\) to infer trade balance implications."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["y", "c", "g"]);
          if (missing.length) return formulaMissingResult(missing);
          const result = values.y - values.c - values.g;
          return formulaSuccess(
            "s",
            result,
            `Computed national saving: ${formatFormulaNumber(result)}.`,
            `<p>\\(S = Y - C - G = ${formatFormulaNumber(values.y)} - ${formatFormulaNumber(values.c)} - ${formatFormulaNumber(values.g)} = ${formatFormulaNumber(result)}\\).</p>`
          );
        }
      },
      {
        id: "saving_investment_external",
        topic: "L05 Saving and External Balance",
        title: "Saving-Investment Identity",
        latex: "NX = S - I",
        outputVarId: "nx",
        variables: ["nx", "s", "i"],
        intuition: "An economy with saving above investment is a net lender to the rest of the world (positive \\(NX\\)).",
        examFocus: [
          "Strong for causal reasoning when rates move \\(S\\) and \\(I\\) in opposite directions.",
          "Links domestic macro behavior to current account outcomes."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["s", "i"]);
          if (missing.length) return formulaMissingResult(missing);
          const result = values.s - values.i;
          return formulaSuccess(
            "nx",
            result,
            `Computed net exports from saving and investment: ${formatFormulaNumber(result)}.`,
            `<p>\\(NX = S - I = ${formatFormulaNumber(values.s)} - ${formatFormulaNumber(values.i)} = ${formatFormulaNumber(result)}\\).</p>`
          );
        }
      },
      {
        id: "labor_force_definition",
        topic: "L06 Labor Market",
        title: "Labor Force Definition",
        latex: "\\text{LF} = E + U",
        outputVarId: "lf",
        variables: ["lf", "e", "u"],
        intuition: "Labor force includes people employed or actively searching for jobs.",
        examFocus: [
          "People not searching are out of labor force.",
          "Needed before computing unemployment rate."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["e", "u"]);
          if (missing.length) return formulaMissingResult(missing);
          const result = values.e + values.u;
          return formulaSuccess(
            "lf",
            result,
            `Computed labor force: ${formatFormulaNumber(result)}.`,
            `<p>\\(LF = E + U = ${formatFormulaNumber(values.e)} + ${formatFormulaNumber(values.u)} = ${formatFormulaNumber(result)}\\).</p>`
          );
        }
      },
      {
        id: "unemployment_rate",
        topic: "L06 Labor Market",
        title: "Unemployment Rate",
        latex: "u = \\frac{U}{LF} \\times 100",
        outputVarId: "u_rate",
        variables: ["u_rate", "u", "lf"],
        intuition: "Unemployment rate is the unemployed share of labor force, not of population.",
        examFocus: [
          "Numerator and denominator must come from same labor-force concept.",
          "Rate can change from both \\(U\\) and \\(LF\\) movement."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["u", "lf"]);
          if (missing.length) return formulaMissingResult(missing);
          if (values.lf === 0) return formulaError("Labor force cannot be zero when computing unemployment rate.");
          const result = (values.u / values.lf) * 100;
          return formulaSuccess(
            "u_rate",
            result,
            `Computed unemployment rate: ${formatFormulaNumber(result)}%.`,
            `<p>\\(u = \\frac{U}{LF}\\times100 = \\frac{${formatFormulaNumber(values.u)}}{${formatFormulaNumber(values.lf)}}\\times100 = ${formatFormulaNumber(result)}\\%\\).</p>`
          );
        }
      },
      {
        id: "labor_force_participation_rate",
        topic: "L06 Labor Market",
        title: "Labor Force Participation Rate",
        latex: "\\text{LFPR} = \\frac{LF}{\\text{Adults}} \\times 100",
        outputVarId: "lfpr",
        variables: ["lfpr", "lf", "adults"],
        intuition: "Participation captures willingness/ability of adults to be active in labor market.",
        examFocus: [
          "Adult population denominator is required.",
          "LFPR can move independently from unemployment rate."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["lf", "adults"]);
          if (missing.length) return formulaMissingResult(missing);
          if (values.adults === 0) return formulaError("Adult population cannot be zero.");
          const result = (values.lf / values.adults) * 100;
          return formulaSuccess(
            "lfpr",
            result,
            `Computed labor force participation rate: ${formatFormulaNumber(result)}%.`,
            `<p>\\(LFPR = \\frac{LF}{Adults}\\times100 = \\frac{${formatFormulaNumber(values.lf)}}{${formatFormulaNumber(values.adults)}}\\times100 = ${formatFormulaNumber(result)}\\%\\).</p>`
          );
        }
      },
      {
        id: "employment_population_ratio",
        topic: "L06 Labor Market",
        title: "Employment-Population Ratio",
        latex: "\\text{EPOP} = \\frac{E}{\\text{Adults}} \\times 100",
        outputVarId: "epop",
        variables: ["epop", "e", "adults"],
        intuition: "EPOP measures employment utilization relative to adult population base.",
        examFocus: [
          "Directly interpretable as share of adults employed.",
          "Combines participation and employment outcomes."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["e", "adults"]);
          if (missing.length) return formulaMissingResult(missing);
          if (values.adults === 0) return formulaError("Adult population cannot be zero.");
          const result = (values.e / values.adults) * 100;
          return formulaSuccess(
            "epop",
            result,
            `Computed employment-population ratio: ${formatFormulaNumber(result)}%.`,
            `<p>\\(EPOP = \\frac{E}{Adults}\\times100 = \\frac{${formatFormulaNumber(values.e)}}{${formatFormulaNumber(values.adults)}}\\times100 = ${formatFormulaNumber(result)}\\%\\).</p>`
          );
        }
      },
      {
        id: "real_rate_approx",
        topic: "L05 Intertemporal Choice",
        title: "Real Interest Approximation",
        latex: "r \\approx i - \\pi^e",
        outputVarId: "r_real",
        variables: ["r_real", "i_nominal", "pi_expected"],
        intuition: "Approximate real return by netting out expected inflation from nominal return.",
        examFocus: [
          "Maintain sign convention when inflation expectations are negative.",
          "Good first-pass approximation in intro macro."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["i_nominal", "pi_expected"]);
          if (missing.length) return formulaMissingResult(missing);
          const result = values.i_nominal - values.pi_expected;
          return formulaSuccess(
            "r_real",
            result,
            `Computed real interest rate: ${formatFormulaNumber(result)}%.`,
            `<p>\\(r \\approx i - \\pi^e = ${formatFormulaNumber(values.i_nominal)} - ${formatFormulaNumber(values.pi_expected)} = ${formatFormulaNumber(result)}\\%\\).</p>`
          );
        }
      },
      {
        id: "midpoint_elasticity",
        topic: "L02 Elasticity",
        title: "Midpoint Demand Elasticity",
        latex: "\\varepsilon_D=\\frac{\\frac{Q_2-Q_1}{(Q_2+Q_1)/2}}{\\frac{P_2-P_1}{(P_2+P_1)/2}}",
        outputVarId: "epsilon_d",
        variables: ["epsilon_d", "q1", "q2", "p1", "p2"],
        intuition: "Midpoint method gives symmetric percent changes and avoids base-choice bias between endpoints.",
        examFocus: [
          "Use average denominator for both quantity and price.",
          "Interpret absolute value for elastic/inelastic classification."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["q1", "q2", "p1", "p2"]);
          if (missing.length) return formulaMissingResult(missing);
          const qAvg = (values.q2 + values.q1) / 2;
          const pAvg = (values.p2 + values.p1) / 2;
          if (qAvg === 0 || pAvg === 0) {
            return formulaError("Midpoint denominator cannot be zero for quantity or price averages.");
          }
          const pctQ = (values.q2 - values.q1) / qAvg;
          const pctP = (values.p2 - values.p1) / pAvg;
          if (pctP === 0) return formulaError("Price percent change is zero; elasticity is undefined.");
          const result = pctQ / pctP;
          return formulaSuccess(
            "epsilon_d",
            result,
            `Computed demand elasticity: ${formatFormulaNumber(result)}.`,
            `<p>\\(\\%\\Delta Q = \\frac{${formatFormulaNumber(values.q2)}-${formatFormulaNumber(values.q1)}}{(${formatFormulaNumber(values.q2)}+${formatFormulaNumber(values.q1)})/2} = ${formatFormulaNumber(pctQ)}\\)</p><p>\\(\\%\\Delta P = \\frac{${formatFormulaNumber(values.p2)}-${formatFormulaNumber(values.p1)}}{(${formatFormulaNumber(values.p2)}+${formatFormulaNumber(values.p1)})/2} = ${formatFormulaNumber(pctP)}\\)</p><p>\\(\\varepsilon_D = \\frac{\\%\\Delta Q}{\\%\\Delta P} = ${formatFormulaNumber(result)}\\)</p>`
          );
        }
      },
      {
        id: "compound_growth",
        topic: "L07 Growth",
        title: "Compound Annual Growth Rate",
        latex: "g=\\left(\\frac{X_t}{X_0}\\right)^{\\frac{1}{n}}-1",
        outputVarId: "growth_rate",
        variables: ["growth_rate", "x_t", "x_0", "n_years"],
        intuition: "CAGR answers: what constant per-period rate would transform \\(X_0\\) into \\(X_t\\) over \\(n\\) periods?",
        examFocus: [
          "Ensure \\(X_0 > 0\\) and \\(n > 0\\).",
          "Report both decimal and percent when presenting final answer."
        ],
        compute(values) {
          const missing = missingFormulaInputs(values, ["x_t", "x_0", "n_years"]);
          if (missing.length) return formulaMissingResult(missing);
          if (values.x_0 <= 0) return formulaError("Initial level \\(X_0\\) must be positive.");
          if (values.n_years <= 0) return formulaError("Number of periods \\(n\\) must be positive.");
          const result = Math.pow(values.x_t / values.x_0, 1 / values.n_years) - 1;
          return formulaSuccess(
            "growth_rate",
            result,
            `Computed growth rate: ${formatFormulaNumber(result * 100)}% per period.`,
            `<p>\\(g = \\left(\\frac{${formatFormulaNumber(values.x_t)}}{${formatFormulaNumber(values.x_0)}}\\right)^{1/${formatFormulaNumber(values.n_years)}} - 1 = ${formatFormulaNumber(result)}\\)</p><p>Percent form: \\(${formatFormulaNumber(result * 100)}\\%\\) per period.</p>`
          );
        }
      }
    ];

    const STORAGE = {
      checks: "econ205_midterm1_checks_v3",
      mastered: "econ205_midterm1_mastered_v3",
      minutes: "econ205_midterm1_timer_mins_v3",
      cards: "econ205_midterm1_card_stats_v1",
      formulaLab: "econ205_midterm1_formula_lab_v1",
      formulaApi: "econ205_midterm1_formula_api_v1",
      marketLab: "econ205_midterm1_market_lab_v1",
      macroLink: "econ205_midterm1_macro_link_v1",
      arenaStats: "econ205_midterm1_arena_stats_v1",
      arenaPrefs: "econ205_midterm1_arena_prefs_v1",
      intuitionState: "econ205_midterm1_intuition_state_v1",
      questState: "econ205_midterm1_quest_state_v1",
      authSession: "econ205_midterm1_auth_session_v1",
      idleMinutes: "econ205_midterm1_idle_minutes_v1"
    };

    const AUTH_USERS = {
      hanna: { name: "Hanna Nio", role: "student" },
      josh: { name: "Josh", role: "student" },
      ian: { name: "Ian Helfrich", role: "admin" }
    };

    const AUTH_ALIASES = {
      "hanna": "hanna",
      "hanna nio": "hanna",
      "josh": "josh",
      "ian": "ian",
      "ian helfrich": "ian"
    };

    const AUTH_THROTTLE = {
      maxAttempts: 4,
      lockMs: 20000
    };

    const SESSION_SECURITY = {
      defaultIdleMinutes: 30,
      minIdleMinutes: 5,
      maxIdleMinutes: 180,
      warningMs: 60 * 1000,
      pollMs: 1000,
      warningPulseMs: 10000
    };

    const flashQ = document.getElementById("flashQ");
    const flashA = document.getElementById("flashA");
    const flashMeta = document.getElementById("flashMeta");
    const flashMasteredMeta = document.getElementById("flashMasteredMeta");
    const flashAdaptiveMeta = document.getElementById("flashAdaptiveMeta");
    const seenCount = document.getElementById("seenCount");
    const remainingCount = document.getElementById("remainingCount");
    const recallScore = document.getElementById("recallScore");
    const flashModeMeta = document.getElementById("flashModeMeta");
    const flashAttemptMeta = document.getElementById("flashAttemptMeta");
    const flashModeHelp = document.getElementById("flashModeHelp");
    const recallOptions = document.getElementById("recallOptions");
    const submitAnswerBtn = document.getElementById("submitAnswerBtn");
    const clearAnswerBtn = document.getElementById("clearAnswerBtn");
    const recallFeedback = document.getElementById("recallFeedback");
    const heroRecallCount = document.getElementById("heroRecallCount");
    const newCardBtn = document.getElementById("newCardBtn");
    const showAnswerBtn = document.getElementById("showAnswerBtn");
    const markMasteredBtn = document.getElementById("markMasteredBtn");
    const clearMasteredBtn = document.getElementById("clearMasteredBtn");
    const rateAgainBtn = document.getElementById("rateAgainBtn");
    const rateHardBtn = document.getElementById("rateHardBtn");
    const rateGoodBtn = document.getElementById("rateGoodBtn");
    const rateEasyBtn = document.getElementById("rateEasyBtn");
    const checklist = document.getElementById("checklist");
    const progressPct = document.getElementById("progressPct");
    const progressText = document.getElementById("progressText");
    const progressFill = document.getElementById("progressFill");
    const resetChecklistBtn = document.getElementById("resetChecklistBtn");
    const resourceGrid = document.getElementById("resourceGrid");
    const resourceFilter = document.getElementById("resourceFilter");
    const resourceCount = document.getElementById("resourceCount");
    const authGate = document.getElementById("authGate");
    const authNameInput = document.getElementById("authNameInput");
    const authUnlockBtn = document.getElementById("authUnlockBtn");
    const authMessage = document.getElementById("authMessage");
    const authBadge = document.getElementById("authBadge");
    const sessionGuardChip = document.getElementById("sessionGuardChip");
    const printBtn = document.getElementById("printBtn");
    const resetAllBtn = document.getElementById("resetAllBtn");
    const switchUserBtn = document.getElementById("switchUserBtn");
    const commandBtn = document.getElementById("commandBtn");
    const adminDiagnosticsBtn = document.getElementById("adminDiagnosticsBtn");
    const liveStatus = document.getElementById("liveStatus");
    const commandShell = document.getElementById("commandShell");
    const commandBackdrop = document.getElementById("commandBackdrop");
    const commandInput = document.getElementById("commandInput");
    const commandList = document.getElementById("commandList");
    const diagnosticsChip = document.getElementById("diagnosticsChip");
    const hero = document.getElementById("hero");
    const parallaxLayers = [...document.querySelectorAll("[data-parallax]")];
    const revealTargets = [...document.querySelectorAll(".hero, .section, footer")];

    const timerDisplay = document.getElementById("timerDisplay");
    const timerMinutes = document.getElementById("timerMinutes");
    const timerStatus = document.getElementById("timerStatus");
    const startTimerBtn = document.getElementById("startTimerBtn");
    const pauseTimerBtn = document.getElementById("pauseTimerBtn");
    const resetTimerBtn = document.getElementById("resetTimerBtn");

    const arenaType = document.getElementById("arenaType");
    const arenaDifficulty = document.getElementById("arenaDifficulty");
    const arenaGenerateBtn = document.getElementById("arenaGenerateBtn");
    const arenaCheckBtn = document.getElementById("arenaCheckBtn");
    const arenaRevealBtn = document.getElementById("arenaRevealBtn");
    const arenaNextBtn = document.getElementById("arenaNextBtn");
    const arenaResetBtn = document.getElementById("arenaResetBtn");
    const arenaPrompt = document.getElementById("arenaPrompt");
    const arenaAnswer = document.getElementById("arenaAnswer");
    const arenaFeedback = document.getElementById("arenaFeedback");
    const arenaSolution = document.getElementById("arenaSolution");
    const arenaTimer = document.getElementById("arenaTimer");
    const arenaSolved = document.getElementById("arenaSolved");
    const arenaCorrect = document.getElementById("arenaCorrect");
    const arenaAccuracy = document.getElementById("arenaAccuracy");
    const arenaStreak = document.getElementById("arenaStreak");
    const arenaBestStreak = document.getElementById("arenaBestStreak");
    const arenaLastType = document.getElementById("arenaLastType");
    const adminRunDiagnosticsBtn = document.getElementById("adminRunDiagnosticsBtn");
    const adminExportStateBtn = document.getElementById("adminExportStateBtn");
    const adminHardResetBtn = document.getElementById("adminHardResetBtn");
    const adminModeMeta = document.getElementById("adminModeMeta");
    const adminIdleMinutes = document.getElementById("adminIdleMinutes");
    const adminSaveIdleBtn = document.getElementById("adminSaveIdleBtn");
    const adminLockNowBtn = document.getElementById("adminLockNowBtn");
    const adminSecurityMeta = document.getElementById("adminSecurityMeta");

    const labDemandShift = document.getElementById("labDemandShift");
    const labSupplyShift = document.getElementById("labSupplyShift");
    const labPolicyType = document.getElementById("labPolicyType");
    const labControlPrice = document.getElementById("labControlPrice");
    const labDemandShiftVal = document.getElementById("labDemandShiftVal");
    const labSupplyShiftVal = document.getElementById("labSupplyShiftVal");
    const labControlPriceVal = document.getElementById("labControlPriceVal");
    const labEqPrice = document.getElementById("labEqPrice");
    const labEqQty = document.getElementById("labEqQty");
    const labPolicyStatus = document.getElementById("labPolicyStatus");
    const labGap = document.getElementById("labGap");
    const labNarrative = document.getElementById("labNarrative");
    const labPresetBtns = [...document.querySelectorAll(".lab-preset")];

    const macroLayoutMode = document.getElementById("macroLayoutMode");
    const macroPairMode = document.getElementById("macroPairMode");
    const macroDemandShift = document.getElementById("macroDemandShift");
    const macroSupplyShift = document.getElementById("macroSupplyShift");
    const macroMoneySupplyShift = document.getElementById("macroMoneySupplyShift");
    const macroMoneyDemandShift = document.getElementById("macroMoneyDemandShift");
    const macroSavingShift = document.getElementById("macroSavingShift");
    const macroInvestmentShift = document.getElementById("macroInvestmentShift");
    const macroExpectedInflation = document.getElementById("macroExpectedInflation");
    const macroDemandShiftVal = document.getElementById("macroDemandShiftVal");
    const macroSupplyShiftVal = document.getElementById("macroSupplyShiftVal");
    const macroMoneySupplyShiftVal = document.getElementById("macroMoneySupplyShiftVal");
    const macroMoneyDemandShiftVal = document.getElementById("macroMoneyDemandShiftVal");
    const macroSavingShiftVal = document.getElementById("macroSavingShiftVal");
    const macroInvestmentShiftVal = document.getElementById("macroInvestmentShiftVal");
    const macroExpectedInflationVal = document.getElementById("macroExpectedInflationVal");
    const macroOutputLevel = document.getElementById("macroOutputLevel");
    const macroPriceLevel = document.getElementById("macroPriceLevel");
    const macroNominalRate = document.getElementById("macroNominalRate");
    const macroRealRate = document.getElementById("macroRealRate");
    const macroUnemploymentRate = document.getElementById("macroUnemploymentRate");
    const macroInflationRate = document.getElementById("macroInflationRate");
    const macroRateGap = document.getElementById("macroRateGap");
    const macroRegimeTag = document.getElementById("macroRegimeTag");
    const macroNarrative = document.getElementById("macroNarrative");
    const macroChartGrid = document.getElementById("macroChartGrid");
    const macroParticleCanvas = document.getElementById("macroParticleCanvas");
    const macroChartCards = [...document.querySelectorAll(".macro-chart-card")];
    const macroPresetBtns = [...document.querySelectorAll(".macro-preset")];

    const macroAdasGrid = document.getElementById("macroAdasGrid");
    const macroAdasBaseAd = document.getElementById("macroAdasBaseAd");
    const macroAdasBaseSras = document.getElementById("macroAdasBaseSras");
    const macroAdPath = document.getElementById("macroAdPath");
    const macroSrasPath = document.getElementById("macroSrasPath");
    const macroAdasBaseLras = document.getElementById("macroAdasBaseLras");
    const macroAdasLras = document.getElementById("macroAdasLras");
    const macroAdasEqPoint = document.getElementById("macroAdasEqPoint");
    const macroAdasEqLabel = document.getElementById("macroAdasEqLabel");
    const macroAdasTag = document.getElementById("macroAdasTag");

    const macroMoneyGrid = document.getElementById("macroMoneyGrid");
    const macroMoneyBaseSupply = document.getElementById("macroMoneyBaseSupply");
    const macroMoneyBaseDemand = document.getElementById("macroMoneyBaseDemand");
    const macroMoneySupply = document.getElementById("macroMoneySupply");
    const macroMoneyDemand = document.getElementById("macroMoneyDemand");
    const macroMoneyEqPoint = document.getElementById("macroMoneyEqPoint");
    const macroMoneyEqLabel = document.getElementById("macroMoneyEqLabel");
    const macroMoneyTag = document.getElementById("macroMoneyTag");

    const macroLfGrid = document.getElementById("macroLfGrid");
    const macroLfBaseSupply = document.getElementById("macroLfBaseSupply");
    const macroLfBaseDemand = document.getElementById("macroLfBaseDemand");
    const macroLfSupply = document.getElementById("macroLfSupply");
    const macroLfDemand = document.getElementById("macroLfDemand");
    const macroLfEqPoint = document.getElementById("macroLfEqPoint");
    const macroLfEqLabel = document.getElementById("macroLfEqLabel");
    const macroLfTag = document.getElementById("macroLfTag");

    const macroPcGrid = document.getElementById("macroPcGrid");
    const macroPcBasePath = document.getElementById("macroPcBasePath");
    const macroPcPath = document.getElementById("macroPcPath");
    const macroPcPoint = document.getElementById("macroPcPoint");
    const macroPcLabel = document.getElementById("macroPcLabel");
    const macroPcTag = document.getElementById("macroPcTag");

    const marketSvg = document.getElementById("marketSvg");
    const marketGrid = document.getElementById("marketGrid");
    const marketDemandPath = document.getElementById("marketDemandPath");
    const marketSupplyPath = document.getElementById("marketSupplyPath");
    const marketDemandLabel = document.getElementById("marketDemandLabel");
    const marketSupplyLabel = document.getElementById("marketSupplyLabel");
    const marketEqPoint = document.getElementById("marketEqPoint");
    const marketEqLabel = document.getElementById("marketEqLabel");
    const marketEqPriceLine = document.getElementById("marketEqPriceLine");
    const marketEqQtyLine = document.getElementById("marketEqQtyLine");
    const marketPolicyLine = document.getElementById("marketPolicyLine");
    const marketQdLine = document.getElementById("marketQdLine");
    const marketQsLine = document.getElementById("marketQsLine");
    const marketPcLabel = document.getElementById("marketPcLabel");
    const marketQdLabel = document.getElementById("marketQdLabel");
    const marketQsLabel = document.getElementById("marketQsLabel");

    const intuitionScenarioCards = document.getElementById("intuitionScenarioCards");
    const intuitionStatsMeta = document.getElementById("intuitionStatsMeta");
    const intuitionScenarioTitle = document.getElementById("intuitionScenarioTitle");
    const intuitionScenarioTag = document.getElementById("intuitionScenarioTag");
    const intuitionShock = document.getElementById("intuitionShock");
    const intuitionTagFilter = document.getElementById("intuitionTagFilter");
    const intuitionConfidence = document.getElementById("intuitionConfidence");
    const intuitionCoachMeta = document.getElementById("intuitionCoachMeta");
    const intuitionVars = document.getElementById("intuitionVars");
    const intuitionGradeBtn = document.getElementById("intuitionGradeBtn");
    const intuitionHintBtn = document.getElementById("intuitionHintBtn");
    const intuitionRevealBtn = document.getElementById("intuitionRevealBtn");
    const intuitionNextBtn = document.getElementById("intuitionNextBtn");
    const intuitionFeedback = document.getElementById("intuitionFeedback");
    const intuitionDebrief = document.getElementById("intuitionDebrief");
    const intuitionChain = document.getElementById("intuitionChain");

    const masteryRing = document.getElementById("masteryRing");
    const masteryScore = document.getElementById("masteryScore");
    const missionRecallScore = document.getElementById("missionRecallScore");
    const missionArenaScore = document.getElementById("missionArenaScore");
    const missionIntuitionScore = document.getElementById("missionIntuitionScore");
    const missionChecklistScore = document.getElementById("missionChecklistScore");
    const missionAlert = document.getElementById("missionAlert");
    const missionHeatmap = document.getElementById("missionHeatmap");
    const missionWeaknessMeta = document.getElementById("missionWeaknessMeta");
    const refreshMissionBtn = document.getElementById("refreshMissionBtn");
    const questIntensity = document.getElementById("questIntensity");
    const generateQuestBtn = document.getElementById("generateQuestBtn");
    const runNextQuestBtn = document.getElementById("runNextQuestBtn");
    const clearQuestBtn = document.getElementById("clearQuestBtn");
    const questMeta = document.getElementById("questMeta");
    const questList = document.getElementById("questList");
    const questProgressPct = document.getElementById("questProgressPct");
    const questProgressText = document.getElementById("questProgressText");
    const questProgressFill = document.getElementById("questProgressFill");

    const formulaCatalog = document.getElementById("formulaCatalog");
    const formulaActiveTitle = document.getElementById("formulaActiveTitle");
    const formulaActiveTopic = document.getElementById("formulaActiveTopic");
    const formulaActiveLatex = document.getElementById("formulaActiveLatex");
    const formulaIntuition = document.getElementById("formulaIntuition");
    const formulaExamFocus = document.getElementById("formulaExamFocus");
    const formulaVariableButtons = document.getElementById("formulaVariableButtons");
    const formulaVariableTitle = document.getElementById("formulaVariableTitle");
    const formulaVariableSymbol = document.getElementById("formulaVariableSymbol");
    const formulaVariableDefinition = document.getElementById("formulaVariableDefinition");
    const formulaVariableRole = document.getElementById("formulaVariableRole");
    const formulaVariableUnits = document.getElementById("formulaVariableUnits");
    const formulaVariableDataMap = document.getElementById("formulaVariableDataMap");
    const formulaVariableExamHint = document.getElementById("formulaVariableExamHint");
    const formulaVariableSelect = document.getElementById("formulaVariableSelect");
    const formulaSourceSelect = document.getElementById("formulaSourceSelect");
    const formulaSeriesField = document.getElementById("formulaSeriesField");
    const formulaSeriesInput = document.getElementById("formulaSeriesInput");
    const formulaManualField = document.getElementById("formulaManualField");
    const formulaManualInput = document.getElementById("formulaManualInput");
    const formulaSaveBindingBtn = document.getElementById("formulaSaveBindingBtn");
    const formulaFetchBtn = document.getElementById("formulaFetchBtn");
    const formulaApplyManualBtn = document.getElementById("formulaApplyManualBtn");
    const fredApiKeyInput = document.getElementById("fredApiKeyInput");
    const blsApiKeyInput = document.getElementById("blsApiKeyInput");
    const formulaSaveKeysBtn = document.getElementById("formulaSaveKeysBtn");
    const formulaDataMeta = document.getElementById("formulaDataMeta");
    const formulaBindingsTable = document.getElementById("formulaBindingsTable");
    const formulaComputeBtn = document.getElementById("formulaComputeBtn");
    const formulaResetBtn = document.getElementById("formulaResetBtn");
    const formulaComputeResult = document.getElementById("formulaComputeResult");
    const formulaComputeSteps = document.getElementById("formulaComputeSteps");

    let currentIdx = null;
    let recallSubmitted = false;
    let recallLastCorrect = false;
    let timerSeconds = 75 * 60;
    let timerId = null;

    const LAB_MODEL = {
      baseDemand: 130,
      baseSupply: 25,
      demandSlope: 2.2,
      supplySlope: 1.8
    };

    const LAB_CHART = {
      width: 700,
      height: 420,
      marginLeft: 66,
      marginRight: 26,
      marginTop: 24,
      marginBottom: 56,
      pMax: 50,
      qMax: 190
    };

    const LAB_DEFAULT_STATE = {
      demandShift: 0,
      supplyShift: 0,
      policy: "none",
      controlPrice: 22
    };

    let marketLabState = { ...LAB_DEFAULT_STATE };

    const MACRO_LINK_DEFAULT_STATE = {
      demandShift: 0,
      supplyShift: 0,
      moneySupplyShift: 0,
      moneyDemandShift: 0,
      savingShift: 0,
      investmentShift: 0,
      expectedInflation: 2,
      layoutMode: "2x2",
      pairMode: "adas_money"
    };

    const MACRO_INPUT_NUMERIC_KEYS = [
      "demandShift",
      "supplyShift",
      "moneySupplyShift",
      "moneyDemandShift",
      "savingShift",
      "investmentShift",
      "expectedInflation"
    ];

    const MACRO_LINK_LAYOUTS = {
      "2x2": ["adas", "money", "loanable", "phillips"],
      adas_money: ["adas", "money"],
      adas_loanable: ["adas", "loanable"],
      money_loanable: ["money", "loanable"],
      adas_phillips: ["adas", "phillips"],
      money_phillips: ["money", "phillips"],
      loanable_phillips: ["loanable", "phillips"]
    };

    const MACRO_CHART = {
      width: 640,
      height: 360,
      marginLeft: 58,
      marginRight: 24,
      marginTop: 24,
      marginBottom: 46
    };

    const MACRO_AXIS = {
      adasY: { min: 60, max: 140 },
      adasP: { min: 50, max: 120 },
      moneyQ: { min: 70, max: 170 },
      moneyI: { min: 0, max: 14 },
      lfQ: { min: 70, max: 170 },
      lfR: { min: 0, max: 12 },
      pcU: { min: 2, max: 11 },
      pcPi: { min: -1, max: 10 }
    };

    const MACRO_ANIMATION = {
      minMs: 280,
      maxMs: 760,
      baselineMs: 320,
      particleThreshold: 8,
      emphasisThreshold: 20
    };

    let macroLinkState = { ...MACRO_LINK_DEFAULT_STATE };
    let macroLastInputState = { ...MACRO_LINK_DEFAULT_STATE };
    let macroRenderedState = null;
    let macroTransitionFrame = null;
    let macroChartFlashTimer = null;
    let macroParticleCtx = null;
    let macroParticles = [];
    let macroParticleFrame = null;
    let macroParticleLastTs = 0;

    const ARENA_TYPES = ["gdp", "deflator", "labor", "saving", "real_rate", "elasticity"];
    const ARENA_TYPE_LABELS = {
      gdp: "GDP spending",
      deflator: "Deflator inflation",
      labor: "Unemployment rate",
      saving: "Saving and net exports",
      real_rate: "Real interest",
      elasticity: "Elasticity midpoint"
    };

    function defaultArenaByType() {
      return ARENA_TYPES.reduce((acc, type) => {
        acc[type] = { solved: 0, correct: 0 };
        return acc;
      }, {});
    }

    function defaultArenaStats() {
      return {
        solved: 0,
        correct: 0,
        streak: 0,
        bestStreak: 0,
        lastType: "-",
        byType: defaultArenaByType()
      };
    }

    let arenaStats = defaultArenaStats();
    let arenaChallenge = null;
    let arenaSeconds = 120;
    let arenaTimerId = null;
    let commandItems = [];
    let filteredCommandItems = [];
    let commandActiveIndex = 0;
    let commandOpen = false;
    let commandReturnFocus = null;
    let activeAuth = null;
    let authFailedAttempts = 0;
    let authLockedUntil = 0;
    let authCooldownId = null;
    let lastActivityTs = Date.now();
    let lastIdleWarningTs = 0;
    let idleMonitorId = null;
    let sessionIdleMinutes = SESSION_SECURITY.defaultIdleMinutes;
    let intuitionState = null;
    let activeIntuitionScenarioId = "";
    let intuitionGuesses = {};
    let intuitionHintStep = 0;
    let activeIntuitionTagFilter = "all";
    let questState = null;
    let formulaLabState = null;
    let formulaApiState = null;
    let formulaFetchInFlight = false;

    function safeRead(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return fallback;
        return JSON.parse(raw);
      } catch {
        return fallback;
      }
    }

    function safeWrite(key, value) {
      try {
        localStorage.setItem(key, JSON.stringify(value));
      } catch {
        // Ignore storage write failures.
      }
    }

    function normalizeName(value) {
      return String(value || "")
        .trim()
        .toLowerCase()
        .normalize("NFKD")
        .replace(/[^\w\s]/g, " ")
        .replace(/^(dr|doctor)\s+/, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    function resolveAuthorizedUser(value) {
      const normalized = normalizeName(value);
      if (!normalized) return null;
      const key = AUTH_ALIASES[normalized];
      return key ? AUTH_USERS[key] : null;
    }

    function roleLabel(role) {
      return role === "admin" ? "Admin" : "Student";
    }

    function setAuthMessage(message, tone = "") {
      if (!authMessage) return;
      authMessage.textContent = message;
      authMessage.className = `auth-message${tone ? ` ${tone}` : ""}`;
    }

    function sanitizeIdleMinutes(value) {
      const n = Number.parseInt(value, 10);
      if (!Number.isFinite(n)) return SESSION_SECURITY.defaultIdleMinutes;
      return clamp(n, SESSION_SECURITY.minIdleMinutes, SESSION_SECURITY.maxIdleMinutes);
    }

    function loadIdleMinutesPolicy() {
      const stored = safeRead(STORAGE.idleMinutes, SESSION_SECURITY.defaultIdleMinutes);
      sessionIdleMinutes = sanitizeIdleMinutes(stored);
      if (adminIdleMinutes) adminIdleMinutes.value = String(sessionIdleMinutes);
    }

    function persistIdleMinutesPolicy(value) {
      sessionIdleMinutes = sanitizeIdleMinutes(value);
      safeWrite(STORAGE.idleMinutes, sessionIdleMinutes);
      if (adminIdleMinutes) adminIdleMinutes.value = String(sessionIdleMinutes);
    }

    function getIdleLockMs() {
      return sessionIdleMinutes * 60 * 1000;
    }

    function formatClock(totalSeconds) {
      const secs = Math.max(0, totalSeconds | 0);
      const minutesPart = Math.floor(secs / 60);
      const secondsPart = secs % 60;
      return `${String(minutesPart).padStart(2, "0")}:${String(secondsPart).padStart(2, "0")}`;
    }

    function updateSessionSecurityUI(remainingMs = null) {
      const policyText = `Idle lock: ${sessionIdleMinutes} minute${sessionIdleMinutes === 1 ? "" : "s"}.`;
      if (adminSecurityMeta) {
        adminSecurityMeta.textContent = `${policyText} Warning in final ${Math.round(SESSION_SECURITY.warningMs / 1000)}s.`;
      }
      if (!sessionGuardChip) return;
      if (!activeAuth || document.body.classList.contains("auth-locked")) {
        sessionGuardChip.textContent = "Session Guard: Locked";
        sessionGuardChip.classList.remove("warn", "danger");
        return;
      }
      const msLeft = Number.isFinite(remainingMs)
        ? Math.max(0, remainingMs)
        : Math.max(0, getIdleLockMs() - (Date.now() - lastActivityTs));
      const secondsLeft = Math.ceil(msLeft / 1000);
      sessionGuardChip.textContent = `Auto-lock ${formatClock(secondsLeft)}`;
      sessionGuardChip.classList.remove("warn", "danger");
      if (msLeft <= 15000) {
        sessionGuardChip.classList.add("danger");
      } else if (msLeft <= SESSION_SECURITY.warningMs) {
        sessionGuardChip.classList.add("warn");
      }
    }

    function clearAuthCooldownTimer() {
      if (!authCooldownId) return;
      clearInterval(authCooldownId);
      authCooldownId = null;
    }

    function clearSessionWarning() {
      lastIdleWarningTs = 0;
      if (!liveStatus) return;
      if (liveStatus.textContent.startsWith("Security: session locks in ")) {
        liveStatus.textContent = "";
      }
    }

    function markSessionActivity(force = false) {
      if (!activeAuth || document.body.classList.contains("auth-locked")) return;
      const now = Date.now();
      if (!force && now - lastActivityTs < 600) return;
      lastActivityTs = now;
      clearSessionWarning();
      updateSessionSecurityUI(getIdleLockMs());
    }

    function lockSessionNow(message = "Session locked.") {
      try {
        localStorage.removeItem(STORAGE.authSession);
      } catch {
        // Ignore storage failures.
      }
      lockAccess(message);
      showStatus("Session locked. Re-enter authorized name.");
    }

    function resetAuthThrottle() {
      authFailedAttempts = 0;
      authLockedUntil = 0;
      clearAuthCooldownTimer();
    }

    function setAuthLockedState(locked, message = "") {
      if (authUnlockBtn) authUnlockBtn.disabled = locked;
      if (authNameInput) authNameInput.disabled = locked;
      if (!locked) {
        resetAuthThrottle();
        if (message) setAuthMessage(message);
        return;
      }
      setAuthMessage(message, "error");
      clearAuthCooldownTimer();
      authCooldownId = setInterval(() => {
        const remainingMs = authLockedUntil - Date.now();
        if (remainingMs <= 0) {
          clearAuthCooldownTimer();
          setAuthLockedState(false, "You can try again.");
          return;
        }
        const remainingSeconds = Math.ceil(remainingMs / 1000);
        setAuthMessage(`Too many attempts. Try again in ${remainingSeconds}s.`, "error");
      }, 250);
    }

    function isAuthTemporarilyLocked() {
      const now = Date.now();
      if (!authLockedUntil) return false;
      if (authLockedUntil <= now) {
        resetAuthThrottle();
        return false;
      }
      setAuthLockedState(true, `Too many attempts. Try again in ${Math.ceil((authLockedUntil - now) / 1000)}s.`);
      return true;
    }

    function lockAccess(message = "Access is name-gated for current enrolled use.") {
      activeAuth = null;
      resetAuthThrottle();
      clearSessionWarning();
      document.body.classList.add("auth-locked");
      document.body.dataset.role = "locked";
      if (authGate) authGate.classList.remove("hidden");
      if (authBadge) authBadge.textContent = "Locked";
      if (authNameInput) {
        authNameInput.disabled = false;
        authNameInput.value = "";
        authNameInput.focus();
      }
      if (authUnlockBtn) authUnlockBtn.disabled = false;
      if (adminModeMeta) adminModeMeta.textContent = "Admin mode unavailable.";
      closeCommandPalette();
      setAuthMessage(message);
      updateSessionSecurityUI();
    }

    function applyAccess(user) {
      activeAuth = user;
      setAuthLockedState(false);
      lastActivityTs = Date.now();
      clearSessionWarning();
      document.body.classList.remove("auth-locked");
      document.body.dataset.role = user.role;
      if (authGate) authGate.classList.add("hidden");
      if (authBadge) authBadge.textContent = `${user.name}  ${roleLabel(user.role)}`;
      if (adminModeMeta) {
        adminModeMeta.textContent = user.role === "admin"
          ? `Admin mode active for ${user.name}.`
          : "Student mode active.";
      }
      setAuthMessage("");
      updateSessionSecurityUI(getIdleLockMs());
    }

    function unlockByName() {
      if (!authNameInput) return;
      if (isAuthTemporarilyLocked()) return;
      const normalized = normalizeName(authNameInput.value);
      if (!normalized) {
        setAuthMessage("Enter your authorized name.", "error");
        return;
      }
      const user = resolveAuthorizedUser(normalized);
      if (!user) {
        authFailedAttempts += 1;
        const remaining = Math.max(0, AUTH_THROTTLE.maxAttempts - authFailedAttempts);
        if (remaining === 0) {
          authLockedUntil = Date.now() + AUTH_THROTTLE.lockMs;
          setAuthLockedState(true, `Too many attempts. Try again in ${Math.ceil(AUTH_THROTTLE.lockMs / 1000)}s.`);
          showStatus("Access gate temporarily locked.");
          return;
        }
        setAuthMessage(`Name not recognized. ${remaining} attempt${remaining === 1 ? "" : "s"} remaining.`, "error");
        return;
      }
      safeWrite(STORAGE.authSession, user);
      applyAccess(user);
      showStatus(`${user.name} signed in (${roleLabel(user.role)} mode).`);
    }

    function initAccessGate() {
      loadIdleMinutesPolicy();
      const stored = safeRead(STORAGE.authSession, null);
      const mapped = resolveAuthorizedUser(stored && stored.name);
      if (mapped && mapped.role === stored.role) {
        applyAccess(mapped);
      } else {
        lockAccess();
      }

      if (authUnlockBtn) {
        authUnlockBtn.addEventListener("click", unlockByName);
      }
      if (authNameInput) {
        authNameInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            unlockByName();
          }
        });
      }
      if (switchUserBtn) {
        switchUserBtn.addEventListener("click", () => {
          lockSessionNow("Session cleared. Enter an authorized name.");
        });
      }
      updateSessionSecurityUI();
    }

    function initSessionSecurity() {
      const activityEvents = ["pointerdown", "keydown", "mousedown", "touchstart", "scroll", "wheel"];
      activityEvents.forEach((eventName) => {
        window.addEventListener(eventName, () => markSessionActivity(), { passive: true });
      });
      window.addEventListener("focus", () => markSessionActivity(true));
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible") {
          markSessionActivity(true);
        }
      });

      if (idleMonitorId) {
        clearInterval(idleMonitorId);
      }
      updateSessionSecurityUI();
      idleMonitorId = window.setInterval(() => {
        if (!activeAuth || document.body.classList.contains("auth-locked")) {
          updateSessionSecurityUI();
          return;
        }
        const now = Date.now();
        const idleMs = now - lastActivityTs;
        const remainingMs = getIdleLockMs() - idleMs;

        if (remainingMs <= 0) {
          lockSessionNow("Session timed out due to inactivity.");
          return;
        }

        updateSessionSecurityUI(remainingMs);

        if (remainingMs <= SESSION_SECURITY.warningMs) {
          if (now - lastIdleWarningTs >= SESSION_SECURITY.warningPulseMs) {
            const seconds = Math.max(1, Math.ceil(remainingMs / 1000));
            showStatus(`Security: session locks in ${seconds}s without activity.`);
            lastIdleWarningTs = now;
          }
        } else {
          clearSessionWarning();
        }
      }, SESSION_SECURITY.pollMs);
    }

    let mathQueue = Promise.resolve();

    function typesetMath(target) {
      if (!target || !window.MathJax || typeof window.MathJax.typesetPromise !== "function") {
        return;
      }
      mathQueue = mathQueue
        .then(() => {
          if (typeof window.MathJax.typesetClear === "function") {
            window.MathJax.typesetClear([target]);
          }
          return window.MathJax.typesetPromise([target]);
        })
        .catch(() => {
          // Ignore typesetting failures and keep interactivity responsive.
        });
    }

    function clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    }

    function formatFormulaNumber(value, digits = 4) {
      if (!Number.isFinite(value)) return "--";
      const precision = Math.abs(value) >= 100 ? 2 : digits;
      return String(Number(value.toFixed(precision)));
    }

    function formatFormulaValueCell(value) {
      if (!Number.isFinite(value)) return "--";
      return value.toLocaleString(undefined, {
        minimumFractionDigits: 0,
        maximumFractionDigits: 4
      });
    }

    function getFormulaById(id) {
      return FORMULA_CATALOG.find((formula) => formula.id === id) || null;
    }

    function getVariableMeta(id) {
      return FORMULA_VARIABLES[id] || null;
    }

    function recommendedSeriesId(variableId, source = "fred") {
      const meta = getVariableMeta(variableId);
      if (!meta || !meta.sources || !meta.sources[source]) return "";
      return String(meta.sources[source].seriesId || "").trim();
    }

    function defaultFormulaBinding(variableId) {
      const defaultSeries = recommendedSeriesId(variableId, "fred") || recommendedSeriesId(variableId, "bls");
      return {
        source: "manual",
        seriesId: defaultSeries || "",
        manualValue: "",
        value: null,
        updatedAt: 0,
        updatedLabel: ""
      };
    }

    function defaultFormulaApiState() {
      return {
        fredKey: "",
        blsKey: ""
      };
    }

    function defaultFormulaLabState() {
      const firstFormula = FORMULA_CATALOG[0] || null;
      const firstVar = firstFormula && firstFormula.variables[0] ? firstFormula.variables[0] : "";
      const bindings = {};
      FORMULA_CATALOG.forEach((formula) => {
        formula.variables.forEach((variableId) => {
          if (!bindings[variableId]) {
            bindings[variableId] = defaultFormulaBinding(variableId);
          }
        });
      });
      return {
        selectedFormulaId: firstFormula ? firstFormula.id : "",
        selectedVariableId: firstVar,
        bindings
      };
    }

    function sanitizeFormulaBinding(raw, variableId) {
      const fallback = defaultFormulaBinding(variableId);
      if (!raw || typeof raw !== "object") return fallback;
      const source = FORMULA_SOURCES.includes(raw.source) ? raw.source : fallback.source;
      const seriesId = typeof raw.seriesId === "string"
        ? raw.seriesId.trim().slice(0, 64)
        : fallback.seriesId;
      const manualValue = typeof raw.manualValue === "string"
        ? raw.manualValue.trim().slice(0, 64)
        : (Number.isFinite(Number.parseFloat(raw.manualValue)) ? String(raw.manualValue).trim().slice(0, 64) : "");
      const parsedValue = Number.parseFloat(raw.value);
      const fallbackManual = Number.parseFloat(manualValue);
      const value = Number.isFinite(parsedValue)
        ? parsedValue
        : (Number.isFinite(fallbackManual) ? fallbackManual : null);
      const updatedAt = Math.max(0, Number.parseInt(raw.updatedAt, 10) || 0);
      const updatedLabel = typeof raw.updatedLabel === "string" ? raw.updatedLabel.slice(0, 220) : "";
      return {
        source,
        seriesId,
        manualValue,
        value,
        updatedAt,
        updatedLabel
      };
    }

    function sanitizeFormulaApiState(raw) {
      const base = defaultFormulaApiState();
      if (!raw || typeof raw !== "object") return base;
      return {
        fredKey: typeof raw.fredKey === "string" ? raw.fredKey.trim().slice(0, 128) : "",
        blsKey: typeof raw.blsKey === "string" ? raw.blsKey.trim().slice(0, 128) : ""
      };
    }

    function sanitizeFormulaLabState(raw) {
      const base = defaultFormulaLabState();
      if (!raw || typeof raw !== "object") return base;

      const selectedFormula = getFormulaById(raw.selectedFormulaId) || getFormulaById(base.selectedFormulaId);
      const selectedFormulaId = selectedFormula ? selectedFormula.id : "";

      const bindings = { ...base.bindings };
      if (raw.bindings && typeof raw.bindings === "object") {
        Object.keys(bindings).forEach((variableId) => {
          bindings[variableId] = sanitizeFormulaBinding(raw.bindings[variableId], variableId);
        });
      }

      let selectedVariableId = typeof raw.selectedVariableId === "string" ? raw.selectedVariableId : "";
      if (!selectedFormula || !selectedFormula.variables.includes(selectedVariableId)) {
        selectedVariableId = selectedFormula && selectedFormula.variables[0] ? selectedFormula.variables[0] : "";
      }

      return {
        selectedFormulaId,
        selectedVariableId,
        bindings
      };
    }

    function persistFormulaLabState() {
      if (!formulaLabState) return;
      safeWrite(STORAGE.formulaLab, formulaLabState);
    }

    function persistFormulaApiState() {
      if (!formulaApiState) return;
      safeWrite(STORAGE.formulaApi, formulaApiState);
    }

    function getActiveFormula() {
      if (!formulaLabState) return null;
      return getFormulaById(formulaLabState.selectedFormulaId);
    }

    function ensureFormulaBinding(variableId) {
      if (!formulaLabState || !formulaLabState.bindings || typeof formulaLabState.bindings !== "object") {
        formulaLabState = defaultFormulaLabState();
      }
      if (!formulaLabState.bindings[variableId]) {
        formulaLabState.bindings[variableId] = defaultFormulaBinding(variableId);
      }
      return formulaLabState.bindings[variableId];
    }

    function missingFormulaInputs(values, requiredIds) {
      return requiredIds.filter((id) => !Number.isFinite(values[id]));
    }

    function formulaError(message) {
      return {
        ok: false,
        message
      };
    }

    function formulaMissingResult(missingIds) {
      const labels = missingIds
        .map((id) => {
          const meta = getVariableMeta(id);
          return meta ? `\\(${meta.symbolLatex}\\)` : id;
        })
        .join(", ");
      return formulaError(`Missing numeric values for ${labels}. Add values manually or fetch data first.`);
    }

    function formulaSuccess(outputVarId, value, summary, stepsHtml = "") {
      return {
        ok: true,
        outputVarId,
        value,
        summary,
        stepsHtml
      };
    }

    function getFormulaValues(formula) {
      const values = {};
      formula.variables.forEach((id) => {
        const binding = ensureFormulaBinding(id);
        values[id] = Number.isFinite(binding.value) ? binding.value : null;
      });
      return values;
    }

    function setFormulaComputeFeedback(message, tone = "") {
      if (!formulaComputeResult) return;
      formulaComputeResult.innerHTML = message;
      formulaComputeResult.className = `arena-feedback${tone ? ` ${tone}` : ""}`;
      typesetMath(formulaComputeResult);
    }

    function setFormulaDataStatus(message) {
      if (!formulaDataMeta) return;
      formulaDataMeta.textContent = message;
    }

    function formatFormulaTimestamp(ts) {
      if (!Number.isFinite(ts) || ts <= 0) return "";
      try {
        return new Date(ts).toLocaleString([], {
          hour: "2-digit",
          minute: "2-digit",
          month: "short",
          day: "numeric"
        });
      } catch {
        return "";
      }
    }

    function updateFormulaInputVisibility() {
      if (!formulaSourceSelect || !formulaSeriesField || !formulaManualField) return;
      const source = formulaSourceSelect.value;
      formulaSeriesField.hidden = source === "manual";
      formulaManualField.hidden = source !== "manual";
    }

    function renderFormulaCatalog() {
      if (!formulaCatalog || !formulaLabState) return;
      formulaCatalog.innerHTML = "";
      FORMULA_CATALOG.forEach((formula) => {
        const button = document.createElement("button");
        button.type = "button";
        button.className = `formula-item${formulaLabState.selectedFormulaId === formula.id ? " active" : ""}`;
        button.innerHTML = `
          <span class="kicker">${formula.topic}</span>
          <span class="title">${formula.title}</span>
          <span class="math">\\(${formula.latex}\\)</span>
        `;
        button.addEventListener("click", () => {
          selectFormula(formula.id);
        });
        formulaCatalog.appendChild(button);
      });
      typesetMath(formulaCatalog);
    }

    function renderFormulaVariableDetails() {
      const formula = getActiveFormula();
      if (!formula || !formulaLabState) return;
      const variableId = formulaLabState.selectedVariableId;
      const meta = getVariableMeta(variableId);
      if (!meta) return;

      if (formulaVariableTitle) formulaVariableTitle.textContent = `${meta.label} Explorer`;
      if (formulaVariableSymbol) formulaVariableSymbol.innerHTML = `\\(${meta.symbolLatex}\\)`;
      if (formulaVariableDefinition) formulaVariableDefinition.textContent = meta.definition;
      if (formulaVariableRole) {
        const roleBits = [meta.role];
        if (formula.outputVarId === variableId) {
          roleBits.push("This variable is the current compute target in this formula.");
        }
        formulaVariableRole.textContent = roleBits.join(" ");
      }
      if (formulaVariableUnits) formulaVariableUnits.textContent = meta.units;
      if (formulaVariableDataMap) formulaVariableDataMap.textContent = meta.dataMap;
      if (formulaVariableExamHint) formulaVariableExamHint.textContent = meta.examHint;
      typesetMath(formulaVariableSymbol);
    }

    function renderFormulaControlPanel() {
      const formula = getActiveFormula();
      if (!formula || !formulaLabState || !formulaVariableSelect || !formulaSourceSelect || !formulaSeriesInput || !formulaManualInput) return;

      formulaVariableSelect.innerHTML = "";
      formula.variables.forEach((variableId) => {
        const meta = getVariableMeta(variableId);
        const option = document.createElement("option");
        option.value = variableId;
        option.textContent = `${meta ? meta.label : variableId} [${variableId}]`;
        formulaVariableSelect.appendChild(option);
      });

      if (!formula.variables.includes(formulaLabState.selectedVariableId)) {
        formulaLabState.selectedVariableId = formula.variables[0] || "";
      }
      formulaVariableSelect.value = formulaLabState.selectedVariableId;

      const binding = ensureFormulaBinding(formulaLabState.selectedVariableId);
      const uiSource = binding.source === "computed" ? "manual" : binding.source;
      formulaSourceSelect.value = ["manual", "fred", "bls"].includes(uiSource) ? uiSource : "manual";

      const source = formulaSourceSelect.value;
      if (source === "manual") {
        formulaManualInput.value = binding.manualValue || (Number.isFinite(binding.value) ? String(binding.value) : "");
      } else {
        const recommended = recommendedSeriesId(formulaLabState.selectedVariableId, source);
        formulaSeriesInput.value = binding.seriesId || recommended;
      }

      const ts = formatFormulaTimestamp(binding.updatedAt);
      if (binding.updatedLabel) {
        setFormulaDataStatus(`Latest ${formulaLabState.selectedVariableId}: ${binding.updatedLabel}${ts ? ` (${ts})` : ""}`);
      } else {
        setFormulaDataStatus("No variable updates yet.");
      }

      updateFormulaInputVisibility();
    }

    function renderFormulaBindingsTable() {
      const formula = getActiveFormula();
      if (!formula || !formulaBindingsTable || !formulaLabState) return;
      formulaBindingsTable.innerHTML = "";

      const header = document.createElement("div");
      header.className = "formula-binding-row header";
      header.innerHTML = "<span>Variable</span><span>Value</span><span>Source</span><span>Series / Update</span>";
      formulaBindingsTable.appendChild(header);

      formula.variables.forEach((variableId) => {
        const meta = getVariableMeta(variableId);
        const binding = ensureFormulaBinding(variableId);
        const row = document.createElement("button");
        row.type = "button";
        row.className = `formula-binding-row${variableId === formulaLabState.selectedVariableId ? " active" : ""}`;
        const sourceLabel = binding.source === "computed"
          ? "computed"
          : (binding.source || "manual");
        const updateBits = [];
        if (binding.seriesId) updateBits.push(binding.seriesId);
        if (binding.updatedLabel) updateBits.push(binding.updatedLabel);
        const ts = formatFormulaTimestamp(binding.updatedAt);
        if (ts) updateBits.push(ts);
        row.innerHTML = `
          <span>\\(${meta ? meta.symbolLatex : variableId}\\) ${meta ? meta.label : variableId}</span>
          <span class="cell-value">${formatFormulaValueCell(binding.value)}</span>
          <span class="cell-source">${sourceLabel}</span>
          <span class="cell-series">${updateBits.join("  ") || "No data yet"}</span>
        `;
        row.addEventListener("click", () => {
          selectFormulaVariable(variableId);
        });
        formulaBindingsTable.appendChild(row);
      });
      typesetMath(formulaBindingsTable);
    }

    function renderActiveFormula() {
      const formula = getActiveFormula();
      if (!formula || !formulaLabState) return;

      if (formulaActiveTitle) formulaActiveTitle.textContent = formula.title;
      if (formulaActiveTopic) formulaActiveTopic.textContent = formula.topic;
      if (formulaActiveLatex) formulaActiveLatex.innerHTML = `\\(${formula.latex}\\)`;
      if (formulaIntuition) formulaIntuition.textContent = formula.intuition;
      if (formulaExamFocus) {
        formulaExamFocus.innerHTML = "";
        formula.examFocus.forEach((item) => {
          const li = document.createElement("li");
          li.innerHTML = item;
          formulaExamFocus.appendChild(li);
        });
      }
      if (!formula.variables.includes(formulaLabState.selectedVariableId)) {
        formulaLabState.selectedVariableId = formula.variables[0] || "";
      }

      if (formulaVariableButtons) {
        formulaVariableButtons.innerHTML = "";
        formula.variables.forEach((variableId) => {
          const meta = getVariableMeta(variableId);
          const chip = document.createElement("button");
          chip.type = "button";
          chip.className = `formula-var-chip${variableId === formulaLabState.selectedVariableId ? " active" : ""}`;
          chip.innerHTML = `<span class="symbol">\\(${meta ? meta.symbolLatex : variableId}\\)</span><span>${meta ? meta.label : variableId}</span>`;
          chip.addEventListener("click", () => {
            selectFormulaVariable(variableId);
          });
          formulaVariableButtons.appendChild(chip);
        });
      }

      renderFormulaVariableDetails();
      renderFormulaControlPanel();
      renderFormulaBindingsTable();
      persistFormulaLabState();
      typesetMath(formulaActiveLatex);
      typesetMath(formulaExamFocus);
      typesetMath(formulaVariableButtons);
    }

    function selectFormula(formulaId, silent = false) {
      if (!formulaLabState) formulaLabState = defaultFormulaLabState();
      const next = getFormulaById(formulaId) || FORMULA_CATALOG[0];
      if (!next) return;
      formulaLabState.selectedFormulaId = next.id;
      if (!next.variables.includes(formulaLabState.selectedVariableId)) {
        formulaLabState.selectedVariableId = next.variables[0] || "";
      }
      renderFormulaCatalog();
      renderActiveFormula();
      if (!silent) showStatus(`Loaded formula: ${next.title}`);
    }

    function selectFormulaVariable(variableId, silent = false) {
      const formula = getActiveFormula();
      if (!formula || !formulaLabState) return;
      if (!formula.variables.includes(variableId)) return;
      formulaLabState.selectedVariableId = variableId;
      renderActiveFormula();
      if (!silent) {
        const meta = getVariableMeta(variableId);
        showStatus(`Variable focus: ${meta ? meta.label : variableId}`);
      }
    }

    function saveFormulaVariableBinding() {
      if (!formulaLabState || !formulaSourceSelect || !formulaSeriesInput || !formulaManualInput) return;
      const variableId = formulaLabState.selectedVariableId;
      const binding = ensureFormulaBinding(variableId);
      const source = ["manual", "fred", "bls"].includes(formulaSourceSelect.value)
        ? formulaSourceSelect.value
        : "manual";
      binding.source = source;
      if (source === "manual") {
        binding.manualValue = formulaManualInput.value.trim();
        const numeric = Number.parseFloat(binding.manualValue);
        if (binding.manualValue && Number.isFinite(numeric)) {
          binding.value = numeric;
          binding.updatedAt = Date.now();
          binding.updatedLabel = "Manual value saved";
        } else if (!binding.manualValue) {
          binding.value = null;
          binding.updatedAt = Date.now();
          binding.updatedLabel = "Manual value cleared";
        }
      } else {
        const candidateSeries = formulaSeriesInput.value.trim().toUpperCase();
        const fallback = recommendedSeriesId(variableId, source);
        binding.seriesId = candidateSeries || fallback;
      }
      persistFormulaLabState();
      renderFormulaBindingsTable();
      renderFormulaControlPanel();
      showStatus("Variable binding saved.");
    }

    function applyManualFormulaValue() {
      if (!formulaLabState || !formulaManualInput || !formulaSourceSelect) return;
      const variableId = formulaLabState.selectedVariableId;
      const binding = ensureFormulaBinding(variableId);
      const raw = formulaManualInput.value.trim();
      const numeric = Number.parseFloat(raw);
      if (!raw || !Number.isFinite(numeric)) {
        setFormulaComputeFeedback("Enter a valid numeric manual value first.", "error");
        return;
      }
      binding.source = "manual";
      binding.manualValue = raw;
      binding.value = numeric;
      binding.updatedAt = Date.now();
      binding.updatedLabel = "Manual value applied";
      formulaSourceSelect.value = "manual";
      persistFormulaLabState();
      renderFormulaBindingsTable();
      renderFormulaControlPanel();
      setFormulaComputeFeedback(`Stored manual value for \\(${getVariableMeta(variableId).symbolLatex}\\): ${formatFormulaNumber(numeric)}.`, "success");
      showStatus("Manual variable value applied.");
    }

    function saveFormulaApiKeys() {
      if (!formulaApiState || !fredApiKeyInput || !blsApiKeyInput) return;
      formulaApiState.fredKey = fredApiKeyInput.value.trim();
      formulaApiState.blsKey = blsApiKeyInput.value.trim();
      persistFormulaApiState();
      setFormulaDataStatus("API keys saved in local storage for this browser.");
      showStatus("Formula API keys saved locally.");
    }

    async function fetchJsonWithTimeout(url, options = {}, timeoutMs = 15000) {
      const controller = new AbortController();
      const timeoutId = window.setTimeout(() => controller.abort(), timeoutMs);
      try {
        const response = await fetch(url, { ...options, signal: controller.signal });
        const payload = await response.json();
        if (!response.ok) {
          const details = payload && typeof payload === "object"
            ? (payload.error_message || payload.message || payload.status || "")
            : "";
          throw new Error(`${response.status} ${response.statusText}${details ? `: ${details}` : ""}`);
        }
        return payload;
      } finally {
        window.clearTimeout(timeoutId);
      }
    }

    async function fetchFredObservationLatest(seriesId, apiKey = "") {
      const dataUrl = new URL("https://api.stlouisfed.org/fred/series/observations");
      dataUrl.searchParams.set("series_id", seriesId);
      dataUrl.searchParams.set("sort_order", "desc");
      dataUrl.searchParams.set("limit", "120");
      dataUrl.searchParams.set("file_type", "json");
      if (apiKey) dataUrl.searchParams.set("api_key", apiKey);

      const payload = await fetchJsonWithTimeout(dataUrl.toString(), {
        headers: { Accept: "application/json" }
      });
      if (!payload || !Array.isArray(payload.observations)) {
        throw new Error("Unexpected FRED response shape.");
      }
      const observation = payload.observations.find((item) => {
        if (!item || typeof item.value !== "string") return false;
        const numeric = Number.parseFloat(item.value);
        return Number.isFinite(numeric);
      });
      if (!observation) {
        throw new Error("No numeric observation returned for this FRED series.");
      }
      let title = seriesId;
      let units = "";
      try {
        const metaUrl = new URL("https://api.stlouisfed.org/fred/series");
        metaUrl.searchParams.set("series_id", seriesId);
        metaUrl.searchParams.set("file_type", "json");
        if (apiKey) metaUrl.searchParams.set("api_key", apiKey);
        const meta = await fetchJsonWithTimeout(metaUrl.toString(), {
          headers: { Accept: "application/json" }
        });
        if (meta && Array.isArray(meta.seriess) && meta.seriess[0]) {
          title = meta.seriess[0].title || title;
          units = meta.seriess[0].units_short || meta.seriess[0].units || "";
        }
      } catch {
        // Keep fallback metadata if secondary lookup fails.
      }

      return {
        source: "fred",
        seriesId,
        value: Number.parseFloat(observation.value),
        date: observation.date || "",
        title,
        units
      };
    }

    function blsPeriodLabel(rawPeriod, periodName = "") {
      if (periodName) return periodName;
      if (!rawPeriod) return "";
      if (rawPeriod === "M13") return "Annual average";
      if (/^M\d{2}$/.test(rawPeriod)) {
        const monthIdx = Number.parseInt(rawPeriod.slice(1), 10) - 1;
        const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        return monthNames[monthIdx] || rawPeriod;
      }
      if (/^Q\d$/.test(rawPeriod)) return rawPeriod;
      return rawPeriod;
    }

    async function fetchBlsObservationLatest(seriesId, apiKey = "") {
      const year = new Date().getFullYear();
      const requestBody = {
        seriesid: [seriesId],
        startyear: String(year - 2),
        endyear: String(year)
      };
      if (apiKey) requestBody.registrationkey = apiKey;

      const payload = await fetchJsonWithTimeout("https://api.bls.gov/publicAPI/v2/timeseries/data/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        body: JSON.stringify(requestBody)
      });
      if (!payload || payload.status !== "REQUEST_SUCCEEDED") {
        throw new Error("BLS request did not succeed.");
      }

      const series = payload.Results && Array.isArray(payload.Results.series)
        ? payload.Results.series[0]
        : null;
      if (!series || !Array.isArray(series.data)) {
        throw new Error("Unexpected BLS response shape.");
      }
      const observation = series.data.find((item) => {
        if (!item || typeof item.value !== "string") return false;
        const cleaned = item.value.replace(/,/g, "");
        return Number.isFinite(Number.parseFloat(cleaned));
      });
      if (!observation) {
        throw new Error("No numeric observation returned for this BLS series.");
      }

      const value = Number.parseFloat(observation.value.replace(/,/g, ""));
      const period = blsPeriodLabel(observation.period, observation.periodName);
      const date = `${period} ${observation.year}`.trim();
      const title = series.catalog && series.catalog.series_title
        ? series.catalog.series_title
        : series.seriesID;
      return {
        source: "bls",
        seriesId,
        value,
        date,
        title,
        units: ""
      };
    }

    async function fetchSelectedFormulaVariable() {
      if (formulaFetchInFlight) return;
      if (!formulaLabState || !formulaSourceSelect || !formulaSeriesInput) return;
      const variableId = formulaLabState.selectedVariableId;
      const source = formulaSourceSelect.value;
      if (source !== "fred" && source !== "bls") {
        setFormulaComputeFeedback("Switch source to FRED or BLS to fetch series data.", "error");
        return;
      }

      const binding = ensureFormulaBinding(variableId);
      const seriesId = formulaSeriesInput.value.trim().toUpperCase() || binding.seriesId || recommendedSeriesId(variableId, source);
      if (!seriesId) {
        setFormulaComputeFeedback(`No ${source.toUpperCase()} series ID provided for this variable.`, "error");
        return;
      }

      formulaFetchInFlight = true;
      if (formulaFetchBtn) formulaFetchBtn.disabled = true;
      setFormulaDataStatus(`Fetching ${source.toUpperCase()} series ${seriesId}...`);

      try {
        const apiKey = source === "fred"
          ? (formulaApiState ? formulaApiState.fredKey : "")
          : (formulaApiState ? formulaApiState.blsKey : "");
        const packet = source === "fred"
          ? await fetchFredObservationLatest(seriesId, apiKey || "")
          : await fetchBlsObservationLatest(seriesId, apiKey || "");

        binding.source = source;
        binding.seriesId = seriesId;
        binding.value = packet.value;
        binding.manualValue = String(packet.value);
        binding.updatedAt = Date.now();
        binding.updatedLabel = `${packet.title}${packet.date ? `  ${packet.date}` : ""}`;

        persistFormulaLabState();
        renderFormulaBindingsTable();
        renderFormulaControlPanel();
        setFormulaComputeFeedback(
          `Loaded \\(${getVariableMeta(variableId).symbolLatex}\\) = ${formatFormulaNumber(packet.value)} from ${source.toUpperCase()} (${seriesId}).`,
          "success"
        );
        showStatus(`Fetched ${seriesId} from ${source.toUpperCase()}.`);
      } catch (error) {
        const message = error && error.name === "AbortError"
          ? "Request timed out. Try again."
          : (error && error.message ? error.message : "Failed to fetch series value.");
        setFormulaComputeFeedback(`Data fetch failed: ${message}`, "error");
        setFormulaDataStatus(`Fetch failed for ${seriesId}.`);
      } finally {
        formulaFetchInFlight = false;
        if (formulaFetchBtn) formulaFetchBtn.disabled = false;
      }
    }

    function computeActiveFormula() {
      const formula = getActiveFormula();
      if (!formula) return;
      const values = getFormulaValues(formula);
      const result = formula.compute(values);
      if (!result || typeof result !== "object" || !result.ok) {
        const message = result && result.message ? result.message : "Unable to compute this formula with current values.";
        setFormulaComputeFeedback(message, "error");
        if (formulaComputeSteps) {
          formulaComputeSteps.innerHTML = "";
          formulaComputeSteps.classList.remove("show");
        }
        return;
      }

      const outputVarId = result.outputVarId || formula.outputVarId;
      if (outputVarId) {
        const outputBinding = ensureFormulaBinding(outputVarId);
        outputBinding.value = result.value;
        outputBinding.manualValue = String(result.value);
        outputBinding.source = "computed";
        outputBinding.updatedAt = Date.now();
        outputBinding.updatedLabel = `Computed from ${formula.title}`;
      }
      persistFormulaLabState();
      renderFormulaBindingsTable();
      renderFormulaControlPanel();
      setFormulaComputeFeedback(result.summary || "Formula computed.", "success");
      if (formulaComputeSteps) {
        formulaComputeSteps.innerHTML = result.stepsHtml || "";
        formulaComputeSteps.classList.toggle("show", Boolean(result.stepsHtml));
        if (result.stepsHtml) typesetMath(formulaComputeSteps);
      }
      showStatus(`Computed ${formula.title}.`);
    }

    function resetFormulaLabState(shouldPersist = true, clearKeys = false) {
      formulaLabState = defaultFormulaLabState();
      if (clearKeys) {
        formulaApiState = defaultFormulaApiState();
        if (fredApiKeyInput) fredApiKeyInput.value = "";
        if (blsApiKeyInput) blsApiKeyInput.value = "";
      }
      if (shouldPersist) {
        safeWrite(STORAGE.formulaLab, formulaLabState);
        if (clearKeys) {
          safeWrite(STORAGE.formulaApi, formulaApiState || defaultFormulaApiState());
        }
      }
      renderFormulaCatalog();
      renderActiveFormula();
      if (formulaComputeSteps) {
        formulaComputeSteps.innerHTML = "";
        formulaComputeSteps.classList.remove("show");
      }
      setFormulaComputeFeedback("Formula playground reset. Choose values and compute again.");
      setFormulaDataStatus("No variable updates yet.");
    }

    function initFormulaEngine() {
      if (
        !formulaCatalog
        || !formulaActiveTitle
        || !formulaActiveLatex
        || !formulaIntuition
        || !formulaExamFocus
        || !formulaVariableButtons
        || !formulaVariableSelect
        || !formulaSourceSelect
        || !formulaSeriesInput
        || !formulaManualInput
        || !formulaSaveBindingBtn
        || !formulaFetchBtn
        || !formulaApplyManualBtn
        || !formulaSaveKeysBtn
        || !formulaBindingsTable
        || !formulaComputeBtn
        || !formulaResetBtn
      ) {
        return;
      }

      formulaApiState = sanitizeFormulaApiState(safeRead(STORAGE.formulaApi, null));
      formulaLabState = sanitizeFormulaLabState(safeRead(STORAGE.formulaLab, null));

      if (fredApiKeyInput) fredApiKeyInput.value = formulaApiState.fredKey;
      if (blsApiKeyInput) blsApiKeyInput.value = formulaApiState.blsKey;

      renderFormulaCatalog();
      selectFormula(formulaLabState.selectedFormulaId, true);
      setFormulaComputeFeedback("Ready to compute.");
      setFormulaDataStatus("No variable updates yet.");

      formulaVariableSelect.addEventListener("change", () => {
        selectFormulaVariable(formulaVariableSelect.value, true);
      });
      formulaSourceSelect.addEventListener("change", () => {
        updateFormulaInputVisibility();
        const variableId = formulaLabState ? formulaLabState.selectedVariableId : "";
        const fallback = recommendedSeriesId(variableId, formulaSourceSelect.value);
        if (formulaSourceSelect.value !== "manual" && !formulaSeriesInput.value.trim() && fallback) {
          formulaSeriesInput.value = fallback;
        }
      });
      formulaSaveBindingBtn.addEventListener("click", saveFormulaVariableBinding);
      formulaApplyManualBtn.addEventListener("click", applyManualFormulaValue);
      formulaFetchBtn.addEventListener("click", fetchSelectedFormulaVariable);
      formulaSaveKeysBtn.addEventListener("click", saveFormulaApiKeys);
      formulaComputeBtn.addEventListener("click", computeActiveFormula);
      formulaResetBtn.addEventListener("click", () => {
        resetFormulaLabState(true, false);
        showStatus("Formula playground reset.");
      });
      if (fredApiKeyInput) {
        fredApiKeyInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            saveFormulaApiKeys();
          }
        });
      }
      if (blsApiKeyInput) {
        blsApiKeyInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            saveFormulaApiKeys();
          }
        });
      }
    }

    function isCardShape(card) {
      return card && typeof card === "object";
    }

    function defaultCard() {
      return {
        seen: 0,
        correct: 0,
        streak: 0,
        ef: 2.3,
        intervalDays: 0,
        dueTs: 0,
        lastSeenTs: 0,
        lastRating: ""
      };
    }

    function sanitizeCard(raw) {
      const base = defaultCard();
      if (!isCardShape(raw)) return base;
      return {
        seen: clamp(Number.parseInt(raw.seen, 10) || 0, 0, 100000),
        correct: clamp(Number.parseInt(raw.correct, 10) || 0, 0, 100000),
        streak: clamp(Number.parseInt(raw.streak, 10) || 0, 0, 10000),
        ef: clamp(Number.parseFloat(raw.ef) || 2.3, 1.3, 2.8),
        intervalDays: clamp(Number.parseInt(raw.intervalDays, 10) || 0, 0, 3650),
        dueTs: Math.max(0, Number.parseInt(raw.dueTs, 10) || 0),
        lastSeenTs: Math.max(0, Number.parseInt(raw.lastSeenTs, 10) || 0),
        lastRating: typeof raw.lastRating === "string" ? raw.lastRating : ""
      };
    }

    function sanitizeCardStats(rawStats) {
      if (!Array.isArray(rawStats)) return prompts.map(() => defaultCard());
      const next = [];
      for (let i = 0; i < prompts.length; i += 1) {
        next.push(sanitizeCard(rawStats[i]));
      }
      return next;
    }

    let cardStats = sanitizeCardStats(safeRead(STORAGE.cards, null));

    function getCard(idx) {
      if (!cardStats[idx]) {
        cardStats[idx] = defaultCard();
      }
      return cardStats[idx];
    }

    function persistCardStats() {
      safeWrite(STORAGE.cards, cardStats);
    }

    function availableIndices() {
      const out = [];
      for (let i = 0; i < prompts.length; i += 1) {
        if (!masteredSet.has(i)) out.push(i);
      }
      return out;
    }

    function cardDueNow(idx, nowMs = Date.now()) {
      const card = getCard(idx);
      return card.seen === 0 || card.dueTs <= nowMs;
    }

    function computeTotals() {
      return cardStats.reduce((acc, c) => {
        acc.seen += c.seen;
        acc.correct += c.correct;
        return acc;
      }, { seen: 0, correct: 0 });
    }

    function formatDueDistance(ts) {
      if (!ts) return "now";
      const diff = ts - Date.now();
      if (diff <= 0) return "now";
      const mins = Math.ceil(diff / 60000);
      if (mins < 60) return `${mins}m`;
      const hours = Math.ceil(mins / 60);
      if (hours < 24) return `${hours}h`;
      const days = Math.ceil(hours / 24);
      return `${days}d`;
    }

    function weightedPick(indices, nowMs) {
      if (indices.length === 0) return null;
      const pool = indices.length > 1 && currentIdx !== null
        ? indices.filter((i) => i !== currentIdx)
        : indices.slice();
      const finalPool = pool.length ? pool : indices.slice();

      const weights = finalPool.map((idx) => {
        const c = getCard(idx);
        const accuracy = c.seen > 0 ? (c.correct / c.seen) : 0;
        const overdueHours = c.dueTs > 0 ? Math.max(0, (nowMs - c.dueTs) / 3600000) : 0;
        const noveltyBoost = c.seen === 0 ? 0.7 : 0;
        const weaknessBoost = (1 - accuracy) * 2.1;
        const overdueBoost = Math.min(3, overdueHours / 12);
        return 1 + noveltyBoost + weaknessBoost + overdueBoost;
      });

      let sum = 0;
      for (const w of weights) sum += w;
      let r = Math.random() * sum;

      for (let i = 0; i < finalPool.length; i += 1) {
        r -= weights[i];
        if (r <= 0) return finalPool[i];
      }
      return finalPool[finalPool.length - 1];
    }

    function showStatus(message) {
      liveStatus.textContent = message;
      window.clearTimeout(showStatus._t);
      showStatus._t = window.setTimeout(() => {
        liveStatus.textContent = "";
      }, 2600);
    }

    let masteredSet = new Set(
      (safeRead(STORAGE.mastered, []) || [])
        .filter((i) => Number.isInteger(i) && i >= 0 && i < prompts.length)
    );

    let checks = safeRead(STORAGE.checks, Array(dailyChecks.length).fill(false));
    if (!Array.isArray(checks) || checks.length !== dailyChecks.length) {
      checks = Array(dailyChecks.length).fill(false);
    } else {
      checks = checks.map(Boolean);
    }

    function availableCount() {
      return prompts.length - masteredSet.size;
    }

    function updateFlashStats() {
      const totals = computeTotals();
      const score = totals.seen ? Math.round((totals.correct / totals.seen) * 100) : 0;
      const nowMs = Date.now();
      const dueNow = availableIndices().filter((i) => cardDueNow(i, nowMs)).length;
      const currentDue = currentIdx === null ? "n/a" : formatDueDistance(getCard(currentIdx).dueTs);

      flashMasteredMeta.textContent = `Mastered: ${masteredSet.size}/${prompts.length}`;
      seenCount.textContent = String(totals.seen);
      remainingCount.textContent = String(availableCount());
      recallScore.textContent = `${score}%`;
      flashAdaptiveMeta.textContent = `Due now: ${dueNow}  Recall score: ${score}%`;
      flashMeta.textContent = currentIdx === null
        ? "No active prompt"
        : `Prompt #${currentIdx + 1}  Next due ${currentDue}`;
      heroRecallCount.textContent = String(prompts.length);
      updateMissionControl();
    }

    function choiceKey(index) {
      return String.fromCharCode(65 + index);
    }

    function setRecallFeedback(message, tone = "") {
      if (!recallFeedback) return;
      recallFeedback.innerHTML = message;
      recallFeedback.className = `arena-feedback${tone ? ` ${tone}` : ""}`;
      typesetMath(recallFeedback);
    }

    function setRatingControlsEnabled(enabled) {
      [rateAgainBtn, rateHardBtn, rateGoodBtn, rateEasyBtn].forEach((btn) => {
        if (!btn) return;
        btn.disabled = !enabled;
      });
    }

    function resetRecallSubmissionState() {
      recallSubmitted = false;
      recallLastCorrect = false;
      if (flashAttemptMeta) flashAttemptMeta.textContent = "Status: Awaiting submission";
      setRatingControlsEnabled(false);
      setRecallFeedback("No response submitted yet.");
    }

    function getSelectedRecallChoice() {
      if (!recallOptions) return null;
      const selected = recallOptions.querySelector("input[name='recallChoice']:checked");
      if (!selected) return null;
      const value = Number.parseInt(selected.value, 10);
      return Number.isInteger(value) ? value : null;
    }

    function renderRecallOptions(prompt) {
      if (!recallOptions) return;
      recallOptions.innerHTML = "";
      prompt.choices.forEach((choice, idx) => {
        const option = document.createElement("label");
        option.className = "recall-option";
        option.innerHTML = `
          <input type="radio" name="recallChoice" value="${idx}" />
          <span class="choice-key">${choiceKey(idx)}</span>
          <span class="choice-text">${choice}</span>
        `;
        const input = option.querySelector("input");
        if (input) {
          input.addEventListener("change", () => {
            recallOptions.querySelectorAll(".recall-option").forEach((node) => {
              node.classList.toggle("selected", Boolean(node.querySelector("input:checked")));
            });
          });
        }
        recallOptions.appendChild(option);
      });
      typesetMath(recallOptions);
    }

    function clearAnswerBox(silent = false) {
      if (!recallOptions) return;
      if (recallSubmitted) {
        setRecallFeedback("Answer already submitted. Use New Prompt to attempt another question.");
        return;
      }
      recallOptions.querySelectorAll("input[name='recallChoice']").forEach((input) => {
        input.disabled = false;
        input.checked = false;
      });
      recallOptions.querySelectorAll(".recall-option").forEach((row) => {
        row.classList.remove("selected", "correct", "wrong");
      });
      if (!silent && !recallSubmitted) {
        setRecallFeedback("Selection cleared. Choose one option, then submit.");
      }
    }

    function setCardByIndex(idx) {
      currentIdx = idx;
      const prompt = prompts[idx];
      flashQ.innerHTML = prompt.q;
      flashA.innerHTML = prompt.a;
      flashA.style.display = "none";
      if (flashModeMeta) flashModeMeta.textContent = "Format: Multiple Choice";
      if (flashModeHelp) flashModeHelp.innerHTML = prompt.guidance || "Select one option and press Submit Answer.";
      renderRecallOptions(prompt);
      resetRecallSubmissionState();
      clearAnswerBox(true);
      updateFlashStats();
      typesetMath(flashQ);
      typesetMath(flashA);
      typesetMath(flashModeHelp);
    }

    function pickPrompt() {
      if (availableCount() === 0) {
        currentIdx = null;
        flashQ.textContent = "All prompts are marked mastered. Click Reset Deck to practice again.";
        flashA.textContent = "";
        flashA.style.display = "none";
        if (recallOptions) recallOptions.innerHTML = "";
        if (flashModeMeta) flashModeMeta.textContent = "Format: -";
        if (flashModeHelp) flashModeHelp.textContent = "Reset the deck to continue.";
        if (flashAttemptMeta) flashAttemptMeta.textContent = "Status: Deck complete";
        setRecallFeedback("All prompts mastered in current deck.", "success");
        setRatingControlsEnabled(false);
        updateFlashStats();
        return;
      }

      const nowMs = Date.now();
      const pool = availableIndices();
      const duePool = pool.filter((i) => cardDueNow(i, nowMs));
      const next = weightedPick(duePool.length ? duePool : pool, nowMs);
      setCardByIndex(next);
    }

    function submitRecallAnswer() {
      if (currentIdx === null) {
        pickPrompt();
        return;
      }
      const prompt = prompts[currentIdx];
      const selected = getSelectedRecallChoice();
      if (selected === null) {
        setRecallFeedback("Select an option before submitting.", "error");
        if (flashAttemptMeta) flashAttemptMeta.textContent = "Status: Missing selection";
        return;
      }

      const correct = selected === prompt.correctChoice;
      recallSubmitted = true;
      recallLastCorrect = correct;

      recallOptions.querySelectorAll(".recall-option").forEach((row, idx) => {
        row.classList.remove("selected", "correct", "wrong");
        if (idx === prompt.correctChoice) row.classList.add("correct");
        if (idx === selected && idx !== prompt.correctChoice) row.classList.add("wrong");
        const input = row.querySelector("input[name='recallChoice']");
        if (input) input.disabled = true;
      });

      if (flashAttemptMeta) {
        flashAttemptMeta.textContent = correct
          ? "Status: Submitted  Correct"
          : "Status: Submitted  Needs review";
      }

      if (correct) {
        setRecallFeedback("Correct. Now choose Again/Hard/Good/Easy to schedule the next review.", "success");
      } else {
        setRecallFeedback("Not quite. Review the highlighted correct option, then choose a rating for spaced repetition.", "error");
      }
      setRatingControlsEnabled(true);
    }

    function revealAnswer() {
      if (currentIdx === null) pickPrompt();
      if (currentIdx !== null) {
        flashA.style.display = "block";
        typesetMath(flashA);
        if (flashAttemptMeta && !recallSubmitted) {
          flashAttemptMeta.textContent = "Status: Answer revealed";
          setRecallFeedback("Answer revealed. Choose Again/Hard/Good/Easy based on how hard this felt.");
          setRatingControlsEnabled(true);
        }
      }
    }

    function applyRating(idx, grade) {
      const nowMs = Date.now();
      const card = getCard(idx);
      const qualityMap = { again: 0, hard: 3, good: 4, easy: 5 };
      const q = qualityMap[grade];
      if (q === undefined) return;

      card.seen += 1;
      card.lastSeenTs = nowMs;
      card.lastRating = grade;

      if (q < 3) {
        card.streak = 0;
        card.intervalDays = 0;
        card.ef = clamp(card.ef - 0.2, 1.3, 2.8);
        card.dueTs = nowMs + (10 * 60 * 1000);
        if (masteredSet.has(idx)) {
          masteredSet.delete(idx);
          safeWrite(STORAGE.mastered, [...masteredSet]);
        }
      } else {
        card.correct += 1;
        card.streak += 1;
        if (card.streak === 1) {
          card.intervalDays = grade === "easy" ? 2 : 1;
        } else if (card.streak === 2) {
          card.intervalDays = grade === "easy" ? 4 : (grade === "hard" ? 2 : 3);
        } else {
          const factor = grade === "hard"
            ? Math.max(1.2, card.ef - 0.25)
            : (grade === "easy" ? card.ef + 0.2 : card.ef);
          card.intervalDays = Math.max(1, Math.round(card.intervalDays * factor));
        }
        card.ef = clamp(
          card.ef + (0.1 - (5 - q) * (0.08 + (5 - q) * 0.02)),
          1.3,
          2.8
        );
        card.dueTs = nowMs + (card.intervalDays * 24 * 60 * 60 * 1000);
      }

      persistCardStats();
    }

    function rateCurrent(grade) {
      if (currentIdx === null) {
        showStatus("No active prompt to rate.");
        return;
      }
      const answerRevealed = flashA && flashA.style.display === "block";
      if (!recallSubmitted && !answerRevealed) {
        showStatus("Submit an answer (or reveal it) before rating.");
        return;
      }
      applyRating(currentIdx, grade);
      const nextDue = formatDueDistance(getCard(currentIdx).dueTs);
      showStatus(`Rated ${grade}. Next due in ${nextDue}.`);
      pickPrompt();
    }

    function markCurrentMastered() {
      if (currentIdx === null) {
        showStatus("No active prompt to mark.");
        return;
      }
      if (masteredSet.has(currentIdx)) {
        showStatus("Prompt already marked mastered.");
        return;
      }

      masteredSet.add(currentIdx);
      safeWrite(STORAGE.mastered, [...masteredSet]);
      showStatus("Prompt marked mastered.");
      pickPrompt();
    }

    function resetDeck() {
      masteredSet.clear();
      cardStats = prompts.map(() => defaultCard());
      safeWrite(STORAGE.mastered, []);
      safeWrite(STORAGE.cards, cardStats);
      pickPrompt();
      showStatus("Deck and adaptive stats reset.");
    }

    function updateChecklistProgress() {
      const completed = checks.filter(Boolean).length;
      const pct = Math.round((completed / dailyChecks.length) * 100);
      progressPct.textContent = `${pct}% complete`;
      progressText.textContent = `${completed} of ${dailyChecks.length} checklist targets done`;
      progressFill.style.width = `${pct}%`;
      updateMissionControl();
    }

    function renderChecks() {
      checklist.innerHTML = "";
      dailyChecks.forEach((txt, idx) => {
        const row = document.createElement("label");
        row.className = "check";

        const box = document.createElement("input");
        box.type = "checkbox";
        box.checked = !!checks[idx];
        box.addEventListener("change", () => {
          checks[idx] = box.checked;
          safeWrite(STORAGE.checks, checks);
          updateChecklistProgress();
        });

        const span = document.createElement("span");
        span.textContent = txt;

        row.appendChild(box);
        row.appendChild(span);
        checklist.appendChild(row);
      });
      updateChecklistProgress();
    }

    function resetChecklist() {
      checks = Array(dailyChecks.length).fill(false);
      safeWrite(STORAGE.checks, checks);
      renderChecks();
      showStatus("Checklist reset.");
    }

    const resourceCards = [...resourceGrid.querySelectorAll(".resource")];

    function applyResourceFilter() {
      const q = resourceFilter.value.trim().toLowerCase();
      let visible = 0;
      resourceCards.forEach((card) => {
        const hay = `${card.textContent} ${card.dataset.tags || ""}`.toLowerCase();
        const match = !q || hay.includes(q);
        card.style.display = match ? "grid" : "none";
        if (match) visible += 1;
      });
      resourceCount.textContent = `${visible} resource${visible === 1 ? "" : "s"}`;
    }

    function formatTime(totalSeconds) {
      const mins = Math.floor(totalSeconds / 60);
      const secs = totalSeconds % 60;
      return `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
    }

    function setTimerStatus(message, level = "") {
      timerStatus.textContent = message;
      timerStatus.className = `timer-status${level ? ` ${level}` : ""}`;
    }

    function renderTimer() {
      timerDisplay.textContent = formatTime(timerSeconds);
    }

    function stopTimer() {
      if (timerId) {
        window.clearInterval(timerId);
        timerId = null;
      }
    }

    function resetTimerFromInput() {
      let mins = Number.parseInt(timerMinutes.value, 10);
      if (!Number.isFinite(mins) || mins < 1) mins = 75;
      mins = Math.min(240, Math.max(1, mins));
      timerMinutes.value = String(mins);
      safeWrite(STORAGE.minutes, mins);
      timerSeconds = mins * 60;
      stopTimer();
      renderTimer();
      setTimerStatus("Ready. Set minutes, then start.");
    }

    function tickTimer() {
      if (timerSeconds <= 0) {
        stopTimer();
        setTimerStatus("Time is up.", "danger");
        return;
      }
      timerSeconds -= 1;
      renderTimer();

      if (timerSeconds === 5 * 60) setTimerStatus("5 minutes remaining.", "warn");
      if (timerSeconds === 60) setTimerStatus("1 minute remaining.", "danger");
      if (timerSeconds === 0) {
        stopTimer();
        setTimerStatus("Time is up.", "danger");
      }
    }

    function startTimer() {
      if (timerId) return;
      if (timerSeconds <= 0) resetTimerFromInput();
      setTimerStatus("Timer running.");
      timerId = window.setInterval(tickTimer, 1000);
    }

    function pauseTimer() {
      if (!timerId) {
        setTimerStatus("Timer is already paused.");
        return;
      }
      stopTimer();
      setTimerStatus("Paused.");
    }

    function sanitizeMarketLabState(raw) {
      if (!raw || typeof raw !== "object") return { ...LAB_DEFAULT_STATE };
      const policy = raw.policy === "ceiling" || raw.policy === "floor" ? raw.policy : "none";
      const demandShift = clamp(Number.parseInt(raw.demandShift, 10) || 0, -40, 40);
      const supplyShift = clamp(Number.parseInt(raw.supplyShift, 10) || 0, -40, 40);
      const controlPrice = clamp(Number.parseFloat(raw.controlPrice) || 22, 2, 46);
      return { demandShift, supplyShift, policy, controlPrice };
    }

    function persistMarketLabState() {
      safeWrite(STORAGE.marketLab, marketLabState);
    }

    function qToX(quantity) {
      const usableWidth = LAB_CHART.width - LAB_CHART.marginLeft - LAB_CHART.marginRight;
      return LAB_CHART.marginLeft + (clamp(quantity, 0, LAB_CHART.qMax) / LAB_CHART.qMax) * usableWidth;
    }

    function pToY(price) {
      const usableHeight = LAB_CHART.height - LAB_CHART.marginTop - LAB_CHART.marginBottom;
      return LAB_CHART.height - LAB_CHART.marginBottom - (clamp(price, 0, LAB_CHART.pMax) / LAB_CHART.pMax) * usableHeight;
    }

    function buildMarketGrid() {
      if (!marketGrid) return;
      marketGrid.innerHTML = "";
      const NS = "http://www.w3.org/2000/svg";
      const pStep = 10;
      const qStep = 20;

      for (let p = 0; p <= LAB_CHART.pMax; p += pStep) {
        const y = pToY(p);
        const line = document.createElementNS(NS, "line");
        line.setAttribute("x1", String(LAB_CHART.marginLeft));
        line.setAttribute("x2", String(LAB_CHART.width - LAB_CHART.marginRight));
        line.setAttribute("y1", String(y));
        line.setAttribute("y2", String(y));
        line.setAttribute("stroke", p === 0 ? "#8f7d69" : "#eadfce");
        line.setAttribute("stroke-width", p === 0 ? "1.2" : "1");
        marketGrid.appendChild(line);

        if (p > 0) {
          const label = document.createElementNS(NS, "text");
          label.setAttribute("x", String(LAB_CHART.marginLeft - 10));
          label.setAttribute("y", String(y + 4));
          label.setAttribute("fill", "#7d6b58");
          label.setAttribute("font-size", "11");
          label.setAttribute("text-anchor", "end");
          label.textContent = String(p);
          marketGrid.appendChild(label);
        }
      }

      for (let q = 0; q <= LAB_CHART.qMax; q += qStep) {
        const x = qToX(q);
        const line = document.createElementNS(NS, "line");
        line.setAttribute("x1", String(x));
        line.setAttribute("x2", String(x));
        line.setAttribute("y1", String(LAB_CHART.marginTop));
        line.setAttribute("y2", String(LAB_CHART.height - LAB_CHART.marginBottom));
        line.setAttribute("stroke", q === 0 ? "#8f7d69" : "#efe3d1");
        line.setAttribute("stroke-width", q === 0 ? "1.2" : "1");
        marketGrid.appendChild(line);

        if (q > 0) {
          const label = document.createElementNS(NS, "text");
          label.setAttribute("x", String(x));
          label.setAttribute("y", String(LAB_CHART.height - LAB_CHART.marginBottom + 16));
          label.setAttribute("fill", "#7d6b58");
          label.setAttribute("font-size", "11");
          label.setAttribute("text-anchor", "middle");
          label.textContent = String(q);
          marketGrid.appendChild(label);
        }
      }
    }

    function computeMarketState() {
      const A_D = LAB_MODEL.baseDemand + marketLabState.demandShift;
      const A_S = LAB_MODEL.baseSupply + marketLabState.supplyShift;
      const b = LAB_MODEL.demandSlope;
      const d = LAB_MODEL.supplySlope;
      const pStar = (A_D - A_S) / (b + d);
      const qStar = A_D - b * pStar;
      const pBase = (LAB_MODEL.baseDemand - LAB_MODEL.baseSupply) / (b + d);
      const qBase = LAB_MODEL.baseDemand - b * pBase;
      const pControl = marketLabState.controlPrice;
      const qdAtPc = A_D - b * pControl;
      const qsAtPc = A_S + d * pControl;
      const gap = Math.abs(qdAtPc - qsAtPc);
      let policyStatus = "No control";
      let policyGap = "n/a";
      let binding = false;
      let gapType = "none";

      if (marketLabState.policy === "ceiling") {
        binding = pControl < pStar;
        if (binding) {
          gapType = "shortage";
          policyStatus = `Binding ceiling at ${pControl.toFixed(1)}`;
          policyGap = `${gap.toFixed(2)} shortage`;
        } else {
          policyStatus = `Non-binding ceiling at ${pControl.toFixed(1)}`;
          policyGap = "0.00";
        }
      } else if (marketLabState.policy === "floor") {
        binding = pControl > pStar;
        if (binding) {
          gapType = "surplus";
          policyStatus = `Binding floor at ${pControl.toFixed(1)}`;
          policyGap = `${gap.toFixed(2)} surplus`;
        } else {
          policyStatus = `Non-binding floor at ${pControl.toFixed(1)}`;
          policyGap = "0.00";
        }
      }

      return {
        A_D,
        A_S,
        b,
        d,
        pStar,
        qStar,
        pBase,
        qBase,
        pControl,
        qdAtPc,
        qsAtPc,
        gap,
        policyStatus,
        policyGap,
        binding,
        gapType
      };
    }

    function formatShift(n) {
      if (n > 0) return `+${n}`;
      return String(n);
    }

    function buildMarketNarrative(state) {
      const demandView = state.A_D > LAB_MODEL.baseDemand
        ? "Demand shifted right."
        : (state.A_D < LAB_MODEL.baseDemand ? "Demand shifted left." : "Demand unchanged.");
      const supplyView = state.A_S > LAB_MODEL.baseSupply
        ? "Supply shifted right."
        : (state.A_S < LAB_MODEL.baseSupply ? "Supply shifted left." : "Supply unchanged.");

      const pMove = state.pStar > state.pBase + 0.15
        ? "equilibrium price rises"
        : (state.pStar < state.pBase - 0.15 ? "equilibrium price falls" : "equilibrium price is roughly unchanged");
      const qMove = state.qStar > state.qBase + 0.15
        ? "equilibrium quantity rises"
        : (state.qStar < state.qBase - 0.15 ? "equilibrium quantity falls" : "equilibrium quantity is roughly unchanged");

      let policyLine = "No policy distortion in this scenario.";
      if (marketLabState.policy === "ceiling") {
        policyLine = state.binding
          ? `The ceiling binds, creating a shortage of ${state.gap.toFixed(2)} units at \\(P_c\\).`
          : "The ceiling is non-binding, so market outcome remains at equilibrium.";
      } else if (marketLabState.policy === "floor") {
        policyLine = state.binding
          ? `The floor binds, creating a surplus of ${state.gap.toFixed(2)} units at \\(P_c\\).`
          : "The floor is non-binding, so market outcome remains at equilibrium.";
      }

      return `${demandView} ${supplyView} Relative to baseline, ${pMove} and ${qMove}. ${policyLine}`;
    }

    function renderMarketChart(state) {
      if (!marketSvg) return;
      const pTop = LAB_CHART.pMax;
      const qDAtZero = state.A_D;
      const qDAtTop = state.A_D - state.b * pTop;
      const qSAtZero = state.A_S;
      const qSAtTop = state.A_S + state.d * pTop;

      marketDemandPath.setAttribute(
        "d",
        `M ${qToX(qDAtZero)} ${pToY(0)} L ${qToX(qDAtTop)} ${pToY(pTop)}`
      );
      marketSupplyPath.setAttribute(
        "d",
        `M ${qToX(qSAtZero)} ${pToY(0)} L ${qToX(qSAtTop)} ${pToY(pTop)}`
      );

      marketDemandLabel.setAttribute("x", String(qToX(state.A_D - state.b * 38) + 8));
      marketDemandLabel.setAttribute("y", String(pToY(38) - 5));
      marketSupplyLabel.setAttribute("x", String(qToX(state.A_S + state.d * 38) + 8));
      marketSupplyLabel.setAttribute("y", String(pToY(38) - 5));

      const eqX = qToX(state.qStar);
      const eqY = pToY(state.pStar);
      marketEqPoint.setAttribute("cx", String(eqX));
      marketEqPoint.setAttribute("cy", String(eqY));
      marketEqLabel.setAttribute("x", String(eqX + 8));
      marketEqLabel.setAttribute("y", String(eqY - 8));
      marketEqPriceLine.setAttribute("x1", String(LAB_CHART.marginLeft));
      marketEqPriceLine.setAttribute("x2", String(eqX));
      marketEqPriceLine.setAttribute("y1", String(eqY));
      marketEqPriceLine.setAttribute("y2", String(eqY));
      marketEqQtyLine.setAttribute("x1", String(eqX));
      marketEqQtyLine.setAttribute("x2", String(eqX));
      marketEqQtyLine.setAttribute("y1", String(eqY));
      marketEqQtyLine.setAttribute("y2", String(pToY(0)));

      const showPolicy = marketLabState.policy !== "none";
      const policyOpacity = showPolicy ? "1" : "0";
      const policyY = pToY(state.pControl);
      const qdX = qToX(state.qdAtPc);
      const qsX = qToX(state.qsAtPc);
      marketPolicyLine.setAttribute("opacity", policyOpacity);
      marketQdLine.setAttribute("opacity", policyOpacity);
      marketQsLine.setAttribute("opacity", policyOpacity);
      marketPcLabel.setAttribute("opacity", policyOpacity);
      marketQdLabel.setAttribute("opacity", policyOpacity);
      marketQsLabel.setAttribute("opacity", policyOpacity);

      if (showPolicy) {
        marketPolicyLine.setAttribute("y1", String(policyY));
        marketPolicyLine.setAttribute("y2", String(policyY));
        marketQdLine.setAttribute("x1", String(qdX));
        marketQdLine.setAttribute("x2", String(qdX));
        marketQdLine.setAttribute("y1", String(policyY));
        marketQdLine.setAttribute("y2", String(pToY(0)));
        marketQsLine.setAttribute("x1", String(qsX));
        marketQsLine.setAttribute("x2", String(qsX));
        marketQsLine.setAttribute("y1", String(policyY));
        marketQsLine.setAttribute("y2", String(pToY(0)));
        marketPcLabel.setAttribute("x", String(LAB_CHART.marginLeft + 8));
        marketPcLabel.setAttribute("y", String(policyY - 6));
        marketQdLabel.setAttribute("x", String(qdX + 6));
        marketQdLabel.setAttribute("y", String(pToY(0) + 18));
        marketQsLabel.setAttribute("x", String(qsX + 6));
        marketQsLabel.setAttribute("y", String(pToY(0) + 34));
      }
    }

    function updateMarketLab() {
      if (!labDemandShift || !labSupplyShift || !labPolicyType || !labControlPrice) return;
      marketLabState = {
        demandShift: clamp(Number.parseInt(labDemandShift.value, 10) || 0, -40, 40),
        supplyShift: clamp(Number.parseInt(labSupplyShift.value, 10) || 0, -40, 40),
        policy: labPolicyType.value,
        controlPrice: clamp(Number.parseFloat(labControlPrice.value) || 22, 2, 46)
      };

      labDemandShiftVal.textContent = formatShift(marketLabState.demandShift);
      labSupplyShiftVal.textContent = formatShift(marketLabState.supplyShift);
      labControlPriceVal.textContent = marketLabState.controlPrice.toFixed(1);

      persistMarketLabState();
      const state = computeMarketState();
      renderMarketChart(state);

      labEqPrice.textContent = state.pStar.toFixed(2);
      labEqQty.textContent = state.qStar.toFixed(2);
      labPolicyStatus.textContent = state.policyStatus;
      labGap.textContent = state.policyGap;

      labNarrative.innerHTML = buildMarketNarrative(state);
      typesetMath(labNarrative);
    }

    function applyMarketPreset(name) {
      if (!labDemandShift || !labSupplyShift || !labPolicyType || !labControlPrice) return;
      if (name === "demand_surge") {
        labDemandShift.value = "24";
        labSupplyShift.value = "0";
        labPolicyType.value = "none";
        labControlPrice.value = "22";
      } else if (name === "supply_shock") {
        labDemandShift.value = "0";
        labSupplyShift.value = "-24";
        labPolicyType.value = "none";
        labControlPrice.value = "22";
      } else if (name === "ceiling_bind") {
        labDemandShift.value = "16";
        labSupplyShift.value = "-8";
        labPolicyType.value = "ceiling";
        labControlPrice.value = "20";
      } else if (name === "floor_bind") {
        labDemandShift.value = "-14";
        labSupplyShift.value = "10";
        labPolicyType.value = "floor";
        labControlPrice.value = "30";
      } else {
        labDemandShift.value = String(LAB_DEFAULT_STATE.demandShift);
        labSupplyShift.value = String(LAB_DEFAULT_STATE.supplyShift);
        labPolicyType.value = LAB_DEFAULT_STATE.policy;
        labControlPrice.value = String(LAB_DEFAULT_STATE.controlPrice);
      }
      updateMarketLab();
      showStatus("Market lab preset applied.");
    }

    function initMarketLab() {
      if (!marketSvg) return;
      buildMarketGrid();
      const stored = sanitizeMarketLabState(safeRead(STORAGE.marketLab, null));
      marketLabState = { ...stored };

      labDemandShift.value = String(marketLabState.demandShift);
      labSupplyShift.value = String(marketLabState.supplyShift);
      labPolicyType.value = marketLabState.policy;
      labControlPrice.value = String(marketLabState.controlPrice);

      labDemandShift.addEventListener("input", updateMarketLab);
      labSupplyShift.addEventListener("input", updateMarketLab);
      labPolicyType.addEventListener("change", updateMarketLab);
      labControlPrice.addEventListener("input", updateMarketLab);
      labPresetBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          applyMarketPreset(btn.dataset.preset || "reset");
        });
      });

      updateMarketLab();
    }

    function sanitizeMacroLinkState(raw) {
      const base = { ...MACRO_LINK_DEFAULT_STATE };
      if (!raw || typeof raw !== "object") return base;
      const layoutMode = raw.layoutMode === "1x2" ? "1x2" : "2x2";
      const pairMode = raw.pairMode in MACRO_LINK_LAYOUTS && raw.pairMode !== "2x2"
        ? raw.pairMode
        : base.pairMode;
      return {
        demandShift: clamp(Number.parseInt(raw.demandShift, 10) || 0, -40, 40),
        supplyShift: clamp(Number.parseInt(raw.supplyShift, 10) || 0, -30, 30),
        moneySupplyShift: clamp(Number.parseInt(raw.moneySupplyShift, 10) || 0, -40, 40),
        moneyDemandShift: clamp(Number.parseInt(raw.moneyDemandShift, 10) || 0, -40, 40),
        savingShift: clamp(Number.parseInt(raw.savingShift, 10) || 0, -30, 30),
        investmentShift: clamp(Number.parseInt(raw.investmentShift, 10) || 0, -30, 30),
        expectedInflation: clamp(Number.parseFloat(raw.expectedInflation) || 2, -1, 10),
        layoutMode,
        pairMode
      };
    }

    function persistMacroLinkState() {
      safeWrite(STORAGE.macroLink, macroLinkState);
    }

    function macroMotionReduced() {
      return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
    }

    function macroEaseInOutQuad(t) {
      return t < 0.5
        ? (2 * t * t)
        : (1 - (Math.pow(-2 * t + 2, 2) / 2));
    }

    function macroInterpolateNumber(start, end, t) {
      return start + ((end - start) * t);
    }

    function macroInterpolateCore(start, end, t) {
      const frame = {};
      Object.keys(end).forEach((key) => {
        const fromValue = start[key];
        const toValue = end[key];
        if (typeof fromValue === "number" && typeof toValue === "number" && Number.isFinite(fromValue) && Number.isFinite(toValue)) {
          frame[key] = macroInterpolateNumber(fromValue, toValue, t);
        } else {
          frame[key] = toValue;
        }
      });
      return frame;
    }

    function macroInterpolateState(start, end, t) {
      return {
        baseline: macroInterpolateCore(start.baseline, end.baseline, t),
        current: macroInterpolateCore(start.current, end.current, t)
      };
    }

    function macroInputDeltaMagnitude(prevInput, nextInput) {
      const prev = sanitizeMacroLinkState(prevInput);
      const next = sanitizeMacroLinkState(nextInput);
      const expectedInflationDelta = Math.abs(next.expectedInflation - prev.expectedInflation) * 7;
      const shiftDelta = MACRO_INPUT_NUMERIC_KEYS
        .filter((key) => key !== "expectedInflation")
        .reduce((sum, key) => sum + Math.abs((next[key] || 0) - (prev[key] || 0)), 0);
      return shiftDelta + expectedInflationDelta;
    }

    function resizeMacroParticleCanvas() {
      if (!macroParticleCanvas) return;
      const rect = macroParticleCanvas.getBoundingClientRect();
      const width = Math.max(1, Math.round(rect.width));
      const height = Math.max(1, Math.round(rect.height));
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const pixelWidth = Math.round(width * dpr);
      const pixelHeight = Math.round(height * dpr);
      if (macroParticleCanvas.width !== pixelWidth || macroParticleCanvas.height !== pixelHeight) {
        macroParticleCanvas.width = pixelWidth;
        macroParticleCanvas.height = pixelHeight;
      }
      if (!macroParticleCtx) {
        macroParticleCtx = macroParticleCanvas.getContext("2d");
      }
      if (!macroParticleCtx) return;
      macroParticleCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      macroParticleCtx.clearRect(0, 0, width, height);
    }

    function clearMacroParticleCanvas() {
      if (!macroParticleCanvas || !macroParticleCtx) return;
      const width = Math.max(1, Math.round(macroParticleCanvas.width / Math.max(1, window.devicePixelRatio || 1)));
      const height = Math.max(1, Math.round(macroParticleCanvas.height / Math.max(1, window.devicePixelRatio || 1)));
      macroParticleCtx.clearRect(0, 0, width, height);
    }

    function stopMacroParticleLoop(clear = false) {
      if (macroParticleFrame) {
        window.cancelAnimationFrame(macroParticleFrame);
        macroParticleFrame = null;
      }
      macroParticleLastTs = 0;
      if (clear) {
        macroParticles = [];
        clearMacroParticleCanvas();
      }
    }

    function renderMacroParticlesFrame(ts) {
      if (!macroParticleCanvas || !macroParticleCtx || !macroParticles.length) {
        stopMacroParticleLoop(true);
        return;
      }
      const dt = macroParticleLastTs ? Math.min(34, ts - macroParticleLastTs) : 16;
      macroParticleLastTs = ts;
      const width = Math.max(1, Math.round(macroParticleCanvas.width / Math.max(1, window.devicePixelRatio || 1)));
      const height = Math.max(1, Math.round(macroParticleCanvas.height / Math.max(1, window.devicePixelRatio || 1)));
      macroParticleCtx.clearRect(0, 0, width, height);

      const nextParticles = [];
      macroParticles.forEach((particle) => {
        const life = particle.life + dt;
        const ratio = life / particle.ttl;
        if (ratio >= 1) return;
        const drag = Math.max(0.93, 1 - (0.0017 * dt));
        const vx = particle.vx * drag;
        const vy = (particle.vy * drag) + (0.003 * dt);
        const x = particle.x + (vx * dt * 0.065);
        const y = particle.y + (vy * dt * 0.065);
        const alpha = particle.alpha * Math.pow(1 - ratio, 1.1);

        macroParticleCtx.beginPath();
        macroParticleCtx.fillStyle = `rgba(${particle.color[0]}, ${particle.color[1]}, ${particle.color[2]}, ${alpha.toFixed(4)})`;
        macroParticleCtx.arc(x, y, particle.size, 0, Math.PI * 2);
        macroParticleCtx.fill();

        nextParticles.push({
          ...particle,
          x,
          y,
          vx,
          vy,
          life
        });
      });

      macroParticles = nextParticles;
      if (!macroParticles.length) {
        stopMacroParticleLoop(true);
        return;
      }
      macroParticleFrame = window.requestAnimationFrame(renderMacroParticlesFrame);
    }

    function startMacroParticleLoop() {
      if (macroParticleFrame) return;
      macroParticleFrame = window.requestAnimationFrame(renderMacroParticlesFrame);
    }

    function spawnMacroParticles(fromState, toState, intensity = 0) {
      if (!macroParticleCanvas || macroMotionReduced() || intensity < MACRO_ANIMATION.particleThreshold) return;
      resizeMacroParticleCanvas();
      if (!macroParticleCtx) return;

      const canvasRect = macroParticleCanvas.getBoundingClientRect();
      if (canvasRect.width < 10 || canvasRect.height < 10) return;
      const visibleCards = macroChartCards.filter((card) => !card.classList.contains("hidden"));
      if (!visibleCards.length) return;

      const sourceState = fromState || toState;
      const outputDelta = toState.current.yEq - sourceState.current.yEq;
      const inflationDelta = toState.current.piActual - sourceState.current.piActual;
      const rateDelta = toState.current.iEq - sourceState.current.iEq;
      const biasX = Math.sign(outputDelta || 0);
      const biasY = -Math.sign(inflationDelta || 0);
      const warmPalette = [[205, 58, 58], [224, 141, 75], [255, 213, 120]];
      const coolPalette = [[29, 104, 134], [66, 150, 178], [142, 199, 212]];
      const palette = inflationDelta >= 0 ? warmPalette : coolPalette;
      const particlesPerCard = clamp(Math.round(5 + (intensity / 6)), 6, 14);

      const burst = [];
      visibleCards.forEach((card) => {
        const cardRect = card.getBoundingClientRect();
        const originX = (cardRect.left - canvasRect.left) + (cardRect.width / 2);
        const originY = (cardRect.top - canvasRect.top) + (cardRect.height / 2.1);
        for (let i = 0; i < particlesPerCard; i += 1) {
          const speed = 0.12 + (Math.random() * 0.5) + (intensity * 0.004);
          const angle = (Math.random() * Math.PI * 2) + (biasX * 0.32) - (biasY * 0.14);
          const color = randomChoice(palette);
          burst.push({
            x: originX + ((Math.random() - 0.5) * 20),
            y: originY + ((Math.random() - 0.5) * 16),
            vx: (Math.cos(angle) * speed) + (biasX * 0.35) + (Math.sign(rateDelta || 0) * 0.08),
            vy: (Math.sin(angle) * speed) + (biasY * 0.18),
            size: 1.4 + (Math.random() * 2.4),
            alpha: 0.3 + (Math.random() * 0.34),
            ttl: 460 + (Math.random() * 430),
            life: 0,
            color
          });
        }
      });

      macroParticles = macroParticles.concat(burst).slice(-280);
      startMacroParticleLoop();
    }

    function flashMacroShiftCards(intensity = 0) {
      if (!macroChartCards.length || macroMotionReduced() || intensity < MACRO_ANIMATION.particleThreshold) return;
      macroChartCards.forEach((card) => {
        if (!card.classList.contains("hidden")) {
          card.classList.add("shift-active");
        }
      });
      if (macroChartFlashTimer) {
        window.clearTimeout(macroChartFlashTimer);
      }
      const duration = clamp(260 + (intensity * 8), 300, 760);
      macroChartFlashTimer = window.setTimeout(() => {
        macroChartCards.forEach((card) => card.classList.remove("shift-active"));
      }, duration);
    }

    function macroMapX(value, axis) {
      const usable = MACRO_CHART.width - MACRO_CHART.marginLeft - MACRO_CHART.marginRight;
      return MACRO_CHART.marginLeft + ((clamp(value, axis.min, axis.max) - axis.min) / (axis.max - axis.min)) * usable;
    }

    function macroMapY(value, axis) {
      const usable = MACRO_CHART.height - MACRO_CHART.marginTop - MACRO_CHART.marginBottom;
      return MACRO_CHART.height - MACRO_CHART.marginBottom - ((clamp(value, axis.min, axis.max) - axis.min) / (axis.max - axis.min)) * usable;
    }

    function macroPathFromXFunction(xAxis, yAxis, fnY) {
      const xLo = xAxis.min;
      const xHi = xAxis.max;
      return `M ${macroMapX(xLo, xAxis)} ${macroMapY(fnY(xLo), yAxis)} L ${macroMapX(xHi, xAxis)} ${macroMapY(fnY(xHi), yAxis)}`;
    }

    function macroPathFromYFunction(yAxis, xAxis, fnX) {
      const yLo = yAxis.min;
      const yHi = yAxis.max;
      return `M ${macroMapX(fnX(yLo), xAxis)} ${macroMapY(yLo, yAxis)} L ${macroMapX(fnX(yHi), xAxis)} ${macroMapY(yHi, yAxis)}`;
    }

    function setSvgLine(node, x1, y1, x2, y2) {
      if (!node) return;
      node.setAttribute("x1", String(x1));
      node.setAttribute("y1", String(y1));
      node.setAttribute("x2", String(x2));
      node.setAttribute("y2", String(y2));
    }

    function setSvgPoint(node, x, y) {
      if (!node) return;
      node.setAttribute("cx", String(x));
      node.setAttribute("cy", String(y));
    }

    function setSvgText(node, x, y, text) {
      if (!node) return;
      node.setAttribute("x", String(x));
      node.setAttribute("y", String(y));
      node.textContent = text;
    }

    function buildMacroGrid(node, xAxis, yAxis) {
      if (!node || node.dataset.ready === "1") return;
      for (let i = 1; i <= 4; i += 1) {
        const xVal = xAxis.min + ((xAxis.max - xAxis.min) * i) / 5;
        const yVal = yAxis.min + ((yAxis.max - yAxis.min) * i) / 5;
        const vLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        vLine.setAttribute("x1", String(macroMapX(xVal, xAxis)));
        vLine.setAttribute("y1", String(macroMapY(yAxis.min, yAxis)));
        vLine.setAttribute("x2", String(macroMapX(xVal, xAxis)));
        vLine.setAttribute("y2", String(macroMapY(yAxis.max, yAxis)));
        vLine.setAttribute("stroke", "#eadcc9");
        vLine.setAttribute("stroke-width", "1");
        node.appendChild(vLine);

        const hLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        hLine.setAttribute("x1", String(macroMapX(xAxis.min, xAxis)));
        hLine.setAttribute("y1", String(macroMapY(yVal, yAxis)));
        hLine.setAttribute("x2", String(macroMapX(xAxis.max, xAxis)));
        hLine.setAttribute("y2", String(macroMapY(yVal, yAxis)));
        hLine.setAttribute("stroke", "#eadcc9");
        hLine.setAttribute("stroke-width", "1");
        node.appendChild(hLine);
      }
      node.dataset.ready = "1";
    }

    function computeMacroLinkCore(input) {
      const adSlope = 0.62;
      const srasSlope = 0.47;
      const adIntercept = 166
        + (0.75 * input.demandShift)
        + (0.45 * input.moneySupplyShift)
        - (0.3 * input.moneyDemandShift)
        + (0.2 * input.investmentShift)
        - (0.12 * input.savingShift);
      const srasIntercept = 36
        - (0.85 * input.supplyShift)
        + (0.15 * input.expectedInflation);

      let yEq = (adIntercept - srasIntercept) / (adSlope + srasSlope);
      yEq = clamp(yEq, MACRO_AXIS.adasY.min + 1, MACRO_AXIS.adasY.max - 1);
      let pEq = srasIntercept + (srasSlope * yEq);
      pEq = clamp(pEq, MACRO_AXIS.adasP.min + 0.5, MACRO_AXIS.adasP.max - 0.5);
      const yPotential = clamp(100 + (0.5 * input.supplyShift), MACRO_AXIS.adasY.min + 3, MACRO_AXIS.adasY.max - 3);
      const outputGap = yEq - yPotential;

      const ms = clamp(
        110 + input.moneySupplyShift + (0.1 * input.demandShift),
        MACRO_AXIS.moneyQ.min + 2,
        MACRO_AXIS.moneyQ.max - 2
      );
      const mdSlope = 4.2;
      const mdIntercept = 156
        + (0.6 * outputGap)
        + input.moneyDemandShift
        + (0.12 * input.demandShift);
      let iEq = (mdIntercept - ms) / mdSlope;
      iEq = clamp(iEq, MACRO_AXIS.moneyI.min, MACRO_AXIS.moneyI.max);
      const moneyEqQ = ms;

      const savingSlope = 5;
      const investSlope = 5.4;
      const savingIntercept = 92
        + input.savingShift
        - (0.5 * input.demandShift)
        + (0.25 * input.supplyShift)
        + (0.1 * outputGap);
      const investIntercept = 122
        + input.investmentShift
        + (0.38 * input.demandShift)
        + (0.22 * input.moneyDemandShift);
      let rEq = (investIntercept - savingIntercept) / (savingSlope + investSlope);
      rEq = clamp(rEq, MACRO_AXIS.lfR.min, MACRO_AXIS.lfR.max);
      const lfEqQ = clamp(
        savingIntercept + (savingSlope * rEq),
        MACRO_AXIS.lfQ.min + 1,
        MACRO_AXIS.lfQ.max - 1
      );

      const uNatural = clamp(4.8 - (0.03 * input.supplyShift), 3.2, 6.5);
      const unemployment = clamp(uNatural - (0.08 * outputGap), MACRO_AXIS.pcU.min, MACRO_AXIS.pcU.max);
      const pcSlope = 0.8;
      const costPush = (-0.07 * input.supplyShift) + (0.05 * input.moneyDemandShift);
      const piActual = clamp(
        input.expectedInflation - (pcSlope * (unemployment - uNatural)) + costPush,
        MACRO_AXIS.pcPi.min,
        MACRO_AXIS.pcPi.max
      );

      const impliedRealFromMoney = iEq - input.expectedInflation;
      const rateGap = impliedRealFromMoney - rEq;

      return {
        adSlope,
        srasSlope,
        adIntercept,
        srasIntercept,
        yEq,
        pEq,
        yPotential,
        outputGap,
        ms,
        mdSlope,
        mdIntercept,
        iEq,
        moneyEqQ,
        savingSlope,
        savingIntercept,
        investSlope,
        investIntercept,
        rEq,
        lfEqQ,
        uNatural,
        unemployment,
        pcSlope,
        costPush,
        piActual,
        expectedInflation: input.expectedInflation,
        impliedRealFromMoney,
        rateGap
      };
    }

    function computeMacroLinkState(inputState = macroLinkState) {
      const safeInput = sanitizeMacroLinkState(inputState);
      const baseline = computeMacroLinkCore({
        ...MACRO_LINK_DEFAULT_STATE,
        expectedInflation: safeInput.expectedInflation
      });
      const current = computeMacroLinkCore(safeInput);
      return { baseline, current };
    }

    function renderMacroLayout() {
      if (!macroChartGrid || !macroChartCards.length) return;
      const layoutMode = macroLinkState.layoutMode === "1x2" ? "1x2" : "2x2";
      macroChartGrid.dataset.layout = layoutMode;
      const visible = layoutMode === "1x2"
        ? (MACRO_LINK_LAYOUTS[macroLinkState.pairMode] || MACRO_LINK_LAYOUTS.adas_money)
        : MACRO_LINK_LAYOUTS["2x2"];
      macroChartCards.forEach((card) => {
        card.classList.toggle("hidden", !visible.includes(card.dataset.chart));
      });
      if (macroPairMode) {
        macroPairMode.disabled = layoutMode !== "1x2";
      }
      if (macroParticleCanvas) {
        window.requestAnimationFrame(resizeMacroParticleCanvas);
      }
    }

    function renderMacroAdas(state) {
      buildMacroGrid(macroAdasGrid, MACRO_AXIS.adasY, MACRO_AXIS.adasP);
      if (macroAdasBaseAd) {
        macroAdasBaseAd.setAttribute("d", macroPathFromXFunction(
          MACRO_AXIS.adasY,
          MACRO_AXIS.adasP,
          (y) => state.baseline.adIntercept - (state.baseline.adSlope * y)
        ));
      }
      if (macroAdasBaseSras) {
        macroAdasBaseSras.setAttribute("d", macroPathFromXFunction(
          MACRO_AXIS.adasY,
          MACRO_AXIS.adasP,
          (y) => state.baseline.srasIntercept + (state.baseline.srasSlope * y)
        ));
      }
      if (macroAdPath) {
        macroAdPath.setAttribute("d", macroPathFromXFunction(
          MACRO_AXIS.adasY,
          MACRO_AXIS.adasP,
          (y) => state.current.adIntercept - (state.current.adSlope * y)
        ));
      }
      if (macroSrasPath) {
        macroSrasPath.setAttribute("d", macroPathFromXFunction(
          MACRO_AXIS.adasY,
          MACRO_AXIS.adasP,
          (y) => state.current.srasIntercept + (state.current.srasSlope * y)
        ));
      }

      const yLo = macroMapY(MACRO_AXIS.adasP.min, MACRO_AXIS.adasP);
      const yHi = macroMapY(MACRO_AXIS.adasP.max, MACRO_AXIS.adasP);
      const baseLrasX = macroMapX(state.baseline.yPotential, MACRO_AXIS.adasY);
      const lrasX = macroMapX(state.current.yPotential, MACRO_AXIS.adasY);
      setSvgLine(macroAdasBaseLras, baseLrasX, yLo, baseLrasX, yHi);
      setSvgLine(macroAdasLras, lrasX, yLo, lrasX, yHi);

      const eqX = macroMapX(state.current.yEq, MACRO_AXIS.adasY);
      const eqY = macroMapY(state.current.pEq, MACRO_AXIS.adasP);
      setSvgPoint(macroAdasEqPoint, eqX, eqY);
      setSvgText(macroAdasEqLabel, eqX + 8, eqY - 7, "E1");
      if (macroAdasTag) {
        macroAdasTag.textContent = state.current.outputGap > 1.2
          ? "Positive Gap"
          : (state.current.outputGap < -1.2 ? "Negative Gap" : "Near Potential");
      }
    }

    function renderMacroMoney(state) {
      buildMacroGrid(macroMoneyGrid, MACRO_AXIS.moneyQ, MACRO_AXIS.moneyI);
      const yMin = macroMapY(MACRO_AXIS.moneyI.min, MACRO_AXIS.moneyI);
      const yMax = macroMapY(MACRO_AXIS.moneyI.max, MACRO_AXIS.moneyI);
      const baseSupplyX = macroMapX(state.baseline.ms, MACRO_AXIS.moneyQ);
      const supplyX = macroMapX(state.current.ms, MACRO_AXIS.moneyQ);
      setSvgLine(macroMoneyBaseSupply, baseSupplyX, yMin, baseSupplyX, yMax);
      setSvgLine(macroMoneySupply, supplyX, yMin, supplyX, yMax);
      if (macroMoneyBaseDemand) {
        macroMoneyBaseDemand.setAttribute("d", macroPathFromYFunction(
          MACRO_AXIS.moneyI,
          MACRO_AXIS.moneyQ,
          (i) => state.baseline.mdIntercept - (state.baseline.mdSlope * i)
        ));
      }
      if (macroMoneyDemand) {
        macroMoneyDemand.setAttribute("d", macroPathFromYFunction(
          MACRO_AXIS.moneyI,
          MACRO_AXIS.moneyQ,
          (i) => state.current.mdIntercept - (state.current.mdSlope * i)
        ));
      }
      const eqX = macroMapX(state.current.moneyEqQ, MACRO_AXIS.moneyQ);
      const eqY = macroMapY(state.current.iEq, MACRO_AXIS.moneyI);
      setSvgPoint(macroMoneyEqPoint, eqX, eqY);
      setSvgText(macroMoneyEqLabel, eqX + 8, eqY - 7, "i1");
      if (macroMoneyTag) {
        macroMoneyTag.textContent = state.current.iEq > state.baseline.iEq + 0.4
          ? "Rate Up"
          : (state.current.iEq < state.baseline.iEq - 0.4 ? "Rate Down" : "Rate Stable");
      }
    }

    function renderMacroLoanable(state) {
      buildMacroGrid(macroLfGrid, MACRO_AXIS.lfQ, MACRO_AXIS.lfR);
      if (macroLfBaseSupply) {
        macroLfBaseSupply.setAttribute("d", macroPathFromYFunction(
          MACRO_AXIS.lfR,
          MACRO_AXIS.lfQ,
          (r) => state.baseline.savingIntercept + (state.baseline.savingSlope * r)
        ));
      }
      if (macroLfBaseDemand) {
        macroLfBaseDemand.setAttribute("d", macroPathFromYFunction(
          MACRO_AXIS.lfR,
          MACRO_AXIS.lfQ,
          (r) => state.baseline.investIntercept - (state.baseline.investSlope * r)
        ));
      }
      if (macroLfSupply) {
        macroLfSupply.setAttribute("d", macroPathFromYFunction(
          MACRO_AXIS.lfR,
          MACRO_AXIS.lfQ,
          (r) => state.current.savingIntercept + (state.current.savingSlope * r)
        ));
      }
      if (macroLfDemand) {
        macroLfDemand.setAttribute("d", macroPathFromYFunction(
          MACRO_AXIS.lfR,
          MACRO_AXIS.lfQ,
          (r) => state.current.investIntercept - (state.current.investSlope * r)
        ));
      }
      const eqX = macroMapX(state.current.lfEqQ, MACRO_AXIS.lfQ);
      const eqY = macroMapY(state.current.rEq, MACRO_AXIS.lfR);
      setSvgPoint(macroLfEqPoint, eqX, eqY);
      setSvgText(macroLfEqLabel, eqX + 8, eqY - 7, "r1");
      if (macroLfTag) {
        macroLfTag.textContent = state.current.rEq > state.baseline.rEq + 0.4
          ? "Crowding-Out"
          : (state.current.rEq < state.baseline.rEq - 0.4 ? "Crowding-In" : "Balanced");
      }
    }

    function renderMacroPhillips(state) {
      buildMacroGrid(macroPcGrid, MACRO_AXIS.pcU, MACRO_AXIS.pcPi);
      if (macroPcBasePath) {
        macroPcBasePath.setAttribute("d", macroPathFromXFunction(
          MACRO_AXIS.pcU,
          MACRO_AXIS.pcPi,
          (u) => state.baseline.expectedInflation - (state.baseline.pcSlope * (u - state.baseline.uNatural)) + state.baseline.costPush
        ));
      }
      if (macroPcPath) {
        macroPcPath.setAttribute("d", macroPathFromXFunction(
          MACRO_AXIS.pcU,
          MACRO_AXIS.pcPi,
          (u) => state.current.expectedInflation - (state.current.pcSlope * (u - state.current.uNatural)) + state.current.costPush
        ));
      }
      const pointX = macroMapX(state.current.unemployment, MACRO_AXIS.pcU);
      const pointY = macroMapY(state.current.piActual, MACRO_AXIS.pcPi);
      setSvgPoint(macroPcPoint, pointX, pointY);
      setSvgText(macroPcLabel, pointX + 8, pointY - 7, "1");
      if (macroPcTag) {
        macroPcTag.textContent = state.current.piActual > state.current.expectedInflation + 0.4
          ? "Inflation Above Expectation"
          : (state.current.piActual < state.current.expectedInflation - 0.4 ? "Inflation Below Expectation" : "Near Expectation");
      }
    }

    function buildMacroNarrative(state) {
      const yMove = state.current.yEq > state.baseline.yEq + 0.8
        ? "Output is above baseline."
        : (state.current.yEq < state.baseline.yEq - 0.8 ? "Output is below baseline." : "Output is near baseline.");
      const pMove = state.current.pEq > state.baseline.pEq + 0.8
        ? "Price pressure is higher."
        : (state.current.pEq < state.baseline.pEq - 0.8 ? "Price pressure is lower." : "Price pressure is broadly stable.");
      const moneyMove = state.current.iEq > state.baseline.iEq + 0.35
        ? "Money market implies tighter nominal rates."
        : (state.current.iEq < state.baseline.iEq - 0.35 ? "Money market implies easier nominal rates." : "Money-market rate is near baseline.");
      const lfMove = state.current.rEq > state.baseline.rEq + 0.35
        ? "Loanable funds indicates stronger crowding-out pressure."
        : (state.current.rEq < state.baseline.rEq - 0.35 ? "Loanable funds indicates stronger crowding-in pressure." : "Loanable-funds real rate is near baseline.");
      const wedge = Math.abs(state.current.rateGap) > 0.85
        ? `Rate wedge is elevated at ${state.current.rateGap.toFixed(2)}, signaling tension between liquidity and saving-investment channels.`
        : `Rate wedge is moderate at ${state.current.rateGap.toFixed(2)}, so channels are broadly aligned.`;
      return `${yMove} ${pMove} ${moneyMove} ${lfMove} ${wedge}`;
    }

    function readMacroLinkControlsIntoState() {
      macroLinkState = sanitizeMacroLinkState({
        demandShift: macroDemandShift ? macroDemandShift.value : macroLinkState.demandShift,
        supplyShift: macroSupplyShift ? macroSupplyShift.value : macroLinkState.supplyShift,
        moneySupplyShift: macroMoneySupplyShift ? macroMoneySupplyShift.value : macroLinkState.moneySupplyShift,
        moneyDemandShift: macroMoneyDemandShift ? macroMoneyDemandShift.value : macroLinkState.moneyDemandShift,
        savingShift: macroSavingShift ? macroSavingShift.value : macroLinkState.savingShift,
        investmentShift: macroInvestmentShift ? macroInvestmentShift.value : macroLinkState.investmentShift,
        expectedInflation: macroExpectedInflation ? macroExpectedInflation.value : macroLinkState.expectedInflation,
        layoutMode: macroLayoutMode ? macroLayoutMode.value : macroLinkState.layoutMode,
        pairMode: macroPairMode ? macroPairMode.value : macroLinkState.pairMode
      });
    }

    function writeMacroLinkStateToControls() {
      if (macroDemandShift) macroDemandShift.value = String(macroLinkState.demandShift);
      if (macroSupplyShift) macroSupplyShift.value = String(macroLinkState.supplyShift);
      if (macroMoneySupplyShift) macroMoneySupplyShift.value = String(macroLinkState.moneySupplyShift);
      if (macroMoneyDemandShift) macroMoneyDemandShift.value = String(macroLinkState.moneyDemandShift);
      if (macroSavingShift) macroSavingShift.value = String(macroLinkState.savingShift);
      if (macroInvestmentShift) macroInvestmentShift.value = String(macroLinkState.investmentShift);
      if (macroExpectedInflation) macroExpectedInflation.value = String(macroLinkState.expectedInflation);
      if (macroLayoutMode) macroLayoutMode.value = macroLinkState.layoutMode;
      if (macroPairMode) macroPairMode.value = macroLinkState.pairMode;
    }

    function updateMacroControlLabels() {
      if (macroDemandShiftVal) macroDemandShiftVal.textContent = formatShift(macroLinkState.demandShift);
      if (macroSupplyShiftVal) macroSupplyShiftVal.textContent = formatShift(macroLinkState.supplyShift);
      if (macroMoneySupplyShiftVal) macroMoneySupplyShiftVal.textContent = formatShift(macroLinkState.moneySupplyShift);
      if (macroMoneyDemandShiftVal) macroMoneyDemandShiftVal.textContent = formatShift(macroLinkState.moneyDemandShift);
      if (macroSavingShiftVal) macroSavingShiftVal.textContent = formatShift(macroLinkState.savingShift);
      if (macroInvestmentShiftVal) macroInvestmentShiftVal.textContent = formatShift(macroLinkState.investmentShift);
      if (macroExpectedInflationVal) macroExpectedInflationVal.textContent = `${macroLinkState.expectedInflation.toFixed(1)}%`;
    }

    function renderMacroMetrics(state) {
      if (macroOutputLevel) macroOutputLevel.textContent = state.current.yEq.toFixed(1);
      if (macroPriceLevel) macroPriceLevel.textContent = state.current.pEq.toFixed(1);
      if (macroNominalRate) macroNominalRate.textContent = `${state.current.iEq.toFixed(2)}%`;
      if (macroRealRate) macroRealRate.textContent = `${state.current.rEq.toFixed(2)}%`;
      if (macroUnemploymentRate) macroUnemploymentRate.textContent = `${state.current.unemployment.toFixed(2)}%`;
      if (macroInflationRate) macroInflationRate.textContent = `${state.current.piActual.toFixed(2)}%`;
      if (macroRateGap) macroRateGap.textContent = state.current.rateGap >= 0
        ? `+${state.current.rateGap.toFixed(2)}`
        : state.current.rateGap.toFixed(2);
      if (macroRegimeTag) {
        if (state.current.outputGap > 1.1 && state.current.piActual > state.current.expectedInflation + 0.4) {
          macroRegimeTag.textContent = "Overheating";
        } else if (state.current.outputGap < -1.1 && state.current.unemployment > state.current.uNatural + 0.4) {
          macroRegimeTag.textContent = "Demand Slump";
        } else if (macroLinkState.supplyShift < -8 && state.current.piActual > state.current.expectedInflation + 0.6) {
          macroRegimeTag.textContent = "Stagflation Risk";
        } else {
          macroRegimeTag.textContent = "Near Potential";
        }
      }
    }

    function cancelMacroTransitionAnimation() {
      if (!macroTransitionFrame) return;
      window.cancelAnimationFrame(macroTransitionFrame);
      macroTransitionFrame = null;
    }

    function renderMacroScene(state) {
      renderMacroAdas(state);
      renderMacroMoney(state);
      renderMacroLoanable(state);
      renderMacroPhillips(state);
      renderMacroMetrics(state);
      if (macroNarrative) {
        macroNarrative.textContent = buildMacroNarrative(state);
      }
    }

    function animateMacroScene(nextState, options = {}) {
      const animate = options.animate !== false;
      const shockMagnitude = Number.isFinite(options.shockMagnitude) ? options.shockMagnitude : 0;
      const burst = options.burst === true || shockMagnitude >= MACRO_ANIMATION.emphasisThreshold;
      const canAnimate = animate && !macroMotionReduced() && !!macroRenderedState;

      cancelMacroTransitionAnimation();

      if (!canAnimate) {
        macroRenderedState = nextState;
        renderMacroScene(nextState);
      } else {
        const startState = macroRenderedState;
        const duration = clamp(
          MACRO_ANIMATION.baselineMs + (shockMagnitude * 8),
          MACRO_ANIMATION.minMs,
          MACRO_ANIMATION.maxMs
        );
        const startTs = performance.now();

        const draw = (ts) => {
          const progress = clamp((ts - startTs) / duration, 0, 1);
          const eased = macroEaseInOutQuad(progress);
          const frameState = macroInterpolateState(startState, nextState, eased);
          macroRenderedState = frameState;
          renderMacroScene(frameState);

          if (progress < 1) {
            macroTransitionFrame = window.requestAnimationFrame(draw);
          } else {
            macroTransitionFrame = null;
            macroRenderedState = nextState;
            renderMacroScene(nextState);
          }
        };
        macroTransitionFrame = window.requestAnimationFrame(draw);
      }

      if (shockMagnitude >= MACRO_ANIMATION.particleThreshold) {
        flashMacroShiftCards(shockMagnitude);
      }
      if (burst) {
        spawnMacroParticles(macroRenderedState || nextState, nextState, Math.max(shockMagnitude, MACRO_ANIMATION.emphasisThreshold));
      } else {
        spawnMacroParticles(macroRenderedState || nextState, nextState, shockMagnitude);
      }
    }

    function updateMacroLinkStudio(readControls = true, options = {}) {
      if (!macroLayoutMode || !macroPairMode || !macroNarrative) return;
      const prevInput = { ...macroLastInputState };
      if (readControls) {
        readMacroLinkControlsIntoState();
      }
      writeMacroLinkStateToControls();
      updateMacroControlLabels();
      renderMacroLayout();
      persistMacroLinkState();

      const nextInput = { ...macroLinkState };
      const shockMagnitude = macroInputDeltaMagnitude(prevInput, nextInput);
      macroLastInputState = nextInput;
      const state = computeMacroLinkState(nextInput);
      animateMacroScene(state, {
        animate: options.animate !== false,
        burst: options.burst === true,
        shockMagnitude
      });
    }

    function applyMacroPreset(name) {
      const next = { ...macroLinkState };
      if (name === "monetary_easing") {
        next.demandShift = 14;
        next.supplyShift = 0;
        next.moneySupplyShift = 24;
        next.moneyDemandShift = -6;
        next.savingShift = 5;
        next.investmentShift = 10;
        next.expectedInflation = 2.8;
      } else if (name === "fiscal_expansion") {
        next.demandShift = 20;
        next.supplyShift = 0;
        next.moneySupplyShift = 0;
        next.moneyDemandShift = 8;
        next.savingShift = -10;
        next.investmentShift = 9;
        next.expectedInflation = 2.4;
      } else if (name === "productivity_boom") {
        next.demandShift = 6;
        next.supplyShift = 18;
        next.moneySupplyShift = 4;
        next.moneyDemandShift = -4;
        next.savingShift = 9;
        next.investmentShift = 7;
        next.expectedInflation = 1.8;
      } else if (name === "stagflation_shock") {
        next.demandShift = -6;
        next.supplyShift = -18;
        next.moneySupplyShift = 2;
        next.moneyDemandShift = 10;
        next.savingShift = -4;
        next.investmentShift = -9;
        next.expectedInflation = 4.2;
      } else if (name === "uncertainty_shock") {
        next.demandShift = -18;
        next.supplyShift = -4;
        next.moneySupplyShift = 6;
        next.moneyDemandShift = 15;
        next.savingShift = 11;
        next.investmentShift = -16;
        next.expectedInflation = 1.9;
      } else {
        Object.assign(next, MACRO_LINK_DEFAULT_STATE);
      }
      macroLinkState = sanitizeMacroLinkState(next);
      writeMacroLinkStateToControls();
      updateMacroLinkStudio(false, { animate: true, burst: true });
      showStatus("Macro transmission preset applied.");
    }

    function initMacroLinkStudio() {
      if (
        !macroLayoutMode
        || !macroPairMode
        || !macroDemandShift
        || !macroSupplyShift
        || !macroMoneySupplyShift
        || !macroMoneyDemandShift
        || !macroSavingShift
        || !macroInvestmentShift
        || !macroExpectedInflation
        || !macroNarrative
        || !macroChartGrid
      ) {
        return;
      }

      macroLinkState = sanitizeMacroLinkState(safeRead(STORAGE.macroLink, null));
      macroLastInputState = { ...macroLinkState };
      writeMacroLinkStateToControls();
      resizeMacroParticleCanvas();
      stopMacroParticleLoop(true);
      window.addEventListener("resize", resizeMacroParticleCanvas);

      [
        macroDemandShift,
        macroSupplyShift,
        macroMoneySupplyShift,
        macroMoneyDemandShift,
        macroSavingShift,
        macroInvestmentShift,
        macroExpectedInflation
      ].forEach((slider) => slider.addEventListener("input", () => updateMacroLinkStudio(true, { animate: true })));

      macroLayoutMode.addEventListener("change", () => updateMacroLinkStudio(true, { animate: false }));
      macroPairMode.addEventListener("change", () => updateMacroLinkStudio(true, { animate: false }));
      macroPresetBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          applyMacroPreset(btn.dataset.macroPreset || "reset");
        });
      });

      updateMacroLinkStudio(false, { animate: false });
    }

    function sanitizeArenaStats(raw) {
      const base = defaultArenaStats();
      if (!raw || typeof raw !== "object") return base;
      const lastType = typeof raw.lastType === "string" && raw.lastType
        ? raw.lastType
        : "-";
      const byType = defaultArenaByType();
      if (raw.byType && typeof raw.byType === "object") {
        ARENA_TYPES.forEach((type) => {
          const item = raw.byType[type];
          if (!item || typeof item !== "object") return;
          const solved = clamp(Number.parseInt(item.solved, 10) || 0, 0, 100000);
          const correct = clamp(Number.parseInt(item.correct, 10) || 0, 0, solved);
          byType[type] = { solved, correct };
        });
      }
      return {
        solved: clamp(Number.parseInt(raw.solved, 10) || 0, 0, 100000),
        correct: clamp(Number.parseInt(raw.correct, 10) || 0, 0, 100000),
        streak: clamp(Number.parseInt(raw.streak, 10) || 0, 0, 10000),
        bestStreak: clamp(Number.parseInt(raw.bestStreak, 10) || 0, 0, 10000),
        lastType,
        byType
      };
    }

    function persistArenaStats() {
      safeWrite(STORAGE.arenaStats, arenaStats);
    }

    function persistArenaPrefs() {
      if (!arenaType || !arenaDifficulty) return;
      safeWrite(STORAGE.arenaPrefs, {
        type: arenaType.value,
        difficulty: arenaDifficulty.value
      });
    }

    function updateArenaStatsUI() {
      if (!arenaSolved) return;
      const accuracyPct = arenaStats.solved
        ? Math.round((arenaStats.correct / arenaStats.solved) * 100)
        : 0;
      arenaSolved.textContent = String(arenaStats.solved);
      arenaCorrect.textContent = String(arenaStats.correct);
      arenaAccuracy.textContent = `${accuracyPct}%`;
      arenaStreak.textContent = String(arenaStats.streak);
      arenaBestStreak.textContent = String(arenaStats.bestStreak);
      arenaLastType.textContent = arenaStats.lastType;
      updateMissionControl();
    }

    function setArenaFeedback(message, tone = "") {
      if (!arenaFeedback) return;
      arenaFeedback.textContent = message;
      arenaFeedback.className = `arena-feedback${tone ? ` ${tone}` : ""}`;
    }

    function formatArenaTime(totalSeconds) {
      const mins = Math.floor(totalSeconds / 60);
      const secs = totalSeconds % 60;
      return `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
    }

    function renderArenaTimer() {
      if (!arenaTimer) return;
      arenaTimer.textContent = formatArenaTime(arenaSeconds);
      arenaTimer.className = "arena-timer";
      if (arenaSeconds <= 20) {
        arenaTimer.classList.add("danger");
      } else if (arenaSeconds <= 45) {
        arenaTimer.classList.add("warn");
      }
    }

    function stopArenaTimer() {
      if (!arenaTimerId) return;
      window.clearInterval(arenaTimerId);
      arenaTimerId = null;
    }

    function markArenaOutcome(correct, feedbackMessage, tone) {
      if (!arenaChallenge || arenaChallenge.graded) {
        if (feedbackMessage) setArenaFeedback(feedbackMessage, tone);
        return;
      }
      arenaChallenge.graded = true;
      stopArenaTimer();

      arenaStats.solved += 1;
      if (!arenaStats.byType || typeof arenaStats.byType !== "object") {
        arenaStats.byType = defaultArenaByType();
      }
      if (!arenaStats.byType[arenaChallenge.type]) {
        arenaStats.byType[arenaChallenge.type] = { solved: 0, correct: 0 };
      }
      arenaStats.byType[arenaChallenge.type].solved += 1;
      if (correct) {
        arenaStats.correct += 1;
        arenaStats.streak += 1;
        arenaStats.bestStreak = Math.max(arenaStats.bestStreak, arenaStats.streak);
        arenaStats.byType[arenaChallenge.type].correct += 1;
      } else {
        arenaStats.streak = 0;
      }
      arenaStats.lastType = ARENA_TYPE_LABELS[arenaChallenge.type] || arenaChallenge.type;
      persistArenaStats();
      updateArenaStatsUI();

      if (feedbackMessage) {
        setArenaFeedback(feedbackMessage, tone);
      }
    }

    function startArenaTimer(seconds) {
      arenaSeconds = Math.max(1, seconds);
      renderArenaTimer();
      stopArenaTimer();
      arenaTimerId = window.setInterval(() => {
        arenaSeconds -= 1;
        renderArenaTimer();
        if (arenaSeconds <= 0) {
          stopArenaTimer();
          if (arenaChallenge && !arenaChallenge.graded) {
            markArenaOutcome(
              false,
              `Time expired. Correct value: ${arenaChallenge.answerDisplay}.`,
              "error"
            );
            showStatus("Arena timeout logged as a miss.");
          }
        }
      }, 1000);
    }

    function randomInt(min, max) {
      const lo = Math.ceil(min);
      const hi = Math.floor(max);
      return Math.floor(Math.random() * (hi - lo + 1)) + lo;
    }

    function randomChoice(items) {
      return items[randomInt(0, items.length - 1)];
    }

    function typeForArena() {
      if (!arenaType) return "gdp";
      if (arenaType.value !== "mixed") return arenaType.value;
      return randomChoice(ARENA_TYPES);
    }

    function generateGDPChallenge(isChallenge) {
      const C = randomInt(isChallenge ? 3600 : 1300, isChallenge ? 14500 : 7200);
      const I = randomInt(isChallenge ? 900 : 220, isChallenge ? 5600 : 2200);
      const G = randomInt(isChallenge ? 1100 : 300, isChallenge ? 5300 : 1900);
      const NX = randomInt(isChallenge ? -1600 : -500, isChallenge ? 900 : 300);
      const answer = C + I + G + NX;
      return {
        type: "gdp",
        answer,
        tolerance: 0.5,
        answerDisplay: answer.toFixed(1),
        promptHtml: `<h3>GDP Spending Identity</h3><p>Given \\(C=${C}\\), \\(I=${I}\\), \\(G=${G}\\), and \\(NX=${NX}\\) (billions), compute \\(Y\\) using \\(Y=C+I+G+NX\\).</p>`,
        solutionHtml: `<p>\\(Y = C + I + G + NX = ${C} + ${I} + ${G} ${NX >= 0 ? "+" : "-"} ${Math.abs(NX)} = ${answer}\\).</p><p><strong>Answer:</strong> \\(${answer}\\) billion.</p>`
      };
    }

    function generateDeflatorChallenge(isChallenge) {
      const defPrev = randomInt(isChallenge ? 92 : 96, isChallenge ? 128 : 118);
      const infl = randomInt(isChallenge ? -4 : -2, isChallenge ? 10 : 7) + (isChallenge ? randomChoice([0, 0.2, 0.4, 0.6]) : 0);
      const defNow = defPrev * (1 + infl / 100);
      const realPrev = randomInt(isChallenge ? 1400 : 900, isChallenge ? 3600 : 2300);
      const realNow = randomInt(isChallenge ? 1500 : 950, isChallenge ? 3900 : 2500);
      const nomPrev = (realPrev * defPrev) / 100;
      const nomNow = (realNow * defNow) / 100;
      const inflation = ((defNow - defPrev) / defPrev) * 100;
      return {
        type: "deflator",
        answer: inflation,
        tolerance: isChallenge ? 0.08 : 0.15,
        answerDisplay: inflation.toFixed(2),
        promptHtml: `<h3>Deflator Inflation</h3><p>Year \\(t-1\\): Nominal GDP \\(=${nomPrev.toFixed(1)}\\), Real GDP \\(=${realPrev}\\).<br>Year \\(t\\): Nominal GDP \\(=${nomNow.toFixed(1)}\\), Real GDP \\(=${realNow}\\).<br>Compute GDP-deflator inflation from \\(t-1\\) to \\(t\\) in percent.</p>`,
        solutionHtml: `<p>\\(\\text{Def}_{t-1}=\\frac{${nomPrev.toFixed(1)}}{${realPrev}}\\times100=${defPrev.toFixed(2)}\\)</p><p>\\(\\text{Def}_{t}=\\frac{${nomNow.toFixed(1)}}{${realNow}}\\times100=${defNow.toFixed(2)}\\)</p><p>\\(\\pi_t^{GDP}=\\frac{\\text{Def}_t-\\text{Def}_{t-1}}{\\text{Def}_{t-1}}\\times100=${inflation.toFixed(2)}\\%\\)</p>`
      };
    }

    function generateLaborChallenge(isChallenge) {
      const adults = randomInt(isChallenge ? 180 : 100, isChallenge ? 390 : 260);
      const employed = randomInt(isChallenge ? 90 : 50, adults - (isChallenge ? 20 : 10));
      const unemployed = randomInt(isChallenge ? 8 : 4, Math.max(10, adults - employed - 4));
      const laborForce = employed + unemployed;
      const uRate = (unemployed / laborForce) * 100;
      return {
        type: "labor",
        answer: uRate,
        tolerance: 0.08,
        answerDisplay: uRate.toFixed(2),
        promptHtml: `<h3>Unemployment Rate</h3><p>Adults \\(=${adults}\\), employed \\(E=${employed}\\), unemployed \\(U=${unemployed}\\). Compute unemployment rate \\(u\\) as a percent.</p>`,
        solutionHtml: `<p>\\(LF=E+U=${employed}+${unemployed}=${laborForce}\\)</p><p>\\(u=\\frac{U}{LF}\\times100=\\frac{${unemployed}}{${laborForce}}\\times100=${uRate.toFixed(2)}\\%\\)</p>`
      };
    }

    function generateSavingChallenge(isChallenge) {
      const Y = randomInt(isChallenge ? 6000 : 2800, isChallenge ? 18000 : 9200);
      const C = randomInt(isChallenge ? 2500 : 1300, Math.max(2000, Math.floor(Y * 0.72)));
      const G = randomInt(isChallenge ? 1000 : 450, Math.max(600, Math.floor(Y * 0.35)));
      const I = randomInt(isChallenge ? 900 : 280, isChallenge ? 5200 : 2400);
      const S = Y - C - G;
      const NX = S - I;
      return {
        type: "saving",
        answer: NX,
        tolerance: 0.5,
        answerDisplay: NX.toFixed(1),
        promptHtml: `<h3>Saving and Net Exports</h3><p>Given \\(Y=${Y}\\), \\(C=${C}\\), \\(G=${G}\\), \\(I=${I}\\) (billions), compute \\(NX\\) using \\(S=Y-C-G\\) and \\(NX=S-I\\).</p>`,
        solutionHtml: `<p>\\(S=Y-C-G=${Y}-${C}-${G}=${S}\\)</p><p>\\(NX=S-I=${S}-${I}=${NX}\\)</p><p><strong>Answer:</strong> \\(${NX}\\) billion.</p>`
      };
    }

    function generateRealRateChallenge(isChallenge) {
      const nominal = randomInt(isChallenge ? -1 : 1, isChallenge ? 14 : 10) + randomChoice([0, 0.2, 0.4, 0.6, 0.8]);
      const expectedInfl = randomInt(isChallenge ? -2 : 0, isChallenge ? 9 : 7) + randomChoice([0, 0.2, 0.4, 0.6, 0.8]);
      const real = nominal - expectedInfl;
      return {
        type: "real_rate",
        answer: real,
        tolerance: 0.05,
        answerDisplay: real.toFixed(2),
        promptHtml: `<h3>Real Interest Approximation</h3><p>Nominal interest \\(i=${nominal.toFixed(1)}\\%\\), expected inflation \\(\\pi^e=${expectedInfl.toFixed(1)}\\%\\). Compute \\(r\\approx i-\\pi^e\\).</p>`,
        solutionHtml: `<p>\\(r \\approx i-\\pi^e=${nominal.toFixed(1)}-${expectedInfl.toFixed(1)}=${real.toFixed(2)}\\%\\)</p>`
      };
    }

    function generateElasticityChallenge(isChallenge) {
      const priceUp = Math.random() > 0.5;
      const p1 = randomInt(isChallenge ? 5 : 6, isChallenge ? 20 : 16);
      const p2 = priceUp
        ? p1 + randomInt(1, isChallenge ? 7 : 5)
        : Math.max(2, p1 - randomInt(1, isChallenge ? 4 : 3));
      const q1 = randomInt(isChallenge ? 120 : 90, isChallenge ? 520 : 340);
      const q2 = priceUp
        ? Math.max(20, q1 - randomInt(18, isChallenge ? 180 : 110))
        : q1 + randomInt(18, isChallenge ? 180 : 110);
      const pctQ = (q2 - q1) / ((q2 + q1) / 2);
      const pctP = (p2 - p1) / ((p2 + p1) / 2);
      const epsilon = pctQ / pctP;
      return {
        type: "elasticity",
        answer: epsilon,
        tolerance: isChallenge ? 0.03 : 0.05,
        answerDisplay: epsilon.toFixed(2),
        promptHtml: `<h3>Midpoint Demand Elasticity</h3><p>Price moves from \\(${p1}\\) to \\(${p2}\\), quantity demanded moves from \\(${q1}\\) to \\(${q2}\\). Compute \\(\\varepsilon_D\\) using midpoint method.</p>`,
        solutionHtml: `<p>\\(\\%\\Delta Q=\\frac{${q2}-${q1}}{(${q2}+${q1})/2}=${pctQ.toFixed(4)}\\)</p><p>\\(\\%\\Delta P=\\frac{${p2}-${p1}}{(${p2}+${p1})/2}=${pctP.toFixed(4)}\\)</p><p>\\(\\varepsilon_D=\\frac{\\%\\Delta Q}{\\%\\Delta P}=${epsilon.toFixed(2)}\\)</p>`
      };
    }

    function generateArenaChallenge() {
      if (!arenaPrompt || !arenaSolution || !arenaAnswer) return;
      const selectedType = typeForArena();
      const isChallenge = arenaDifficulty && arenaDifficulty.value === "challenge";
      let challenge = null;

      if (selectedType === "gdp") challenge = generateGDPChallenge(isChallenge);
      else if (selectedType === "deflator") challenge = generateDeflatorChallenge(isChallenge);
      else if (selectedType === "labor") challenge = generateLaborChallenge(isChallenge);
      else if (selectedType === "saving") challenge = generateSavingChallenge(isChallenge);
      else if (selectedType === "real_rate") challenge = generateRealRateChallenge(isChallenge);
      else challenge = generateElasticityChallenge(isChallenge);

      arenaChallenge = {
        ...challenge,
        graded: false
      };

      arenaPrompt.innerHTML = challenge.promptHtml;
      arenaSolution.innerHTML = challenge.solutionHtml;
      arenaSolution.classList.remove("show");
      arenaAnswer.value = "";
      arenaAnswer.focus();
      setArenaFeedback(`Challenge live: ${ARENA_TYPE_LABELS[challenge.type]}. Submit one numeric answer.`, "");
      typesetMath(arenaPrompt);
      typesetMath(arenaSolution);

      const roundSeconds = isChallenge ? 90 : 120;
      startArenaTimer(roundSeconds);
      persistArenaPrefs();
    }

    function checkArenaAnswer() {
      if (!arenaChallenge) {
        setArenaFeedback("Generate a challenge first.", "error");
        return;
      }
      if (arenaChallenge.graded) {
        setArenaFeedback("This challenge is already graded. Generate the next one.", "");
        return;
      }
      const user = Number.parseFloat(arenaAnswer.value);
      if (!Number.isFinite(user)) {
        setArenaFeedback("Enter a numeric answer before grading.", "error");
        return;
      }

      const correct = Math.abs(user - arenaChallenge.answer) <= arenaChallenge.tolerance;
      if (correct) {
        markArenaOutcome(
          true,
          `Correct. Expected ${arenaChallenge.answerDisplay} and your answer was within tolerance.`,
          "success"
        );
      } else {
        markArenaOutcome(
          false,
          `Incorrect. Your value ${user.toFixed(2)} is outside tolerance from ${arenaChallenge.answerDisplay}.`,
          "error"
        );
      }
    }

    function revealArenaSolution() {
      if (!arenaChallenge) {
        setArenaFeedback("Generate a challenge first.", "error");
        return;
      }
      if (!arenaChallenge.graded) {
        markArenaOutcome(
          false,
          `Solution revealed. Correct value: ${arenaChallenge.answerDisplay}.`,
          "error"
        );
      }
      arenaSolution.classList.add("show");
      typesetMath(arenaSolution);
    }

    function resetArena() {
      stopArenaTimer();
      arenaChallenge = null;
      arenaSeconds = 120;
      renderArenaTimer();
      arenaStats = defaultArenaStats();
      persistArenaStats();
      updateArenaStatsUI();
      safeWrite(STORAGE.arenaPrefs, {
        type: "mixed",
        difficulty: "standard"
      });
      if (arenaType) arenaType.value = "mixed";
      if (arenaDifficulty) arenaDifficulty.value = "standard";
      if (arenaPrompt) {
        arenaPrompt.innerHTML = "<h3>Challenge Ready</h3><p>Press <strong>Generate Challenge</strong> to start a timed quantitative problem.</p>";
      }
      if (arenaSolution) {
        arenaSolution.innerHTML = "";
        arenaSolution.classList.remove("show");
      }
      if (arenaAnswer) arenaAnswer.value = "";
      setArenaFeedback("Arena reset. Generate a fresh challenge.", "");
      typesetMath(arenaPrompt);
    }

    function initArena() {
      if (!arenaType || !arenaDifficulty || !arenaGenerateBtn || !arenaCheckBtn || !arenaRevealBtn || !arenaNextBtn || !arenaResetBtn || !arenaAnswer || !arenaPrompt || !arenaFeedback || !arenaSolution) return;
      arenaStats = sanitizeArenaStats(safeRead(STORAGE.arenaStats, null));
      const prefs = safeRead(STORAGE.arenaPrefs, null);
      if (prefs && typeof prefs === "object") {
        if (typeof prefs.type === "string" && (prefs.type === "mixed" || ARENA_TYPES.includes(prefs.type))) {
          arenaType.value = prefs.type;
        }
        if (prefs.difficulty === "challenge" || prefs.difficulty === "standard") {
          arenaDifficulty.value = prefs.difficulty;
        }
      }

      updateArenaStatsUI();
      renderArenaTimer();
      typesetMath(arenaPrompt);

      arenaType.addEventListener("change", persistArenaPrefs);
      arenaDifficulty.addEventListener("change", persistArenaPrefs);
      arenaGenerateBtn.addEventListener("click", generateArenaChallenge);
      arenaCheckBtn.addEventListener("click", checkArenaAnswer);
      arenaRevealBtn.addEventListener("click", revealArenaSolution);
      arenaNextBtn.addEventListener("click", generateArenaChallenge);
      arenaResetBtn.addEventListener("click", resetArena);
      arenaAnswer.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          checkArenaAnswer();
        }
      });
    }

    function normalizeIntuitionTagFilter(value) {
      const key = String(value || "").trim();
      return key in INTUITION_TAG_FILTERS ? key : "all";
    }

    function normalizeIntuitionConfidence(value) {
      const key = String(value || "").trim();
      return key in INTUITION_CONFIDENCE ? key : "medium";
    }

    function scenarioMatchesIntuitionFilter(scenario, filterKey = activeIntuitionTagFilter) {
      const normalized = normalizeIntuitionTagFilter(filterKey);
      const filter = INTUITION_TAG_FILTERS[normalized] || INTUITION_TAG_FILTERS.all;
      if (!scenario || !Array.isArray(filter.markers) || !filter.markers.length) return true;
      return filter.markers.some((marker) => scenario.tag.includes(marker));
    }

    function getFilteredIntuitionScenarios() {
      return intuitionScenarios.filter((scenario) => scenarioMatchesIntuitionFilter(scenario));
    }

    function defaultIntuitionVarStats() {
      return {
        attempts: 0,
        correct: 0
      };
    }

    function sanitizeIntuitionVarStats(raw) {
      const base = defaultIntuitionVarStats();
      if (!raw || typeof raw !== "object") return base;
      const attempts = clamp(Number.parseInt(raw.attempts, 10) || 0, 0, 100000);
      const correct = clamp(Number.parseInt(raw.correct, 10) || 0, 0, attempts);
      return { attempts, correct };
    }

    function defaultIntuitionScenarioStats(scenario = null) {
      const byVar = {};
      if (scenario && Array.isArray(scenario.variables)) {
        scenario.variables.forEach((item) => {
          if (item && item.id) {
            byVar[item.id] = defaultIntuitionVarStats();
          }
        });
      }
      return {
        attempts: 0,
        perfect: 0,
        scoreSum: 0,
        byVar
      };
    }

    function defaultIntuitionState() {
      return {
        attempts: 0,
        perfect: 0,
        scoreSum: 0,
        tagFilter: "all",
        confidence: "medium",
        currentId: intuitionScenarios[0] ? intuitionScenarios[0].id : "",
        scenarioStats: {}
      };
    }

    function sanitizeIntuitionScenarioStats(raw, scenario = null) {
      const base = defaultIntuitionScenarioStats(scenario);
      if (!raw || typeof raw !== "object") return base;
      const attempts = clamp(Number.parseInt(raw.attempts, 10) || 0, 0, 100000);
      const perfect = clamp(Number.parseInt(raw.perfect, 10) || 0, 0, attempts);
      const rawScore = Number.parseFloat(raw.scoreSum);
      const scoreCap = attempts * 100;
      const scoreSum = Number.isFinite(rawScore)
        ? clamp(Math.round(rawScore * 100) / 100, 0, scoreCap)
        : 0;
      const byVar = { ...base.byVar };
      if (raw.byVar && typeof raw.byVar === "object") {
        Object.keys(byVar).forEach((varId) => {
          byVar[varId] = sanitizeIntuitionVarStats(raw.byVar[varId]);
        });
      }
      return { attempts, perfect, scoreSum, byVar };
    }

    function sanitizeIntuitionState(raw) {
      const base = defaultIntuitionState();
      if (!raw || typeof raw !== "object") return base;

      const attempts = clamp(Number.parseInt(raw.attempts, 10) || 0, 0, 100000);
      const perfect = clamp(Number.parseInt(raw.perfect, 10) || 0, 0, attempts);
      const rawScore = Number.parseFloat(raw.scoreSum);
      const scoreCap = attempts * 100;
      const scoreSum = Number.isFinite(rawScore)
        ? clamp(Math.round(rawScore * 100) / 100, 0, scoreCap)
        : 0;
      const next = {
        attempts,
        perfect,
        scoreSum,
        tagFilter: normalizeIntuitionTagFilter(raw.tagFilter),
        confidence: normalizeIntuitionConfidence(raw.confidence),
        currentId: typeof raw.currentId === "string" ? raw.currentId : base.currentId,
        scenarioStats: {}
      };

      const rawScenarioStats = raw.scenarioStats && typeof raw.scenarioStats === "object"
        ? raw.scenarioStats
        : {};
      intuitionScenarios.forEach((scenario) => {
        next.scenarioStats[scenario.id] = sanitizeIntuitionScenarioStats(rawScenarioStats[scenario.id], scenario);
      });

      if (!intuitionScenarios.find((scenario) => scenario.id === next.currentId)) {
        next.currentId = base.currentId;
      }
      return next;
    }

    function persistIntuitionState() {
      if (!intuitionState) return;
      safeWrite(STORAGE.intuitionState, intuitionState);
    }

    function getIntuitionScenarioById(id) {
      return intuitionScenarios.find((scenario) => scenario.id === id) || null;
    }

    function getActiveIntuitionScenario() {
      return getIntuitionScenarioById(activeIntuitionScenarioId);
    }

    function getIntuitionScenarioStats(id) {
      if (!intuitionState) intuitionState = defaultIntuitionState();
      if (!intuitionState.scenarioStats || typeof intuitionState.scenarioStats !== "object") {
        intuitionState.scenarioStats = {};
      }
      const scenario = getIntuitionScenarioById(id);
      intuitionState.scenarioStats[id] = sanitizeIntuitionScenarioStats(
        intuitionState.scenarioStats[id],
        scenario
      );
      return intuitionState.scenarioStats[id];
    }

    function intuitionDirectionLabel(value) {
      if (value === "up") return "Increase ()";
      if (value === "down") return "Decrease ()";
      return "No clear change (~)";
    }

    function stripIntuitionLabel(rawLabel) {
      return String(rawLabel || "")
        .replace(/\\\([^)]*\\\)/g, "")
        .replace(/<[^>]+>/g, "")
        .replace(/\s+/g, " ")
        .trim();
    }

    function getCurrentIntuitionConfidence() {
      const fallback = intuitionState ? intuitionState.confidence : "medium";
      const selected = normalizeIntuitionConfidence(
        intuitionConfidence ? intuitionConfidence.value : fallback
      );
      if (intuitionConfidence && intuitionConfidence.value !== selected) {
        intuitionConfidence.value = selected;
      }
      if (intuitionState) intuitionState.confidence = selected;
      return selected;
    }

    function weakestVariableForScenario(scenario, stats) {
      if (!scenario || !stats || !stats.byVar || typeof stats.byVar !== "object") return null;
      const candidates = scenario.variables
        .map((item) => {
          const varStats = sanitizeIntuitionVarStats(stats.byVar[item.id]);
          const rate = varStats.attempts
            ? Math.round((varStats.correct / varStats.attempts) * 100)
            : 0;
          return {
            label: stripIntuitionLabel(item.label) || item.id,
            attempts: varStats.attempts,
            rate
          };
        })
        .sort((a, b) => {
          if (a.rate !== b.rate) return a.rate - b.rate;
          return a.attempts - b.attempts;
        });
      return candidates[0] || null;
    }

    function setIntuitionFeedback(message, tone = "") {
      if (!intuitionFeedback) return;
      intuitionFeedback.innerHTML = message;
      intuitionFeedback.className = `arena-feedback${tone ? ` ${tone}` : ""}`;
      typesetMath(intuitionFeedback);
    }

    function updateIntuitionCoachMeta(scenario = null) {
      if (!intuitionCoachMeta) return;
      const activeScenario = scenario || getActiveIntuitionScenario();
      const totalSteps = activeScenario && Array.isArray(activeScenario.chain)
        ? activeScenario.chain.length
        : 0;
      const hintStep = clamp(intuitionHintStep, 0, totalSteps);
      const filter = INTUITION_TAG_FILTERS[normalizeIntuitionTagFilter(activeIntuitionTagFilter)] || INTUITION_TAG_FILTERS.all;
      const confidence = INTUITION_CONFIDENCE[getCurrentIntuitionConfidence()] || INTUITION_CONFIDENCE.medium;
      intuitionCoachMeta.textContent = `Hint step ${hintStep}/${totalSteps}  Filter: ${filter.label}  ${confidence.label}`;
    }

    function updateIntuitionStatsMeta() {
      if (!intuitionStatsMeta || !intuitionState) return;
      const attempts = intuitionState.attempts;
      const perfect = intuitionState.perfect;
      const pct = attempts ? Math.round((perfect / attempts) * 100) : 0;
      const avgCalibrated = attempts ? Math.round(intuitionState.scoreSum / attempts) : 0;
      intuitionStatsMeta.textContent = `Attempts: ${attempts}  Perfect rounds: ${perfect}  Perfect rate: ${pct}%  Avg calibrated: ${avgCalibrated}%`;
      updateMissionControl();
    }

    function renderIntuitionScenarioCards() {
      if (!intuitionScenarioCards || !intuitionState) return;
      intuitionScenarioCards.innerHTML = "";

      const active = getActiveIntuitionScenario();
      const filtered = getFilteredIntuitionScenarios();
      const renderList = filtered.slice();
      if (active && !renderList.some((scenario) => scenario.id === active.id)) {
        renderList.unshift(active);
      }

      if (!renderList.length) {
        const empty = document.createElement("div");
        empty.className = "arena-feedback";
        empty.textContent = "No scenarios match the selected filter.";
        intuitionScenarioCards.appendChild(empty);
        return;
      }

      renderList.forEach((scenario) => {
        const stats = getIntuitionScenarioStats(scenario.id);
        const pct = stats.attempts ? Math.round((stats.perfect / stats.attempts) * 100) : 0;
        const avgCalibrated = stats.attempts ? Math.round(stats.scoreSum / stats.attempts) : 0;
        const weak = weakestVariableForScenario(scenario, stats);
        const weakMeta = weak && stats.attempts
          ? `  weak: ${weak.label} ${weak.rate}%`
          : "";
        const row = document.createElement("button");
        row.type = "button";
        row.className = `intuition-scenario${scenario.id === activeIntuitionScenarioId ? " active" : ""}`;
        row.innerHTML = `<span class="title">${scenario.title}</span><span class="meta">${scenario.tag}  ${stats.attempts} tries  ${pct}% perfect  ${avgCalibrated}% calibrated${weakMeta}</span>`;
        row.addEventListener("click", () => {
          setActiveIntuitionScenario(scenario.id);
        });
        intuitionScenarioCards.appendChild(row);
      });
    }

    function renderIntuitionChain(scenario, includeReasons = true, maxSteps = null) {
      if (!intuitionChain || !scenario) return;
      const stepCap = Number.isFinite(maxSteps)
        ? clamp(Math.round(maxSteps), 0, scenario.chain.length)
        : scenario.chain.length;
      const chainItems = scenario.chain
        .slice(0, stepCap)
        .map((line) => `<li>${line}</li>`)
        .join("");
      const reasonItems = includeReasons && stepCap === scenario.chain.length
        ? scenario.variables
          .map((item) => `<li><strong>${item.label}:</strong> ${item.why}</li>`)
          .join("")
        : "";
      const chainBody = chainItems
        ? `<ol>${chainItems}</ol>`
        : "<p>No hint steps revealed yet. Use <strong>Hint Step</strong> to unlock the mechanism progressively.</p>";
      const reasonBlock = includeReasons && stepCap === scenario.chain.length
        ? `<strong>Directional logic</strong><ul>${reasonItems}</ul>`
        : "";

      intuitionChain.innerHTML = `<strong>Causal chain (${stepCap}/${scenario.chain.length} steps)</strong>${chainBody}${reasonBlock}`;
      intuitionChain.classList.remove("hidden");
      typesetMath(intuitionChain);
    }

    function hideIntuitionChain() {
      if (!intuitionChain) return;
      intuitionChain.innerHTML = "";
      intuitionChain.classList.add("hidden");
    }

    function renderIntuitionDebrief(scenario, details, calibratedScore, confidenceLabel) {
      if (!intuitionDebrief || !scenario || !Array.isArray(details) || !details.length) return;
      const summary = `<h4>Directional Debrief  Calibrated score ${calibratedScore}% (${confidenceLabel})</h4>`;
      const rows = details.map((entry) => {
        const guessText = intuitionDirectionLabel(entry.guess);
        const expectedText = intuitionDirectionLabel(entry.expected);
        return `
          <article class="intuition-debrief-item ${entry.correct ? "good" : "bad"}">
            <div class="top">
              <span>${entry.label}</span>
              <span>${entry.correct ? "Correct" : `Your call: ${guessText}  Expected: ${expectedText}`}</span>
            </div>
            <p class="logic">${entry.why}</p>
          </article>
        `;
      }).join("");
      intuitionDebrief.innerHTML = `${summary}${rows}`;
      intuitionDebrief.classList.remove("hidden");
      typesetMath(intuitionDebrief);
    }

    function hideIntuitionDebrief() {
      if (!intuitionDebrief) return;
      intuitionDebrief.innerHTML = "";
      intuitionDebrief.classList.add("hidden");
    }

    function renderIntuitionVariables(scenario) {
      if (!intuitionVars) return;
      intuitionVars.innerHTML = "";

      scenario.variables.forEach((item) => {
        const row = document.createElement("div");
        row.className = "intuition-var";
        row.dataset.varId = item.id;

        const label = document.createElement("label");
        label.className = "intuition-label";
        label.innerHTML = item.label;

        const select = document.createElement("select");
        select.className = "intuition-select";
        select.setAttribute("aria-label", item.label);
        select.innerHTML = "<option value=''>Choose direction...</option>";
        INTUITION_OPTIONS.forEach((option) => {
          const node = document.createElement("option");
          node.value = option.value;
          node.textContent = option.label;
          select.appendChild(node);
        });
        select.value = intuitionGuesses[item.id] || "";
        select.addEventListener("change", () => {
          intuitionGuesses[item.id] = select.value;
          row.classList.remove("correct", "wrong");
          const result = row.querySelector(".intuition-result");
          if (result) result.textContent = select.value ? "Ready" : "Pending";
        });

        const result = document.createElement("span");
        result.className = "intuition-result";
        result.textContent = "Pending";

        row.appendChild(label);
        row.appendChild(select);
        row.appendChild(result);
        intuitionVars.appendChild(row);
      });
      typesetMath(intuitionVars);
    }

    function setActiveIntuitionScenario(id) {
      const scenario = getIntuitionScenarioById(id) || intuitionScenarios[0];
      if (!scenario) return;

      activeIntuitionScenarioId = scenario.id;
      intuitionGuesses = {};
      intuitionHintStep = 0;
      if (intuitionState) {
        intuitionState.currentId = scenario.id;
        intuitionState.tagFilter = normalizeIntuitionTagFilter(activeIntuitionTagFilter);
        intuitionState.confidence = getCurrentIntuitionConfidence();
        persistIntuitionState();
      }

      if (intuitionScenarioTitle) intuitionScenarioTitle.textContent = scenario.title;
      if (intuitionScenarioTag) intuitionScenarioTag.textContent = scenario.tag;
      if (intuitionShock) intuitionShock.innerHTML = scenario.shock;
      renderIntuitionVariables(scenario);
      renderIntuitionScenarioCards();
      updateIntuitionStatsMeta();
      hideIntuitionChain();
      hideIntuitionDebrief();
      updateIntuitionCoachMeta(scenario);
      setIntuitionFeedback("Choose a direction for each variable. Use <strong>Hint Step</strong> for incremental mechanism support before grading.", "");
      typesetMath(intuitionShock);
    }

    function pickNextIntuitionScenarioId() {
      const pool = getFilteredIntuitionScenarios();
      if (!pool.length) return intuitionScenarios[0] ? intuitionScenarios[0].id : "";
      if (pool.length <= 1) return pool[0].id;
      const candidates = pool.filter((scenario) => scenario.id !== activeIntuitionScenarioId);
      if (!candidates.length) return activeIntuitionScenarioId;

      const ranked = candidates
        .map((scenario) => {
          const stats = getIntuitionScenarioStats(scenario.id);
          const perfectRate = stats.attempts ? (stats.perfect / stats.attempts) : 0;
          const calibratedAvg = stats.attempts ? (stats.scoreSum / stats.attempts) / 100 : 0.45;
          const weaknessPressure = (1 - perfectRate) * 0.65 + (1 - calibratedAvg) * 0.35;
          const noveltyBoost = stats.attempts === 0 ? 0.8 : 0;
          const priority = weaknessPressure + noveltyBoost + (Math.random() * 0.2);
          return { id: scenario.id, priority };
        })
        .sort((a, b) => b.priority - a.priority);

      const topBand = ranked.slice(0, Math.min(3, ranked.length));
      return topBand[Math.floor(Math.random() * topBand.length)].id;
    }

    function nextIntuitionScenario() {
      const nextId = pickNextIntuitionScenarioId();
      if (!nextId) return;
      setActiveIntuitionScenario(nextId);
      showStatus("Loaded next intuition scenario.");
    }

    function gradeIntuitionPredictions() {
      const scenario = getActiveIntuitionScenario();
      if (!scenario || !intuitionVars || !intuitionState) return;

      let missing = 0;
      let correct = 0;
      const details = [];
      scenario.variables.forEach((item) => {
        const row = intuitionVars.querySelector(`.intuition-var[data-var-id="${item.id}"]`);
        if (!row) return;
        const select = row.querySelector("select");
        const result = row.querySelector(".intuition-result");
        const guess = select ? select.value : "";
        intuitionGuesses[item.id] = guess;

        row.classList.remove("correct", "wrong");
        if (!guess) {
          missing += 1;
          if (result) result.textContent = "Required";
          return;
        }

        const isCorrect = guess === item.answer;
        details.push({
          id: item.id,
          label: item.label,
          why: item.why,
          guess,
          expected: item.answer,
          correct: isCorrect
        });

        if (isCorrect) {
          correct += 1;
          row.classList.add("correct");
          if (result) result.textContent = "Correct";
        } else {
          row.classList.add("wrong");
          if (result) result.textContent = `${intuitionDirectionLabel(item.answer)} expected`;
        }
      });

      if (missing > 0) {
        setIntuitionFeedback(`Complete all predictions first. Missing ${missing} selection${missing === 1 ? "" : "s"}.`, "error");
        return;
      }

      const stats = getIntuitionScenarioStats(scenario.id);
      const perfect = correct === scenario.variables.length;
      const wrong = scenario.variables.length - correct;
      const baseScore = Math.round((correct / scenario.variables.length) * 100);
      const confidenceKey = getCurrentIntuitionConfidence();
      const confidence = INTUITION_CONFIDENCE[confidenceKey] || INTUITION_CONFIDENCE.medium;
      const calibratedScore = clamp(
        baseScore - (wrong * confidence.penaltyPerWrong) + (perfect ? confidence.perfectBonus : 0),
        0,
        100
      );

      intuitionState.attempts += 1;
      intuitionState.scoreSum += calibratedScore;
      stats.attempts += 1;
      stats.scoreSum += calibratedScore;
      if (perfect) {
        intuitionState.perfect += 1;
        stats.perfect += 1;
      }
      if (!stats.byVar || typeof stats.byVar !== "object") {
        stats.byVar = {};
      }
      details.forEach((entry) => {
        if (!stats.byVar[entry.id]) {
          stats.byVar[entry.id] = defaultIntuitionVarStats();
        }
        stats.byVar[entry.id].attempts += 1;
        if (entry.correct) {
          stats.byVar[entry.id].correct += 1;
        }
      });

      intuitionHintStep = scenario.chain.length;
      persistIntuitionState();
      renderIntuitionScenarioCards();
      updateIntuitionStatsMeta();
      updateIntuitionCoachMeta(scenario);
      renderIntuitionChain(scenario, true, scenario.chain.length);
      renderIntuitionDebrief(scenario, details, calibratedScore, confidence.label);

      if (perfect) {
        setIntuitionFeedback(`Perfect round. ${correct}/${scenario.variables.length} correct with ${calibratedScore}% calibrated score (${confidence.label.toLowerCase()}).`, "success");
      } else {
        setIntuitionFeedback(`Scored ${correct}/${scenario.variables.length}. Base: ${baseScore}%. Calibrated: ${calibratedScore}% (${confidence.label.toLowerCase()}). Review the chain and debrief below.`, "error");
      }
    }

    function revealIntuitionHintStep() {
      const scenario = getActiveIntuitionScenario();
      if (!scenario) return;
      if (intuitionHintStep >= scenario.chain.length) {
        renderIntuitionChain(scenario, false, scenario.chain.length);
        setIntuitionFeedback("All hint steps are already revealed. Grade now, or reveal full logic for directional reasons.", "");
        return;
      }
      intuitionHintStep += 1;
      renderIntuitionChain(scenario, false, intuitionHintStep);
      updateIntuitionCoachMeta(scenario);
      hideIntuitionDebrief();
      setIntuitionFeedback(`Hint ${intuitionHintStep}/${scenario.chain.length}: focus on mechanism before jumping to final outcomes.`, "");
    }

    function revealIntuitionLogic() {
      const scenario = getActiveIntuitionScenario();
      if (!scenario) return;
      intuitionHintStep = scenario.chain.length;
      renderIntuitionChain(scenario, true, scenario.chain.length);
      updateIntuitionCoachMeta(scenario);
      setIntuitionFeedback("Full logic revealed. Re-run this scenario and target a perfect calibrated score.", "");
    }

    function handleIntuitionFilterChange() {
      activeIntuitionTagFilter = normalizeIntuitionTagFilter(intuitionTagFilter ? intuitionTagFilter.value : activeIntuitionTagFilter);
      if (intuitionTagFilter) intuitionTagFilter.value = activeIntuitionTagFilter;
      if (intuitionState) {
        intuitionState.tagFilter = activeIntuitionTagFilter;
      }

      const filtered = getFilteredIntuitionScenarios();
      if (!filtered.some((scenario) => scenario.id === activeIntuitionScenarioId)) {
        const fallback = filtered[0] || intuitionScenarios[0];
        if (fallback) {
          setActiveIntuitionScenario(fallback.id);
        }
      } else {
        renderIntuitionScenarioCards();
        updateIntuitionCoachMeta();
      }
      persistIntuitionState();
      const filterLabel = INTUITION_TAG_FILTERS[activeIntuitionTagFilter]
        ? INTUITION_TAG_FILTERS[activeIntuitionTagFilter].label
        : "all modules";
      showStatus(`Intuition filter set to ${filterLabel}.`);
    }

    function resetIntuitionStudioState(shouldPersist = true) {
      intuitionState = defaultIntuitionState();
      intuitionGuesses = {};
      intuitionHintStep = 0;
      activeIntuitionTagFilter = intuitionState.tagFilter;
      if (intuitionTagFilter) intuitionTagFilter.value = activeIntuitionTagFilter;
      if (intuitionConfidence) intuitionConfidence.value = intuitionState.confidence;
      if (shouldPersist) {
        safeWrite(STORAGE.intuitionState, intuitionState);
      }
      const fallback = intuitionState.currentId || (intuitionScenarios[0] && intuitionScenarios[0].id);
      if (fallback) setActiveIntuitionScenario(fallback);
      updateIntuitionStatsMeta();
      hideIntuitionChain();
      hideIntuitionDebrief();
      updateIntuitionCoachMeta();
      setIntuitionFeedback("Intuition studio reset. Choose directions, use hint steps if needed, then grade.", "");
    }

    function initIntuitionStudio() {
      if (
        !intuitionScenarioCards
        || !intuitionStatsMeta
        || !intuitionScenarioTitle
        || !intuitionScenarioTag
        || !intuitionShock
        || !intuitionTagFilter
        || !intuitionConfidence
        || !intuitionCoachMeta
        || !intuitionVars
        || !intuitionGradeBtn
        || !intuitionHintBtn
        || !intuitionRevealBtn
        || !intuitionNextBtn
        || !intuitionFeedback
        || !intuitionDebrief
        || !intuitionChain
      ) {
        return;
      }
      intuitionState = sanitizeIntuitionState(safeRead(STORAGE.intuitionState, null));
      activeIntuitionTagFilter = normalizeIntuitionTagFilter(intuitionState.tagFilter);
      intuitionTagFilter.value = activeIntuitionTagFilter;
      intuitionConfidence.value = normalizeIntuitionConfidence(intuitionState.confidence);
      activeIntuitionScenarioId = intuitionState.currentId || (intuitionScenarios[0] && intuitionScenarios[0].id) || "";

      const filtered = getFilteredIntuitionScenarios();
      if (!filtered.some((scenario) => scenario.id === activeIntuitionScenarioId)) {
        activeIntuitionScenarioId = filtered[0]
          ? filtered[0].id
          : ((intuitionScenarios[0] && intuitionScenarios[0].id) || "");
      }

      intuitionGradeBtn.addEventListener("click", gradeIntuitionPredictions);
      intuitionHintBtn.addEventListener("click", revealIntuitionHintStep);
      intuitionRevealBtn.addEventListener("click", revealIntuitionLogic);
      intuitionNextBtn.addEventListener("click", nextIntuitionScenario);
      intuitionTagFilter.addEventListener("change", handleIntuitionFilterChange);
      intuitionConfidence.addEventListener("change", () => {
        const normalized = getCurrentIntuitionConfidence();
        if (intuitionState) {
          intuitionState.confidence = normalized;
          persistIntuitionState();
        }
        updateIntuitionCoachMeta();
      });

      setActiveIntuitionScenario(activeIntuitionScenarioId);
      updateIntuitionStatsMeta();
      updateIntuitionCoachMeta();
    }

    const QUEST_INTENSITY = {
      light: { count: 3, minuteScale: 0.85 },
      standard: { count: 4, minuteScale: 1.0 },
      challenge: { count: 5, minuteScale: 1.2 }
    };

    const QUEST_LIBRARY = {
      foundations: [
        {
          title: "Graph policy shock drill",
          note: "Run a binding ceiling scenario and narrate shortage mechanics.",
          minutes: 7,
          action: "go_graph",
          args: { preset: "ceiling_bind" }
        },
        {
          title: "Causal market reasoning",
          note: "Complete one L01/L02 intuition scenario with full directional accuracy.",
          minutes: 6,
          action: "go_intuition",
          args: { marker: "L01" }
        },
        {
          title: "Elasticity execution rep",
          note: "Generate and solve one midpoint elasticity quant challenge.",
          minutes: 7,
          action: "go_quant",
          args: { type: "elasticity" }
        }
      ],
      national: [
        {
          title: "GDP identity precision",
          note: "Solve a GDP spending challenge and verify units.",
          minutes: 7,
          action: "go_quant",
          args: { type: "gdp" }
        },
        {
          title: "Deflator inflation rep",
          note: "Complete one deflator problem with clean formula steps.",
          minutes: 7,
          action: "go_quant",
          args: { type: "deflator" }
        },
        {
          title: "Saving and NX chain",
          note: "Solve one saving/NX problem and explain sign logic.",
          minutes: 7,
          action: "go_quant",
          args: { type: "saving" }
        }
      ],
      labor_rates: [
        {
          title: "Labor metric speed run",
          note: "Solve one unemployment-rate challenge under timer pressure.",
          minutes: 6,
          action: "go_quant",
          args: { type: "labor" }
        },
        {
          title: "Real rate interpretation",
          note: "Solve one real-interest challenge and interpret direction.",
          minutes: 6,
          action: "go_quant",
          args: { type: "real_rate" }
        },
        {
          title: "Labor intuition pass",
          note: "Run one L06 intuition scenario and score perfect.",
          minutes: 6,
          action: "go_intuition",
          args: { marker: "L06" }
        }
      ],
      growth: [
        {
          title: "Production function intuition",
          note: "Work one L07 intuition scenario on TFP/CRS mechanics.",
          minutes: 7,
          action: "go_intuition",
          args: { marker: "L07" }
        },
        {
          title: "Formula pass: growth block",
          note: "Review formula engine with focus on production and growth equations.",
          minutes: 5,
          action: "go_formula",
          args: {}
        }
      ],
      retrieval: [
        {
          title: "Recall burst",
          note: "Complete 5 prompt cycles with reveal and rating.",
          minutes: 8,
          action: "go_recall",
          args: {}
        },
        {
          title: "Error-clinic checkpoint",
          note: "Review one conceptual trap and one calculation trap before next round.",
          minutes: 5,
          action: "go_error",
          args: {}
        }
      ],
      pacing: [
        {
          title: "Timed sprint",
          note: "Run a 12-minute focused sprint to simulate exam urgency.",
          minutes: 12,
          action: "go_timer",
          args: { minutes: 12 }
        }
      ]
    };

    function percentFromCounts(correct, total, fallback = 50) {
      if (!Number.isFinite(correct) || !Number.isFinite(total) || total <= 0) return fallback;
      return clamp(Math.round((correct / total) * 100), 0, 100);
    }

    function formatPercent(value) {
      return `${clamp(Math.round(value), 0, 100)}%`;
    }

    function peekIntuitionScenarioStats(id) {
      if (!intuitionState || !intuitionState.scenarioStats || typeof intuitionState.scenarioStats !== "object") {
        return { attempts: 0, perfect: 0, scoreSum: 0, byVar: {} };
      }
      return sanitizeIntuitionScenarioStats(
        intuitionState.scenarioStats[id],
        getIntuitionScenarioById(id)
      );
    }

    function intuitionAccuracyForMarkers(markers, fallback = 55) {
      const markerList = Array.isArray(markers) ? markers : [markers];
      const relevant = intuitionScenarios.filter((scenario) => markerList.some((marker) => scenario.tag.includes(marker)));
      if (!relevant.length) return fallback;
      let attempts = 0;
      let perfect = 0;
      relevant.forEach((scenario) => {
        const stats = peekIntuitionScenarioStats(scenario.id);
        attempts += stats.attempts;
        perfect += stats.perfect;
      });
      return percentFromCounts(perfect, attempts, fallback);
    }

    function arenaTypeAccuracy(type, fallback = 55) {
      const byType = arenaStats && arenaStats.byType && typeof arenaStats.byType === "object"
        ? arenaStats.byType[type]
        : null;
      if (!byType || typeof byType !== "object") return fallback;
      return percentFromCounts(byType.correct, byType.solved, fallback);
    }

    function computeMissionSignals() {
      const totals = computeTotals();
      const checklistCompleted = checks.filter(Boolean).length;
      const recallPct = percentFromCounts(totals.correct, totals.seen, 50);
      const arenaPct = percentFromCounts(arenaStats.correct, arenaStats.solved, 50);
      const intuitionPct = percentFromCounts(
        intuitionState ? intuitionState.perfect : 0,
        intuitionState ? intuitionState.attempts : 0,
        50
      );
      const checklistPct = dailyChecks.length
        ? Math.round((checklistCompleted / dailyChecks.length) * 100)
        : 0;
      const composite = Math.round(
        (recallPct * 0.27)
        + (arenaPct * 0.31)
        + (intuitionPct * 0.30)
        + (checklistPct * 0.12)
      );

      const topicScores = [
        {
          id: "foundations",
          label: "Markets + Policy (L01-L02)",
          score: Math.round(
            (intuitionAccuracyForMarkers(["L01", "L02"], 55) * 0.5)
            + (arenaTypeAccuracy("elasticity", 55) * 0.25)
            + ((checks[3] ? 100 : 45) * 0.25)
          ),
          note: "Supply-demand shifts, policy binding logic, and elasticity execution."
        },
        {
          id: "national",
          label: "National Accounts (L03-L05)",
          score: Math.round(
            (((arenaTypeAccuracy("gdp", 55) + arenaTypeAccuracy("deflator", 55) + arenaTypeAccuracy("saving", 55)) / 3) * 0.7)
            + (recallPct * 0.3)
          ),
          note: "GDP decomposition, deflator inflation, and saving-NX identity."
        },
        {
          id: "labor_rates",
          label: "Labor + Interest (L05-L06)",
          score: Math.round(
            (((arenaTypeAccuracy("labor", 55) + arenaTypeAccuracy("real_rate", 55)) / 2) * 0.65)
            + (intuitionAccuracyForMarkers("L06", 55) * 0.35)
          ),
          note: "Unemployment metrics, natural rate intuition, and real-rate channels."
        },
        {
          id: "growth",
          label: "Growth + Production (L07)",
          score: Math.round(
            (intuitionAccuracyForMarkers("L07", 55) * 0.6)
            + (recallPct * 0.4)
          ),
          note: "Production functions, TFP shifts, and returns-to-scale reasoning."
        },
        {
          id: "retrieval",
          label: "Retrieval Consistency",
          score: Math.round(
            (recallPct * 0.6)
            + (checklistPct * 0.4)
          ),
          note: "How reliably you retrieve formulas and concepts without cues."
        }
      ];

      topicScores.forEach((topic) => {
        topic.score = clamp(topic.score, 0, 100);
      });

      const sortedTopics = topicScores.slice().sort((a, b) => a.score - b.score);
      return {
        recallPct,
        arenaPct,
        intuitionPct,
        checklistPct,
        composite: clamp(composite, 0, 100),
        topicScores,
        sortedTopics
      };
    }

    function setMissionAlertByScore(score, weakestLabel) {
      if (!missionAlert) return;
      let message = "";
      let tone = "";
      if (score < 55) {
        message = `Risk band: fundamentals are unstable. Prioritize ${weakestLabel}, then run a timed sprint immediately after one corrective drill.`;
        tone = "error";
      } else if (score < 75) {
        message = `Building phase: progress is real, but ${weakestLabel} still limits your exam ceiling. Use the adaptive quest to close this gap.`;
        tone = "";
      } else {
        message = `Strong position: readiness signal is high. Keep retrieval and quant reps active to preserve speed under exam timing.`;
        tone = "success";
      }
      missionAlert.textContent = message;
      missionAlert.className = `arena-feedback${tone ? ` ${tone}` : ""}`;
    }

    function renderMissionHeatmap(topicScores) {
      if (!missionHeatmap) return;
      missionHeatmap.innerHTML = "";
      topicScores.forEach((topic) => {
        const row = document.createElement("div");
        row.className = "heat-row";
        row.innerHTML = `
          <div class="heat-top"><span>${topic.label}</span><strong>${formatPercent(topic.score)}</strong></div>
          <div class="heat-bar"><div class="heat-fill" style="width:${topic.score}%"></div></div>
          <div class="heat-note">${topic.note}</div>
        `;
        missionHeatmap.appendChild(row);
      });
    }

    function defaultQuestState() {
      return {
        generatedAt: 0,
        intensity: "standard",
        tasks: []
      };
    }

    function sanitizeQuestTask(raw, fallbackId = "task") {
      if (!raw || typeof raw !== "object") return null;
      if (typeof raw.title !== "string" || !raw.title.trim()) return null;
      if (typeof raw.note !== "string") return null;
      if (typeof raw.action !== "string" || !raw.action.trim()) return null;
      const id = typeof raw.id === "string" && raw.id.trim() ? raw.id : fallbackId;
      const minutes = clamp(Number.parseInt(raw.minutes, 10) || 5, 3, 60);
      const done = Boolean(raw.done);
      const args = raw.args && typeof raw.args === "object" ? raw.args : {};
      return {
        id,
        title: raw.title.trim(),
        note: raw.note.trim(),
        minutes,
        action: raw.action.trim(),
        args,
        done
      };
    }

    function sanitizeQuestState(raw) {
      const base = defaultQuestState();
      if (!raw || typeof raw !== "object") return base;
      const intensity = raw.intensity in QUEST_INTENSITY ? raw.intensity : "standard";
      const generatedAt = Math.max(0, Number.parseInt(raw.generatedAt, 10) || 0);
      const tasks = Array.isArray(raw.tasks)
        ? raw.tasks
          .map((task, idx) => sanitizeQuestTask(task, `task_${idx}`))
          .filter(Boolean)
          .slice(0, 8)
        : [];
      return {
        generatedAt,
        intensity,
        tasks
      };
    }

    function persistQuestState() {
      if (!questState) return;
      safeWrite(STORAGE.questState, questState);
    }

    function selectWeakestIntuitionScenario(marker) {
      const candidates = intuitionScenarios.filter((scenario) => scenario.tag.includes(marker));
      if (!candidates.length) return null;
      const ranked = candidates
        .map((scenario) => {
          const stats = peekIntuitionScenarioStats(scenario.id);
          const ratio = stats.attempts ? stats.perfect / stats.attempts : 0;
          return {
            id: scenario.id,
            score: ratio + (stats.attempts === 0 ? -0.35 : 0)
          };
        })
        .sort((a, b) => a.score - b.score);
      return ranked[0] ? ranked[0].id : candidates[0].id;
    }

    function runQuestTask(task) {
      if (!task || typeof task !== "object") return;
      const args = task.args && typeof task.args === "object" ? task.args : {};

      if (task.action === "go_graph") {
        applyMarketPreset(args.preset || "reset");
        scrollToSection("marketLab");
      } else if (task.action === "go_intuition") {
        const marker = typeof args.marker === "string" ? args.marker : "";
        const targetScenario = marker ? selectWeakestIntuitionScenario(marker) : pickNextIntuitionScenarioId();
        if (targetScenario) {
          setActiveIntuitionScenario(targetScenario);
        }
        scrollToSection("intuitionStudio");
      } else if (task.action === "go_quant") {
        const type = typeof args.type === "string" && ARENA_TYPES.includes(args.type) ? args.type : "mixed";
        if (arenaType) arenaType.value = type;
        if (arenaDifficulty) {
          arenaDifficulty.value = questState && questState.intensity === "challenge"
            ? "challenge"
            : "standard";
        }
        persistArenaPrefs();
        generateArenaChallenge();
        scrollToSection("quantArena");
      } else if (task.action === "go_formula") {
        scrollToSection("formulaEngine");
      } else if (task.action === "go_recall") {
        pickPrompt();
        scrollToSection("recallTrainer");
      } else if (task.action === "go_error") {
        scrollToSection("errorClinic");
      } else if (task.action === "go_timer") {
        const mins = clamp(Number.parseInt(args.minutes, 10) || 12, 5, 75);
        if (timerMinutes) timerMinutes.value = String(mins);
        resetTimerFromInput();
        startTimer();
        scrollToSection("timerLab");
      }
      showStatus(`Quest focus loaded: ${task.title}`);
    }

    function getQuestTemplatesForTopic(topicId) {
      return Array.isArray(QUEST_LIBRARY[topicId]) ? QUEST_LIBRARY[topicId] : [];
    }

    function buildQuestTasks(signals, intensityConfig) {
      const usedKeys = new Set();
      const tasks = [];
      const weakOrder = signals.sortedTopics.map((topic) => topic.id);
      weakOrder.push("pacing");

      let loopSafety = 0;
      while (tasks.length < intensityConfig.count && loopSafety < 20) {
        loopSafety += 1;
        for (const topicId of weakOrder) {
          if (tasks.length >= intensityConfig.count) break;
          const templates = getQuestTemplatesForTopic(topicId);
          const nextTemplate = templates.find((template, idx) => !usedKeys.has(`${topicId}_${idx}`));
          if (!nextTemplate) continue;
          const templateIdx = templates.indexOf(nextTemplate);
          usedKeys.add(`${topicId}_${templateIdx}`);
          tasks.push({
            id: `quest_${Date.now()}_${tasks.length}`,
            title: nextTemplate.title,
            note: nextTemplate.note,
            minutes: clamp(Math.round(nextTemplate.minutes * intensityConfig.minuteScale), 3, 75),
            action: nextTemplate.action,
            args: nextTemplate.args || {},
            done: false
          });
        }
      }
      return tasks.slice(0, intensityConfig.count);
    }

    function updateQuestProgress() {
      if (!questProgressPct || !questProgressText || !questProgressFill || !questState) return;
      const total = questState.tasks.length;
      const done = questState.tasks.filter((task) => task.done).length;
      const pct = total ? Math.round((done / total) * 100) : 0;
      questProgressPct.textContent = `${pct}% complete`;
      questProgressText.textContent = total
        ? `${done} of ${total} tasks completed`
        : "No active tasks.";
      questProgressFill.style.width = `${pct}%`;
    }

    function renderQuestList() {
      if (!questList || !questMeta || !questState) return;
      questList.innerHTML = "";
      if (!questState.tasks.length) {
        questList.innerHTML = "<div class=\"arena-feedback\">Generate a quest to receive adaptive study tasks tied to your weakest topic signals.</div>";
        questMeta.textContent = "No quest generated yet.";
        updateQuestProgress();
        return;
      }

      const totalMinutes = questState.tasks.reduce((sum, task) => sum + task.minutes, 0);
      const generated = questState.generatedAt
        ? new Date(questState.generatedAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
        : "--:--";
      questMeta.textContent = `${questState.tasks.length} tasks  ${totalMinutes} min  Generated ${generated}`;

      questState.tasks.forEach((task, idx) => {
        const row = document.createElement("article");
        row.className = `quest-item${task.done ? " done" : ""}`;
        row.innerHTML = `
          <div class="quest-item-head">
            <input type="checkbox" aria-label="Mark quest task complete" ${task.done ? "checked" : ""} />
            <div class="quest-title">${task.title}</div>
            <span class="quest-mins">${task.minutes} min</span>
          </div>
          <p class="quest-note">${task.note}</p>
          <div class="quest-actions">
            <button type="button" class="btn btn-ghost">Run Task</button>
          </div>
        `;

        const checkbox = row.querySelector("input[type='checkbox']");
        const runBtn = row.querySelector("button");
        if (checkbox) {
          checkbox.addEventListener("change", () => {
            task.done = checkbox.checked;
            persistQuestState();
            row.classList.toggle("done", task.done);
            updateQuestProgress();
            if (task.done && questState.tasks.every((entry) => entry.done)) {
              showStatus("Quest completed. Generate the next adaptive round.");
            }
          });
        }
        if (runBtn) {
          runBtn.addEventListener("click", () => {
            runQuestTask(task);
          });
        }
        questList.appendChild(row);
      });
      updateQuestProgress();
    }

    function clearQuest(shouldPersist = true) {
      questState = defaultQuestState();
      if (questIntensity) questIntensity.value = "standard";
      if (shouldPersist) {
        safeWrite(STORAGE.questState, questState);
      }
      renderQuestList();
      updateMissionControl();
    }

    function generateAdaptiveQuest(forcedIntensity = "") {
      const signals = computeMissionSignals();
      const level = forcedIntensity || (questIntensity ? questIntensity.value : "standard");
      const config = QUEST_INTENSITY[level] || QUEST_INTENSITY.standard;
      if (questIntensity) questIntensity.value = level in QUEST_INTENSITY ? level : "standard";

      questState = {
        generatedAt: Date.now(),
        intensity: questIntensity ? questIntensity.value : "standard",
        tasks: buildQuestTasks(signals, config)
      };
      persistQuestState();
      renderQuestList();
      updateMissionControl();
      showStatus(`Adaptive quest generated (${questState.tasks.length} tasks).`);
    }

    function runNextQuestTask() {
      if (!questState || !Array.isArray(questState.tasks) || !questState.tasks.length) {
        showStatus("Generate a quest first.");
        return;
      }
      const nextTask = questState.tasks.find((task) => !task.done) || questState.tasks[0];
      runQuestTask(nextTask);
    }

    function updateMissionControl() {
      if (
        !masteryRing
        || !masteryScore
        || !missionRecallScore
        || !missionArenaScore
        || !missionIntuitionScore
        || !missionChecklistScore
        || !missionWeaknessMeta
      ) {
        return;
      }

      const signals = computeMissionSignals();
      const weakest = signals.sortedTopics[0];
      const ringDeg = Math.round((signals.composite / 100) * 360);
      masteryRing.style.background =
        `radial-gradient(circle at center, #fff 52%, transparent 54%),` +
        `conic-gradient(from 270deg, #b22323 0deg, #b22323 ${ringDeg}deg, #ddc6ad ${ringDeg}deg)`;
      masteryScore.textContent = formatPercent(signals.composite);
      missionRecallScore.textContent = formatPercent(signals.recallPct);
      missionArenaScore.textContent = formatPercent(signals.arenaPct);
      missionIntuitionScore.textContent = formatPercent(signals.intuitionPct);
      missionChecklistScore.textContent = formatPercent(signals.checklistPct);
      missionWeaknessMeta.textContent = weakest
        ? `Weakest focus: ${weakest.label}`
        : "Weakest focus: pending";
      renderMissionHeatmap(signals.topicScores);
      setMissionAlertByScore(signals.composite, weakest ? weakest.label : "core topics");
    }

    function initMissionControl() {
      if (
        !masteryRing
        || !questIntensity
        || !generateQuestBtn
        || !runNextQuestBtn
        || !clearQuestBtn
        || !refreshMissionBtn
      ) {
        return;
      }

      questState = sanitizeQuestState(safeRead(STORAGE.questState, null));
      questIntensity.value = questState.intensity in QUEST_INTENSITY
        ? questState.intensity
        : "standard";

      generateQuestBtn.addEventListener("click", () => generateAdaptiveQuest());
      runNextQuestBtn.addEventListener("click", runNextQuestTask);
      clearQuestBtn.addEventListener("click", () => {
        clearQuest(true);
        showStatus("Adaptive quest cleared.");
      });
      refreshMissionBtn.addEventListener("click", () => {
        updateMissionControl();
        showStatus("Mastery analysis refreshed.");
      });
      questIntensity.addEventListener("change", () => {
        if (!questState) questState = defaultQuestState();
        questState.intensity = questIntensity.value in QUEST_INTENSITY ? questIntensity.value : "standard";
        persistQuestState();
      });

      renderQuestList();
      updateMissionControl();
    }

    function scrollToSection(id) {
      const target = document.getElementById(id);
      if (!target) return;
      target.scrollIntoView({ behavior: "smooth", block: "start" });
    }

    function buildCommandItems() {
      commandItems = [
        {
          title: "Jump to Mission Control",
          meta: "Navigate",
          keywords: "mission dashboard mastery heatmap quest",
          run: () => scrollToSection("missionControl")
        },
        {
          title: "Jump to Topic Architecture",
          meta: "Navigate",
          keywords: "topic architecture lecture map",
          run: () => scrollToSection("topicArchitecture")
        },
        {
          title: "Jump to Formula Engine",
          meta: "Navigate",
          keywords: "formula equations math",
          run: () => scrollToSection("formulaEngine")
        },
        {
          title: "Formula Lab: Compute Active Formula",
          meta: "Action",
          keywords: "formula compute evaluate equation",
          run: () => computeActiveFormula()
        },
        {
          title: "Formula Lab: Fetch Variable Data",
          meta: "Action",
          keywords: "formula fetch fred bls series",
          run: () => fetchSelectedFormulaVariable()
        },
        {
          title: "Formula Lab: Reset Playground",
          meta: "Action",
          keywords: "formula reset data bindings",
          run: () => resetFormulaLabState(true, false)
        },
        {
          title: "Jump to Graphing Playbook",
          meta: "Navigate",
          keywords: "graph supply demand playbook",
          run: () => scrollToSection("graphPlaybook")
        },
        {
          title: "Jump to Market Dynamics Lab",
          meta: "Navigate",
          keywords: "market lab ceiling floor shortage surplus",
          run: () => scrollToSection("marketLab")
        },
        {
          title: "Jump to Macro Transmission Studio",
          meta: "Navigate",
          keywords: "macro linked graphs ad as money loanable phillips",
          run: () => scrollToSection("macroLinkStudio")
        },
        {
          title: "Jump to Causal Intuition Studio",
          meta: "Navigate",
          keywords: "intuition causal logic why reasoning",
          run: () => scrollToSection("intuitionStudio")
        },
        {
          title: "Jump to Quant Arena",
          meta: "Navigate",
          keywords: "quant arena numbers practice",
          run: () => scrollToSection("quantArena")
        },
        {
          title: "Jump to Recall Trainer",
          meta: "Navigate",
          keywords: "flashcards recall trainer",
          run: () => scrollToSection("recallTrainer")
        },
        {
          title: "Jump to Resource Dock",
          meta: "Navigate",
          keywords: "resource dock pdf mock",
          run: () => scrollToSection("resourceDock")
        },
        {
          title: "Generate Adaptive Quest",
          meta: "Action",
          keywords: "quest planner adaptive generate",
          run: () => generateAdaptiveQuest()
        },
        {
          title: "Run Next Quest Task",
          meta: "Action",
          keywords: "quest next task run",
          run: () => runNextQuestTask()
        },
        {
          title: "Start 75-Minute Exam Timer",
          meta: "Action",
          keywords: "timer start exam 75",
          run: () => {
            timerMinutes.value = "75";
            resetTimerFromInput();
            startTimer();
          }
        },
        {
          title: "Pause Exam Timer",
          meta: "Action",
          keywords: "timer pause",
          run: () => pauseTimer()
        },
        {
          title: "New Recall Prompt",
          meta: "Action",
          keywords: "recall prompt flashcard next",
          run: () => pickPrompt()
        },
        {
          title: "Submit Recall Answer",
          meta: "Action",
          keywords: "recall submit answer multiple choice",
          run: () => submitRecallAnswer()
        },
        {
          title: "Clear Recall Selection",
          meta: "Action",
          keywords: "recall clear choice",
          run: () => clearAnswerBox()
        },
        {
          title: "Reveal Recall Answer",
          meta: "Action",
          keywords: "recall reveal answer",
          run: () => revealAnswer()
        },
        {
          title: "Generate Quant Challenge",
          meta: "Action",
          keywords: "quant arena generate challenge",
          run: () => generateArenaChallenge()
        },
        {
          title: "Grade Intuition Predictions",
          meta: "Action",
          keywords: "intuition grade predictions directions",
          run: () => gradeIntuitionPredictions()
        },
        {
          title: "Intuition Hint Step",
          meta: "Action",
          keywords: "intuition hint mechanism step coach",
          run: () => revealIntuitionHintStep()
        },
        {
          title: "Reveal Intuition Logic",
          meta: "Action",
          keywords: "intuition reveal why chain",
          run: () => revealIntuitionLogic()
        },
        {
          title: "Next Intuition Scenario",
          meta: "Action",
          keywords: "intuition next scenario adaptive",
          run: () => nextIntuitionScenario()
        },
        {
          title: "Check Quant Answer",
          meta: "Action",
          keywords: "quant check answer grade",
          run: () => checkArenaAnswer()
        },
        {
          title: "Reveal Quant Solution",
          meta: "Action",
          keywords: "quant reveal solution",
          run: () => revealArenaSolution()
        },
        {
          title: "Market Preset: Demand Surge",
          meta: "Scenario",
          keywords: "market demand surge preset",
          run: () => applyMarketPreset("demand_surge")
        },
        {
          title: "Market Preset: Supply Shock",
          meta: "Scenario",
          keywords: "market supply shock preset",
          run: () => applyMarketPreset("supply_shock")
        },
        {
          title: "Market Preset: Binding Ceiling",
          meta: "Scenario",
          keywords: "market ceiling binding shortage",
          run: () => applyMarketPreset("ceiling_bind")
        },
        {
          title: "Market Preset: Binding Floor",
          meta: "Scenario",
          keywords: "market floor binding surplus",
          run: () => applyMarketPreset("floor_bind")
        },
        {
          title: "Macro Preset: Monetary Easing",
          meta: "Scenario",
          keywords: "macro preset monetary easing ad as money market",
          run: () => applyMacroPreset("monetary_easing")
        },
        {
          title: "Macro Preset: Fiscal Expansion",
          meta: "Scenario",
          keywords: "macro preset fiscal expansion loanable funds",
          run: () => applyMacroPreset("fiscal_expansion")
        },
        {
          title: "Macro Preset: Stagflation Shock",
          meta: "Scenario",
          keywords: "macro preset stagflation supply shock",
          run: () => applyMacroPreset("stagflation_shock")
        },
        {
          title: "Focus Resource Filter",
          meta: "Action",
          keywords: "resources filter search",
          run: () => resourceFilter.focus()
        },
        {
          title: "Lock Session",
          meta: "Security",
          keywords: "lock logout auth session",
          run: () => lockSessionNow("Session locked. Enter an authorized name.")
        },
        {
          title: "Print Layout",
          meta: "Action",
          keywords: "print pdf export",
          run: () => window.print()
        }
      ];
      filteredCommandItems = commandItems.slice();
      commandActiveIndex = 0;
    }

    function renderCommandList() {
      if (!commandList) return;
      commandList.innerHTML = "";

      if (!filteredCommandItems.length) {
        const empty = document.createElement("div");
        empty.className = "command-item";
        empty.innerHTML = "<span class=\"title\">No matching actions</span><span class=\"meta\">Try keywords like mission, quest, graph, intuition, timer, arena, recall</span>";
        commandList.appendChild(empty);
        return;
      }

      filteredCommandItems.forEach((item, idx) => {
        const row = document.createElement("button");
        row.type = "button";
        row.className = `command-item${idx === commandActiveIndex ? " active" : ""}`;
        row.innerHTML = `<span class="title">${item.title}</span><span class="meta">${item.meta}</span>`;
        row.addEventListener("mouseenter", () => {
          commandActiveIndex = idx;
          renderCommandList();
        });
        row.addEventListener("click", () => {
          closeCommandPalette();
          item.run();
        });
        commandList.appendChild(row);
      });
    }

    function filterCommandItems() {
      if (!commandInput) return;
      const query = commandInput.value.trim().toLowerCase();
      filteredCommandItems = commandItems.filter((item) => {
        const hay = `${item.title} ${item.meta} ${item.keywords}`.toLowerCase();
        return !query || hay.includes(query);
      });
      commandActiveIndex = 0;
      renderCommandList();
    }

    function openCommandPalette() {
      if (!commandShell || !commandInput) return;
      if (document.body.classList.contains("auth-locked")) return;
      commandReturnFocus = document.activeElement instanceof HTMLElement
        ? document.activeElement
        : null;
      commandOpen = true;
      commandShell.classList.add("open");
      commandShell.setAttribute("aria-hidden", "false");
      commandInput.value = "";
      filterCommandItems();
      window.setTimeout(() => commandInput.focus(), 0);
    }

    function closeCommandPalette() {
      if (!commandShell) return;
      if (!commandOpen && !commandShell.classList.contains("open")) return;
      commandOpen = false;
      commandShell.classList.remove("open");
      commandShell.setAttribute("aria-hidden", "true");
      const fallbackTarget = commandBtn && document.body.contains(commandBtn) ? commandBtn : null;
      const focusTarget = commandReturnFocus && document.body.contains(commandReturnFocus)
        ? commandReturnFocus
        : fallbackTarget;
      commandReturnFocus = null;
      if (focusTarget && typeof focusTarget.focus === "function") {
        window.setTimeout(() => focusTarget.focus(), 0);
      }
    }

    function toggleCommandPalette() {
      if (commandOpen) {
        closeCommandPalette();
      } else {
        openCommandPalette();
      }
    }

    function moveCommandSelection(delta) {
      if (!filteredCommandItems.length) return;
      const size = filteredCommandItems.length;
      commandActiveIndex = (commandActiveIndex + delta + size) % size;
      renderCommandList();
      const activeRow = commandList.querySelector(".command-item.active");
      if (activeRow && typeof activeRow.scrollIntoView === "function") {
        activeRow.scrollIntoView({ block: "nearest" });
      }
    }

    function runActiveCommand() {
      if (!filteredCommandItems.length) return;
      const item = filteredCommandItems[commandActiveIndex];
      closeCommandPalette();
      item.run();
    }

    function initCommandPalette() {
      if (!commandBtn || !commandShell || !commandBackdrop || !commandInput || !commandList) return;
      buildCommandItems();
      renderCommandList();

      commandBtn.addEventListener("click", toggleCommandPalette);
      commandBackdrop.addEventListener("click", closeCommandPalette);
      commandInput.addEventListener("input", filterCommandItems);
      commandInput.addEventListener("keydown", (event) => {
        if (event.key === "ArrowDown") {
          event.preventDefault();
          moveCommandSelection(1);
        } else if (event.key === "ArrowUp") {
          event.preventDefault();
          moveCommandSelection(-1);
        } else if (event.key === "Enter") {
          event.preventDefault();
          runActiveCommand();
        } else if (event.key === "Escape") {
          event.preventDefault();
          closeCommandPalette();
        }
      });
    }

    function runInternalDiagnostics() {
      const issues = [];
      const currentMarketState = { ...marketLabState };
      const currentMacroState = { ...macroLinkState };
      const criticalNodes = [
        ["authGate", authGate],
        ["authNameInput", authNameInput],
        ["authUnlockBtn", authUnlockBtn],
        ["sessionGuardChip", sessionGuardChip],
        ["resourceGrid", resourceGrid],
        ["commandShell", commandShell],
        ["marketSvg", marketSvg],
        ["macroLayoutMode", macroLayoutMode],
        ["macroPairMode", macroPairMode],
        ["macroChartGrid", macroChartGrid],
        ["macroParticleCanvas", macroParticleCanvas],
        ["macroDemandShift", macroDemandShift],
        ["macroExpectedInflation", macroExpectedInflation],
        ["macroNarrative", macroNarrative],
        ["macroAdPath", macroAdPath],
        ["macroMoneyDemand", macroMoneyDemand],
        ["macroLfSupply", macroLfSupply],
        ["macroPcPath", macroPcPath],
        ["arenaPrompt", arenaPrompt],
        ["flashQ", flashQ],
        ["recallOptions", recallOptions],
        ["submitAnswerBtn", submitAnswerBtn],
        ["recallFeedback", recallFeedback],
        ["intuitionScenarioCards", intuitionScenarioCards],
        ["intuitionTagFilter", intuitionTagFilter],
        ["intuitionConfidence", intuitionConfidence],
        ["intuitionCoachMeta", intuitionCoachMeta],
        ["intuitionVars", intuitionVars],
        ["intuitionHintBtn", intuitionHintBtn],
        ["intuitionFeedback", intuitionFeedback],
        ["intuitionDebrief", intuitionDebrief],
        ["intuitionChain", intuitionChain],
        ["masteryRing", masteryRing],
        ["missionHeatmap", missionHeatmap],
        ["questIntensity", questIntensity],
        ["generateQuestBtn", generateQuestBtn],
        ["questList", questList],
        ["formulaCatalog", formulaCatalog],
        ["formulaActiveTitle", formulaActiveTitle],
        ["formulaVariableButtons", formulaVariableButtons],
        ["formulaVariableSelect", formulaVariableSelect],
        ["formulaSourceSelect", formulaSourceSelect],
        ["formulaComputeBtn", formulaComputeBtn],
        ["formulaComputeResult", formulaComputeResult],
        ["liveStatus", liveStatus]
      ];

      criticalNodes.forEach(([label, node]) => {
        if (!node) {
          issues.push(`dom-missing-${label}`);
        }
      });
      if (!AUTH_ALIASES.hanna || !AUTH_ALIASES.ian) {
        issues.push("auth-aliases-missing");
      }
      if (AUTH_THROTTLE.maxAttempts < 3 || AUTH_THROTTLE.lockMs < 5000) {
        issues.push("auth-throttle-unsafe");
      }
      if (
        sessionIdleMinutes < SESSION_SECURITY.minIdleMinutes
        || sessionIdleMinutes > SESSION_SECURITY.maxIdleMinutes
      ) {
        issues.push("session-idle-policy-out-of-range");
      }
      if (!QUEST_INTENSITY.light || !QUEST_INTENSITY.standard || !QUEST_INTENSITY.challenge) {
        issues.push("quest-intensity-config-missing");
      }
      if (!QUEST_LIBRARY.foundations || !QUEST_LIBRARY.national || !QUEST_LIBRARY.retrieval) {
        issues.push("quest-library-missing-core");
      }
      if (!Array.isArray(FORMULA_CATALOG) || FORMULA_CATALOG.length < 10) {
        issues.push("formula-catalog-missing");
      } else {
        FORMULA_CATALOG.forEach((formula, fIdx) => {
          if (!formula || typeof formula !== "object") {
            issues.push(`formula-shape-${fIdx}`);
            return;
          }
          if (!formula.id || !formula.title || !formula.latex || !Array.isArray(formula.variables) || formula.variables.length < 2) {
            issues.push(`formula-meta-${fIdx}`);
          }
          if (typeof formula.compute !== "function") {
            issues.push(`formula-compute-missing-${fIdx}`);
          } else {
            const probe = {};
            formula.variables.forEach((variableId) => {
              probe[variableId] = 1;
            });
            const result = formula.compute(probe);
            if (!result || typeof result !== "object" || typeof result.ok !== "boolean") {
              issues.push(`formula-compute-shape-${fIdx}`);
            }
          }
          formula.variables.forEach((variableId, vIdx) => {
            if (!FORMULA_VARIABLES[variableId]) {
              issues.push(`formula-variable-missing-${fIdx}-${vIdx}`);
            }
          });
        });
      }
      if (!formulaLabState || typeof formulaLabState !== "object") {
        issues.push("formula-state-missing");
      } else {
        const activeFormula = getActiveFormula();
        if (!activeFormula) {
          issues.push("formula-active-missing");
        } else if (!activeFormula.variables.includes(formulaLabState.selectedVariableId)) {
          issues.push("formula-active-variable-missing");
        }
      }
      if (!MACRO_LINK_LAYOUTS["2x2"] || !MACRO_LINK_LAYOUTS.adas_money) {
        issues.push("macro-layout-config-missing");
      }
      if (!macroLinkState || typeof macroLinkState !== "object") {
        issues.push("macro-state-missing");
      } else {
        if (macroLinkState.layoutMode !== "2x2" && macroLinkState.layoutMode !== "1x2") {
          issues.push("macro-layout-invalid");
        }
        if (!(macroLinkState.pairMode in MACRO_LINK_LAYOUTS) || macroLinkState.pairMode === "2x2") {
          issues.push("macro-pair-invalid");
        }
      }

      for (let i = 0; i < 60; i += 1) {
        marketLabState = {
          demandShift: randomInt(-40, 40),
          supplyShift: randomInt(-40, 40),
          policy: randomChoice(["none", "ceiling", "floor"]),
          controlPrice: randomInt(2, 46)
        };
        const state = computeMarketState();
        const values = [state.pStar, state.qStar, state.qdAtPc, state.qsAtPc, state.gap];
        if (!values.every(Number.isFinite)) {
          issues.push(`market-state-${i}`);
        }
        if (state.gap < 0) {
          issues.push(`market-gap-${i}`);
        }
      }
      marketLabState = currentMarketState;

      for (let i = 0; i < 60; i += 1) {
        const randomState = sanitizeMacroLinkState({
          demandShift: randomInt(-40, 40),
          supplyShift: randomInt(-30, 30),
          moneySupplyShift: randomInt(-40, 40),
          moneyDemandShift: randomInt(-40, 40),
          savingShift: randomInt(-30, 30),
          investmentShift: randomInt(-30, 30),
          expectedInflation: randomInt(-10, 100) / 10,
          layoutMode: randomChoice(["2x2", "1x2"]),
          pairMode: randomChoice(Object.keys(MACRO_LINK_LAYOUTS).filter((key) => key !== "2x2"))
        });
        const sample = computeMacroLinkCore(randomState);
        const values = [
          sample.yEq,
          sample.pEq,
          sample.iEq,
          sample.rEq,
          sample.unemployment,
          sample.piActual,
          sample.rateGap
        ];
        if (!values.every(Number.isFinite)) {
          issues.push(`macro-state-${i}`);
        }
      }
      macroLinkState = currentMacroState;

      const generators = [
        generateGDPChallenge,
        generateDeflatorChallenge,
        generateLaborChallenge,
        generateSavingChallenge,
        generateRealRateChallenge,
        generateElasticityChallenge
      ];

      generators.forEach((generator, gIdx) => {
        [false, true].forEach((isChallenge, modeIdx) => {
          for (let i = 0; i < 20; i += 1) {
            const sample = generator(isChallenge);
            if (!sample || typeof sample !== "object") {
              issues.push(`arena-shape-${gIdx}-${modeIdx}-${i}`);
              continue;
            }
            if (!Number.isFinite(sample.answer) || !Number.isFinite(sample.tolerance) || sample.tolerance <= 0) {
              issues.push(`arena-number-${gIdx}-${modeIdx}-${i}`);
            }
            if (!sample.promptHtml || !sample.solutionHtml || !sample.type) {
              issues.push(`arena-content-${gIdx}-${modeIdx}-${i}`);
            }
          }
        });
      });

      if (!Array.isArray(prompts) || prompts.length < 6) {
        issues.push("recall-prompts-missing");
      } else {
        prompts.forEach((prompt, pIdx) => {
          if (!prompt || typeof prompt !== "object") {
            issues.push(`recall-prompt-shape-${pIdx}`);
            return;
          }
          if (!prompt.q || !prompt.a || !Array.isArray(prompt.choices)) {
            issues.push(`recall-prompt-content-${pIdx}`);
            return;
          }
          if (prompt.choices.length < 2) {
            issues.push(`recall-prompt-choices-${pIdx}`);
          }
          if (!Number.isInteger(prompt.correctChoice) || prompt.correctChoice < 0 || prompt.correctChoice >= prompt.choices.length) {
            issues.push(`recall-prompt-correct-${pIdx}`);
          }
        });
      }

      if (!arenaStats.byType || typeof arenaStats.byType !== "object") {
        issues.push("arena-by-type-missing");
      } else {
        ARENA_TYPES.forEach((type) => {
          const node = arenaStats.byType[type];
          if (!node || typeof node !== "object") {
            issues.push(`arena-by-type-${type}-missing`);
            return;
          }
          if (!Number.isFinite(node.solved) || !Number.isFinite(node.correct)) {
            issues.push(`arena-by-type-${type}-nan`);
            return;
          }
          if (node.correct > node.solved || node.solved < 0 || node.correct < 0) {
            issues.push(`arena-by-type-${type}-range`);
          }
        });
      }

      if (!Array.isArray(intuitionScenarios) || intuitionScenarios.length < 4) {
        issues.push("intuition-scenarios-missing");
      } else {
        intuitionScenarios.forEach((scenario, sIdx) => {
          if (!scenario || typeof scenario !== "object") {
            issues.push(`intuition-shape-${sIdx}`);
            return;
          }
          if (!scenario.id || !scenario.title || !scenario.tag || !scenario.shock) {
            issues.push(`intuition-metadata-${sIdx}`);
          }
          if (!Array.isArray(scenario.chain) || scenario.chain.length < 2) {
            issues.push(`intuition-chain-${sIdx}`);
          }
          if (!Array.isArray(scenario.variables) || scenario.variables.length < 3) {
            issues.push(`intuition-vars-${sIdx}`);
            return;
          }
          scenario.variables.forEach((item, iIdx) => {
            if (!item.id || !item.label || !item.why) {
              issues.push(`intuition-var-shape-${sIdx}-${iIdx}`);
            }
            if (!INTUITION_OPTIONS.some((option) => option.value === item.answer)) {
              issues.push(`intuition-answer-${sIdx}-${iIdx}`);
            }
          });
        });
      }
      if (!INTUITION_TAG_FILTERS.all || !INTUITION_CONFIDENCE.medium) {
        issues.push("intuition-config-missing");
      }
      if (!intuitionState || typeof intuitionState !== "object") {
        issues.push("intuition-state-missing");
      } else {
        if (!(normalizeIntuitionTagFilter(intuitionState.tagFilter) in INTUITION_TAG_FILTERS)) {
          issues.push("intuition-filter-invalid");
        }
        if (!(normalizeIntuitionConfidence(intuitionState.confidence) in INTUITION_CONFIDENCE)) {
          issues.push("intuition-confidence-invalid");
        }
        if (!Number.isFinite(intuitionState.scoreSum) || intuitionState.scoreSum < 0) {
          issues.push("intuition-score-sum-invalid");
        }
        intuitionScenarios.forEach((scenario, sIdx) => {
          const stats = sanitizeIntuitionScenarioStats(
            intuitionState.scenarioStats ? intuitionState.scenarioStats[scenario.id] : null,
            scenario
          );
          if (stats.perfect > stats.attempts || stats.scoreSum > (stats.attempts * 100)) {
            issues.push(`intuition-scenario-stats-${sIdx}`);
          }
          scenario.variables.forEach((item, iIdx) => {
            const varStats = sanitizeIntuitionVarStats(stats.byVar[item.id]);
            if (varStats.correct > varStats.attempts) {
              issues.push(`intuition-var-stats-${sIdx}-${iIdx}`);
            }
          });
        });
      }

      if (!questState || typeof questState !== "object") {
        issues.push("quest-state-missing");
      } else {
        if (!(questState.intensity in QUEST_INTENSITY)) {
          issues.push("quest-intensity-invalid");
        }
        if (!Array.isArray(questState.tasks)) {
          issues.push("quest-tasks-invalid");
        }
      }

      if (issues.length) {
        console.warn("Internal diagnostics failed", issues.slice(0, 8));
        if (diagnosticsChip) {
          diagnosticsChip.textContent = `Diagnostics: ${issues.length} issue(s)`;
          diagnosticsChip.classList.remove("chip-status-ok");
          diagnosticsChip.classList.add("chip-status-warn");
        }
        showStatus(`Diagnostics flagged ${issues.length} issue(s).`);
      } else {
        console.info("Internal diagnostics passed.");
        if (diagnosticsChip) {
          diagnosticsChip.textContent = "Diagnostics: passed";
          diagnosticsChip.classList.remove("chip-status-warn");
          diagnosticsChip.classList.add("chip-status-ok");
        }
      }
      if (adminModeMeta && activeAuth && activeAuth.role === "admin") {
        adminModeMeta.textContent = issues.length
          ? `Admin mode active. Diagnostics: ${issues.length} issue(s) detected.`
          : "Admin mode active. Diagnostics passed.";
      }
      return issues.length;
    }

    function exportLocalStateSnapshot() {
      if (!activeAuth || activeAuth.role !== "admin") return;
      const payload = {
        exportedAt: new Date().toISOString(),
        user: activeAuth,
        state: {
          checks: safeRead(STORAGE.checks, null),
          mastered: safeRead(STORAGE.mastered, null),
          minutes: safeRead(STORAGE.minutes, null),
          cards: safeRead(STORAGE.cards, null),
          formulaLab: safeRead(STORAGE.formulaLab, null),
          formulaApiConfigured: {
            fred: Boolean((safeRead(STORAGE.formulaApi, {}) || {}).fredKey),
            bls: Boolean((safeRead(STORAGE.formulaApi, {}) || {}).blsKey)
          },
          marketLab: safeRead(STORAGE.marketLab, null),
          macroLink: safeRead(STORAGE.macroLink, null),
          arenaStats: safeRead(STORAGE.arenaStats, null),
          arenaPrefs: safeRead(STORAGE.arenaPrefs, null),
          intuitionState: safeRead(STORAGE.intuitionState, null),
          questState: safeRead(STORAGE.questState, null)
        }
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const href = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = href;
      a.download = `econ205_state_${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(href);
      showStatus("Admin state export generated.");
    }

    function initAdminControls() {
      if (adminDiagnosticsBtn) {
        adminDiagnosticsBtn.addEventListener("click", () => {
          if (!activeAuth || activeAuth.role !== "admin") return;
          runInternalDiagnostics();
        });
      }
      if (adminRunDiagnosticsBtn) {
        adminRunDiagnosticsBtn.addEventListener("click", () => {
          if (!activeAuth || activeAuth.role !== "admin") return;
          runInternalDiagnostics();
        });
      }
      if (adminExportStateBtn) {
        adminExportStateBtn.addEventListener("click", exportLocalStateSnapshot);
      }
      if (adminHardResetBtn) {
        adminHardResetBtn.addEventListener("click", resetAllProgress);
      }
      if (adminSaveIdleBtn) {
        adminSaveIdleBtn.addEventListener("click", () => {
          if (!activeAuth || activeAuth.role !== "admin") return;
          persistIdleMinutesPolicy(adminIdleMinutes ? adminIdleMinutes.value : sessionIdleMinutes);
          markSessionActivity(true);
          updateSessionSecurityUI(getIdleLockMs());
          showStatus(`Idle lock policy saved: ${sessionIdleMinutes} minute${sessionIdleMinutes === 1 ? "" : "s"}.`);
        });
      }
      if (adminLockNowBtn) {
        adminLockNowBtn.addEventListener("click", () => {
          if (!activeAuth || activeAuth.role !== "admin") return;
          lockSessionNow("Session locked by admin.");
        });
      }
    }

    function resetAllProgress() {
      if (!window.confirm("Reset checklist, flashcard mastery, timer settings, mission quests, formula/graph labs, and quant arena stats?")) {
        return;
      }
      try {
        localStorage.removeItem(STORAGE.checks);
        localStorage.removeItem(STORAGE.mastered);
        localStorage.removeItem(STORAGE.minutes);
        localStorage.removeItem(STORAGE.cards);
        localStorage.removeItem(STORAGE.formulaLab);
        localStorage.removeItem(STORAGE.formulaApi);
        localStorage.removeItem(STORAGE.marketLab);
        localStorage.removeItem(STORAGE.macroLink);
        localStorage.removeItem(STORAGE.arenaStats);
        localStorage.removeItem(STORAGE.arenaPrefs);
        localStorage.removeItem(STORAGE.intuitionState);
        localStorage.removeItem(STORAGE.questState);
        localStorage.removeItem(STORAGE.idleMinutes);
      } catch {
        // Ignore storage failures.
      }

      masteredSet = new Set();
      cardStats = prompts.map(() => defaultCard());
      checks = Array(dailyChecks.length).fill(false);
      resourceFilter.value = "";
      applyResourceFilter();
      renderChecks();
      resetTimerFromInput();
      marketLabState = { ...LAB_DEFAULT_STATE };
      if (labDemandShift && labSupplyShift && labPolicyType && labControlPrice) {
        labDemandShift.value = String(marketLabState.demandShift);
        labSupplyShift.value = String(marketLabState.supplyShift);
        labPolicyType.value = marketLabState.policy;
        labControlPrice.value = String(marketLabState.controlPrice);
        updateMarketLab();
      }
      macroLinkState = { ...MACRO_LINK_DEFAULT_STATE };
      updateMacroLinkStudio(false, { animate: false, burst: false });
      stopMacroParticleLoop(true);
      resetFormulaLabState(false, true);
      stopArenaTimer();
      arenaChallenge = null;
      arenaStats = defaultArenaStats();
      sessionIdleMinutes = SESSION_SECURITY.defaultIdleMinutes;
      if (adminIdleMinutes) adminIdleMinutes.value = String(sessionIdleMinutes);
      updateSessionSecurityUI();
      updateArenaStatsUI();
      if (arenaType && arenaDifficulty) {
        arenaType.value = "mixed";
        arenaDifficulty.value = "standard";
      }
      arenaSeconds = 120;
      renderArenaTimer();
      if (arenaPrompt) {
        arenaPrompt.innerHTML = "<h3>Challenge Ready</h3><p>Press <strong>Generate Challenge</strong> to start a timed quantitative problem.</p>";
        typesetMath(arenaPrompt);
      }
      if (arenaSolution) {
        arenaSolution.innerHTML = "";
        arenaSolution.classList.remove("show");
      }
      if (arenaAnswer) arenaAnswer.value = "";
      setArenaFeedback("Arena reset. Generate a fresh challenge.", "");
      resetIntuitionStudioState(false);
      clearQuest(false);
      pickPrompt();
      showStatus("All interactive progress reset, including formula, multigraph, market, mission, intuition, and quant arenas.");
    }

    function initRevealEffects() {
      if (!revealTargets.length) return;
      revealTargets.forEach((node) => node.classList.add("reveal"));

      const reduceMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      if (reduceMotion || !("IntersectionObserver" in window)) {
        revealTargets.forEach((node) => node.classList.add("is-visible"));
        return;
      }

      const observer = new IntersectionObserver((entries, obs) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("is-visible");
            obs.unobserve(entry.target);
          }
        });
      }, {
        threshold: 0.16,
        rootMargin: "0px 0px -8% 0px"
      });

      revealTargets.forEach((node) => observer.observe(node));
    }

    function initParallax() {
      if (!parallaxLayers.length) return;
      if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

      let ticking = false;

      const render = () => {
        const y = window.scrollY || window.pageYOffset || 0;
        parallaxLayers.forEach((layer) => {
          const speed = Number.parseFloat(layer.dataset.parallax);
          const delta = Number.isFinite(speed) ? y * speed : 0;
          layer.style.setProperty("--parallax-y", `${delta.toFixed(2)}px`);
        });
        ticking = false;
      };

      const requestRender = () => {
        if (ticking) return;
        ticking = true;
        window.requestAnimationFrame(render);
      };

      window.addEventListener("scroll", requestRender, { passive: true });
      window.addEventListener("resize", requestRender);
      render();
    }

    function initHeroPointerMotion() {
      if (!hero) return;
      if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;

      hero.addEventListener("pointermove", (event) => {
        const rect = hero.getBoundingClientRect();
        if (!rect.width || !rect.height) return;
        const x = ((event.clientX - rect.left) / rect.width) - 0.5;
        const y = ((event.clientY - rect.top) / rect.height) - 0.5;
        hero.style.setProperty("--hero-shift-x", `${(x * 18).toFixed(2)}px`);
        hero.style.setProperty("--hero-shift-y", `${(y * 14).toFixed(2)}px`);
      });

      hero.addEventListener("pointerleave", () => {
        hero.style.setProperty("--hero-shift-x", "0px");
        hero.style.setProperty("--hero-shift-y", "0px");
      });
    }

    function bootstrapMath() {
      if (window.MathJax && typeof window.MathJax.typesetPromise === "function") {
        typesetMath(document.body);
        return;
      }

      let checksRemaining = 60;
      const intervalId = window.setInterval(() => {
        checksRemaining -= 1;
        if (window.MathJax && typeof window.MathJax.typesetPromise === "function") {
          window.clearInterval(intervalId);
          typesetMath(document.body);
        } else if (checksRemaining <= 0) {
          window.clearInterval(intervalId);
        }
      }, 120);
    }

    function isTypingTarget(target) {
      if (!target) return false;
      const tag = target.tagName;
      return tag === "INPUT" || tag === "TEXTAREA" || target.isContentEditable;
    }

    document.addEventListener("keydown", (event) => {
      const key = event.key.toLowerCase();
      if (document.body.classList.contains("auth-locked")) return;
      if ((event.metaKey || event.ctrlKey) && key === "k") {
        event.preventDefault();
        toggleCommandPalette();
        return;
      }
      if (commandOpen) {
        if (key === "escape") {
          event.preventDefault();
          closeCommandPalette();
        }
        return;
      }
      if (isTypingTarget(document.activeElement)) return;

      if (key === "n") {
        event.preventDefault();
        pickPrompt();
      } else if (key === "s") {
        event.preventDefault();
        submitRecallAnswer();
      } else if (key === "r") {
        event.preventDefault();
        revealAnswer();
      } else if (key === "m") {
        event.preventDefault();
        markCurrentMastered();
      } else if (key === "1") {
        event.preventDefault();
        rateCurrent("again");
      } else if (key === "2") {
        event.preventDefault();
        rateCurrent("hard");
      } else if (key === "3") {
        event.preventDefault();
        rateCurrent("good");
      } else if (key === "4") {
        event.preventDefault();
        rateCurrent("easy");
      } else if (key === "i") {
        event.preventDefault();
        nextIntuitionScenario();
      } else if (key === "y") {
        event.preventDefault();
        gradeIntuitionPredictions();
      } else if (key === "j") {
        event.preventDefault();
        revealIntuitionHintStep();
      } else if (key === "h") {
        event.preventDefault();
        revealIntuitionLogic();
      } else if (key === "q") {
        event.preventDefault();
        generateAdaptiveQuest();
      } else if (key === "x") {
        event.preventDefault();
        runNextQuestTask();
      } else if (key === "g") {
        event.preventDefault();
        generateArenaChallenge();
      } else if (key === "k") {
        event.preventDefault();
        checkArenaAnswer();
      } else if (key === "v") {
        event.preventDefault();
        revealArenaSolution();
      } else if (key === "/") {
        event.preventDefault();
        resourceFilter.focus();
      }
    });

    newCardBtn.addEventListener("click", pickPrompt);
    submitAnswerBtn.addEventListener("click", submitRecallAnswer);
    clearAnswerBtn.addEventListener("click", clearAnswerBox);
    showAnswerBtn.addEventListener("click", revealAnswer);
    markMasteredBtn.addEventListener("click", markCurrentMastered);
    clearMasteredBtn.addEventListener("click", resetDeck);
    rateAgainBtn.addEventListener("click", () => rateCurrent("again"));
    rateHardBtn.addEventListener("click", () => rateCurrent("hard"));
    rateGoodBtn.addEventListener("click", () => rateCurrent("good"));
    rateEasyBtn.addEventListener("click", () => rateCurrent("easy"));
    resetChecklistBtn.addEventListener("click", resetChecklist);
    resourceFilter.addEventListener("input", applyResourceFilter);
    timerMinutes.addEventListener("change", resetTimerFromInput);
    startTimerBtn.addEventListener("click", startTimer);
    pauseTimerBtn.addEventListener("click", pauseTimer);
    resetTimerBtn.addEventListener("click", resetTimerFromInput);
    printBtn.addEventListener("click", () => window.print());
    resetAllBtn.addEventListener("click", resetAllProgress);

    const savedMinutes = safeRead(STORAGE.minutes, 75);
    timerMinutes.value = String(
      Number.isFinite(savedMinutes) ? Math.min(240, Math.max(1, savedMinutes)) : 75
    );
    resetTimerFromInput();
    renderChecks();
    applyResourceFilter();
    initFormulaEngine();
    initMarketLab();
    initMacroLinkStudio();
    initIntuitionStudio();
    initArena();
    initMissionControl();
    initAdminControls();
    initCommandPalette();
    initAccessGate();
    initSessionSecurity();
    initRevealEffects();
    initParallax();
    initHeroPointerMotion();
    pickPrompt();
    bootstrapMath();
    runInternalDiagnostics();
    showStatus("Interactive mode ready. Shortcuts: N/S/R/M/1/2/3/4 + I/Y/J/H + Q/X + G/K/V + Cmd/Ctrl+K.");
  </script>
</body>
</html>
